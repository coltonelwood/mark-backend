
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model CryptoProject
 * 
 */
export type CryptoProject = $Result.DefaultSelection<Prisma.$CryptoProjectPayload>
/**
 * Model ProjectDocument
 * 
 */
export type ProjectDocument = $Result.DefaultSelection<Prisma.$ProjectDocumentPayload>
/**
 * Model Business
 * 
 */
export type Business = $Result.DefaultSelection<Prisma.$BusinessPayload>
/**
 * Model BusinessFounder
 * 
 */
export type BusinessFounder = $Result.DefaultSelection<Prisma.$BusinessFounderPayload>
/**
 * Model BusinessDocument
 * 
 */
export type BusinessDocument = $Result.DefaultSelection<Prisma.$BusinessDocumentPayload>
/**
 * Model RevenueReport
 * 
 */
export type RevenueReport = $Result.DefaultSelection<Prisma.$RevenueReportPayload>
/**
 * Model PrivateIdentityVerification
 * 
 */
export type PrivateIdentityVerification = $Result.DefaultSelection<Prisma.$PrivateIdentityVerificationPayload>
/**
 * Model ContactMessage
 * 
 */
export type ContactMessage = $Result.DefaultSelection<Prisma.$ContactMessagePayload>
/**
 * Model LaunchApplication
 * 
 */
export type LaunchApplication = $Result.DefaultSelection<Prisma.$LaunchApplicationPayload>
/**
 * Model TrustScoreEvent
 * 
 */
export type TrustScoreEvent = $Result.DefaultSelection<Prisma.$TrustScoreEventPayload>
/**
 * Model AdminNote
 * 
 */
export type AdminNote = $Result.DefaultSelection<Prisma.$AdminNotePayload>
/**
 * Model SystemLog
 * 
 */
export type SystemLog = $Result.DefaultSelection<Prisma.$SystemLogPayload>
/**
 * Model DexPair
 * 
 */
export type DexPair = $Result.DefaultSelection<Prisma.$DexPairPayload>
/**
 * Model RateLimitRecord
 * 
 */
export type RateLimitRecord = $Result.DefaultSelection<Prisma.$RateLimitRecordPayload>
/**
 * Model SecurityEvent
 * 
 */
export type SecurityEvent = $Result.DefaultSelection<Prisma.$SecurityEventPayload>
/**
 * Model BlockedEntity
 * 
 */
export type BlockedEntity = $Result.DefaultSelection<Prisma.$BlockedEntityPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  USER: 'USER',
  ADMIN: 'ADMIN',
  SUPER_ADMIN: 'SUPER_ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const TokenType: {
  UTILITY: 'UTILITY',
  GOVERNANCE: 'GOVERNANCE',
  EQUITY: 'EQUITY',
  REVENUE_SHARE: 'REVENUE_SHARE',
  MEMBERSHIP: 'MEMBERSHIP'
};

export type TokenType = (typeof TokenType)[keyof typeof TokenType]


export const VestingType: {
  LINEAR: 'LINEAR',
  CLIFF_LINEAR: 'CLIFF_LINEAR',
  MILESTONE: 'MILESTONE',
  CUSTOM: 'CUSTOM'
};

export type VestingType = (typeof VestingType)[keyof typeof VestingType]


export const ProjectStatus: {
  DRAFT: 'DRAFT',
  PENDING_REVIEW: 'PENDING_REVIEW',
  IN_REVIEW: 'IN_REVIEW',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  LIVE: 'LIVE',
  PAUSED: 'PAUSED',
  COMPLETED: 'COMPLETED'
};

export type ProjectStatus = (typeof ProjectStatus)[keyof typeof ProjectStatus]


export const KYBLevel: {
  NONE: 'NONE',
  BASIC: 'BASIC',
  STANDARD: 'STANDARD',
  ENHANCED: 'ENHANCED'
};

export type KYBLevel = (typeof KYBLevel)[keyof typeof KYBLevel]


export const BusinessStatus: {
  DRAFT: 'DRAFT',
  PENDING_REVIEW: 'PENDING_REVIEW',
  IN_REVIEW: 'IN_REVIEW',
  KYB_PENDING: 'KYB_PENDING',
  KYB_VERIFIED: 'KYB_VERIFIED',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  LIVE: 'LIVE',
  PAUSED: 'PAUSED'
};

export type BusinessStatus = (typeof BusinessStatus)[keyof typeof BusinessStatus]


export const IdentityStatus: {
  NOT_STARTED: 'NOT_STARTED',
  PENDING: 'PENDING',
  IN_REVIEW: 'IN_REVIEW',
  VERIFIED: 'VERIFIED',
  REJECTED: 'REJECTED',
  EXPIRED: 'EXPIRED'
};

export type IdentityStatus = (typeof IdentityStatus)[keyof typeof IdentityStatus]


export const MessageStatus: {
  NEW: 'NEW',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED'
};

export type MessageStatus = (typeof MessageStatus)[keyof typeof MessageStatus]


export const ApplicationType: {
  CRYPTO_LAUNCH: 'CRYPTO_LAUNCH',
  BUSINESS_RAISE: 'BUSINESS_RAISE',
  PARTNERSHIP: 'PARTNERSHIP',
  OTHER: 'OTHER'
};

export type ApplicationType = (typeof ApplicationType)[keyof typeof ApplicationType]


export const ApplicationStatus: {
  NEW: 'NEW',
  IN_REVIEW: 'IN_REVIEW',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  WAITLISTED: 'WAITLISTED'
};

export type ApplicationStatus = (typeof ApplicationStatus)[keyof typeof ApplicationStatus]


export const TrustScoreEventType: {
  IDENTITY_VERIFIED: 'IDENTITY_VERIFIED',
  LIQUIDITY_LOCKED: 'LIQUIDITY_LOCKED',
  VESTING_CONFIGURED: 'VESTING_CONFIGURED',
  PROFILE_COMPLETED: 'PROFILE_COMPLETED',
  AUDIT_SUBMITTED: 'AUDIT_SUBMITTED',
  DOCS_UPLOADED: 'DOCS_UPLOADED',
  KYB_VERIFIED: 'KYB_VERIFIED',
  MANUAL_ADJUSTMENT: 'MANUAL_ADJUSTMENT',
  PENALTY_APPLIED: 'PENALTY_APPLIED',
  BONUS_APPLIED: 'BONUS_APPLIED'
};

export type TrustScoreEventType = (typeof TrustScoreEventType)[keyof typeof TrustScoreEventType]


export const LogLevel: {
  INFO: 'INFO',
  WARN: 'WARN',
  ERROR: 'ERROR',
  SECURITY: 'SECURITY',
  AUDIT: 'AUDIT'
};

export type LogLevel = (typeof LogLevel)[keyof typeof LogLevel]


export const LogCategory: {
  AUTH: 'AUTH',
  PROJECT: 'PROJECT',
  BUSINESS: 'BUSINESS',
  ADMIN: 'ADMIN',
  TRUST_SCORE: 'TRUST_SCORE',
  SECURITY: 'SECURITY',
  SYSTEM: 'SYSTEM',
  DEX: 'DEX',
  IDENTITY: 'IDENTITY'
};

export type LogCategory = (typeof LogCategory)[keyof typeof LogCategory]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type TokenType = $Enums.TokenType

export const TokenType: typeof $Enums.TokenType

export type VestingType = $Enums.VestingType

export const VestingType: typeof $Enums.VestingType

export type ProjectStatus = $Enums.ProjectStatus

export const ProjectStatus: typeof $Enums.ProjectStatus

export type KYBLevel = $Enums.KYBLevel

export const KYBLevel: typeof $Enums.KYBLevel

export type BusinessStatus = $Enums.BusinessStatus

export const BusinessStatus: typeof $Enums.BusinessStatus

export type IdentityStatus = $Enums.IdentityStatus

export const IdentityStatus: typeof $Enums.IdentityStatus

export type MessageStatus = $Enums.MessageStatus

export const MessageStatus: typeof $Enums.MessageStatus

export type ApplicationType = $Enums.ApplicationType

export const ApplicationType: typeof $Enums.ApplicationType

export type ApplicationStatus = $Enums.ApplicationStatus

export const ApplicationStatus: typeof $Enums.ApplicationStatus

export type TrustScoreEventType = $Enums.TrustScoreEventType

export const TrustScoreEventType: typeof $Enums.TrustScoreEventType

export type LogLevel = $Enums.LogLevel

export const LogLevel: typeof $Enums.LogLevel

export type LogCategory = $Enums.LogCategory

export const LogCategory: typeof $Enums.LogCategory

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.cryptoProject`: Exposes CRUD operations for the **CryptoProject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CryptoProjects
    * const cryptoProjects = await prisma.cryptoProject.findMany()
    * ```
    */
  get cryptoProject(): Prisma.CryptoProjectDelegate<ExtArgs>;

  /**
   * `prisma.projectDocument`: Exposes CRUD operations for the **ProjectDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectDocuments
    * const projectDocuments = await prisma.projectDocument.findMany()
    * ```
    */
  get projectDocument(): Prisma.ProjectDocumentDelegate<ExtArgs>;

  /**
   * `prisma.business`: Exposes CRUD operations for the **Business** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Businesses
    * const businesses = await prisma.business.findMany()
    * ```
    */
  get business(): Prisma.BusinessDelegate<ExtArgs>;

  /**
   * `prisma.businessFounder`: Exposes CRUD operations for the **BusinessFounder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessFounders
    * const businessFounders = await prisma.businessFounder.findMany()
    * ```
    */
  get businessFounder(): Prisma.BusinessFounderDelegate<ExtArgs>;

  /**
   * `prisma.businessDocument`: Exposes CRUD operations for the **BusinessDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessDocuments
    * const businessDocuments = await prisma.businessDocument.findMany()
    * ```
    */
  get businessDocument(): Prisma.BusinessDocumentDelegate<ExtArgs>;

  /**
   * `prisma.revenueReport`: Exposes CRUD operations for the **RevenueReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RevenueReports
    * const revenueReports = await prisma.revenueReport.findMany()
    * ```
    */
  get revenueReport(): Prisma.RevenueReportDelegate<ExtArgs>;

  /**
   * `prisma.privateIdentityVerification`: Exposes CRUD operations for the **PrivateIdentityVerification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrivateIdentityVerifications
    * const privateIdentityVerifications = await prisma.privateIdentityVerification.findMany()
    * ```
    */
  get privateIdentityVerification(): Prisma.PrivateIdentityVerificationDelegate<ExtArgs>;

  /**
   * `prisma.contactMessage`: Exposes CRUD operations for the **ContactMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactMessages
    * const contactMessages = await prisma.contactMessage.findMany()
    * ```
    */
  get contactMessage(): Prisma.ContactMessageDelegate<ExtArgs>;

  /**
   * `prisma.launchApplication`: Exposes CRUD operations for the **LaunchApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LaunchApplications
    * const launchApplications = await prisma.launchApplication.findMany()
    * ```
    */
  get launchApplication(): Prisma.LaunchApplicationDelegate<ExtArgs>;

  /**
   * `prisma.trustScoreEvent`: Exposes CRUD operations for the **TrustScoreEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrustScoreEvents
    * const trustScoreEvents = await prisma.trustScoreEvent.findMany()
    * ```
    */
  get trustScoreEvent(): Prisma.TrustScoreEventDelegate<ExtArgs>;

  /**
   * `prisma.adminNote`: Exposes CRUD operations for the **AdminNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminNotes
    * const adminNotes = await prisma.adminNote.findMany()
    * ```
    */
  get adminNote(): Prisma.AdminNoteDelegate<ExtArgs>;

  /**
   * `prisma.systemLog`: Exposes CRUD operations for the **SystemLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemLogs
    * const systemLogs = await prisma.systemLog.findMany()
    * ```
    */
  get systemLog(): Prisma.SystemLogDelegate<ExtArgs>;

  /**
   * `prisma.dexPair`: Exposes CRUD operations for the **DexPair** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DexPairs
    * const dexPairs = await prisma.dexPair.findMany()
    * ```
    */
  get dexPair(): Prisma.DexPairDelegate<ExtArgs>;

  /**
   * `prisma.rateLimitRecord`: Exposes CRUD operations for the **RateLimitRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RateLimitRecords
    * const rateLimitRecords = await prisma.rateLimitRecord.findMany()
    * ```
    */
  get rateLimitRecord(): Prisma.RateLimitRecordDelegate<ExtArgs>;

  /**
   * `prisma.securityEvent`: Exposes CRUD operations for the **SecurityEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecurityEvents
    * const securityEvents = await prisma.securityEvent.findMany()
    * ```
    */
  get securityEvent(): Prisma.SecurityEventDelegate<ExtArgs>;

  /**
   * `prisma.blockedEntity`: Exposes CRUD operations for the **BlockedEntity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlockedEntities
    * const blockedEntities = await prisma.blockedEntity.findMany()
    * ```
    */
  get blockedEntity(): Prisma.BlockedEntityDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    CryptoProject: 'CryptoProject',
    ProjectDocument: 'ProjectDocument',
    Business: 'Business',
    BusinessFounder: 'BusinessFounder',
    BusinessDocument: 'BusinessDocument',
    RevenueReport: 'RevenueReport',
    PrivateIdentityVerification: 'PrivateIdentityVerification',
    ContactMessage: 'ContactMessage',
    LaunchApplication: 'LaunchApplication',
    TrustScoreEvent: 'TrustScoreEvent',
    AdminNote: 'AdminNote',
    SystemLog: 'SystemLog',
    DexPair: 'DexPair',
    RateLimitRecord: 'RateLimitRecord',
    SecurityEvent: 'SecurityEvent',
    BlockedEntity: 'BlockedEntity'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "session" | "cryptoProject" | "projectDocument" | "business" | "businessFounder" | "businessDocument" | "revenueReport" | "privateIdentityVerification" | "contactMessage" | "launchApplication" | "trustScoreEvent" | "adminNote" | "systemLog" | "dexPair" | "rateLimitRecord" | "securityEvent" | "blockedEntity"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      CryptoProject: {
        payload: Prisma.$CryptoProjectPayload<ExtArgs>
        fields: Prisma.CryptoProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CryptoProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CryptoProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoProjectPayload>
          }
          findFirst: {
            args: Prisma.CryptoProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CryptoProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoProjectPayload>
          }
          findMany: {
            args: Prisma.CryptoProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoProjectPayload>[]
          }
          create: {
            args: Prisma.CryptoProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoProjectPayload>
          }
          createMany: {
            args: Prisma.CryptoProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CryptoProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoProjectPayload>[]
          }
          delete: {
            args: Prisma.CryptoProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoProjectPayload>
          }
          update: {
            args: Prisma.CryptoProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoProjectPayload>
          }
          deleteMany: {
            args: Prisma.CryptoProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CryptoProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CryptoProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CryptoProjectPayload>
          }
          aggregate: {
            args: Prisma.CryptoProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCryptoProject>
          }
          groupBy: {
            args: Prisma.CryptoProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<CryptoProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.CryptoProjectCountArgs<ExtArgs>
            result: $Utils.Optional<CryptoProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectDocument: {
        payload: Prisma.$ProjectDocumentPayload<ExtArgs>
        fields: Prisma.ProjectDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDocumentPayload>
          }
          findFirst: {
            args: Prisma.ProjectDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDocumentPayload>
          }
          findMany: {
            args: Prisma.ProjectDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDocumentPayload>[]
          }
          create: {
            args: Prisma.ProjectDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDocumentPayload>
          }
          createMany: {
            args: Prisma.ProjectDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDocumentPayload>[]
          }
          delete: {
            args: Prisma.ProjectDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDocumentPayload>
          }
          update: {
            args: Prisma.ProjectDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDocumentPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectDocumentPayload>
          }
          aggregate: {
            args: Prisma.ProjectDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectDocument>
          }
          groupBy: {
            args: Prisma.ProjectDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectDocumentCountAggregateOutputType> | number
          }
        }
      }
      Business: {
        payload: Prisma.$BusinessPayload<ExtArgs>
        fields: Prisma.BusinessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          findFirst: {
            args: Prisma.BusinessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          findMany: {
            args: Prisma.BusinessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>[]
          }
          create: {
            args: Prisma.BusinessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          createMany: {
            args: Prisma.BusinessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>[]
          }
          delete: {
            args: Prisma.BusinessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          update: {
            args: Prisma.BusinessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          deleteMany: {
            args: Prisma.BusinessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BusinessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          aggregate: {
            args: Prisma.BusinessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusiness>
          }
          groupBy: {
            args: Prisma.BusinessGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessCountAggregateOutputType> | number
          }
        }
      }
      BusinessFounder: {
        payload: Prisma.$BusinessFounderPayload<ExtArgs>
        fields: Prisma.BusinessFounderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessFounderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessFounderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessFounderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessFounderPayload>
          }
          findFirst: {
            args: Prisma.BusinessFounderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessFounderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessFounderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessFounderPayload>
          }
          findMany: {
            args: Prisma.BusinessFounderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessFounderPayload>[]
          }
          create: {
            args: Prisma.BusinessFounderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessFounderPayload>
          }
          createMany: {
            args: Prisma.BusinessFounderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessFounderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessFounderPayload>[]
          }
          delete: {
            args: Prisma.BusinessFounderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessFounderPayload>
          }
          update: {
            args: Prisma.BusinessFounderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessFounderPayload>
          }
          deleteMany: {
            args: Prisma.BusinessFounderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessFounderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BusinessFounderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessFounderPayload>
          }
          aggregate: {
            args: Prisma.BusinessFounderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessFounder>
          }
          groupBy: {
            args: Prisma.BusinessFounderGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessFounderGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessFounderCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessFounderCountAggregateOutputType> | number
          }
        }
      }
      BusinessDocument: {
        payload: Prisma.$BusinessDocumentPayload<ExtArgs>
        fields: Prisma.BusinessDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessDocumentPayload>
          }
          findFirst: {
            args: Prisma.BusinessDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessDocumentPayload>
          }
          findMany: {
            args: Prisma.BusinessDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessDocumentPayload>[]
          }
          create: {
            args: Prisma.BusinessDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessDocumentPayload>
          }
          createMany: {
            args: Prisma.BusinessDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessDocumentPayload>[]
          }
          delete: {
            args: Prisma.BusinessDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessDocumentPayload>
          }
          update: {
            args: Prisma.BusinessDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessDocumentPayload>
          }
          deleteMany: {
            args: Prisma.BusinessDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BusinessDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessDocumentPayload>
          }
          aggregate: {
            args: Prisma.BusinessDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessDocument>
          }
          groupBy: {
            args: Prisma.BusinessDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessDocumentCountAggregateOutputType> | number
          }
        }
      }
      RevenueReport: {
        payload: Prisma.$RevenueReportPayload<ExtArgs>
        fields: Prisma.RevenueReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RevenueReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RevenueReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueReportPayload>
          }
          findFirst: {
            args: Prisma.RevenueReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RevenueReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueReportPayload>
          }
          findMany: {
            args: Prisma.RevenueReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueReportPayload>[]
          }
          create: {
            args: Prisma.RevenueReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueReportPayload>
          }
          createMany: {
            args: Prisma.RevenueReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RevenueReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueReportPayload>[]
          }
          delete: {
            args: Prisma.RevenueReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueReportPayload>
          }
          update: {
            args: Prisma.RevenueReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueReportPayload>
          }
          deleteMany: {
            args: Prisma.RevenueReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RevenueReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RevenueReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueReportPayload>
          }
          aggregate: {
            args: Prisma.RevenueReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRevenueReport>
          }
          groupBy: {
            args: Prisma.RevenueReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<RevenueReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.RevenueReportCountArgs<ExtArgs>
            result: $Utils.Optional<RevenueReportCountAggregateOutputType> | number
          }
        }
      }
      PrivateIdentityVerification: {
        payload: Prisma.$PrivateIdentityVerificationPayload<ExtArgs>
        fields: Prisma.PrivateIdentityVerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrivateIdentityVerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateIdentityVerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrivateIdentityVerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateIdentityVerificationPayload>
          }
          findFirst: {
            args: Prisma.PrivateIdentityVerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateIdentityVerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrivateIdentityVerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateIdentityVerificationPayload>
          }
          findMany: {
            args: Prisma.PrivateIdentityVerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateIdentityVerificationPayload>[]
          }
          create: {
            args: Prisma.PrivateIdentityVerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateIdentityVerificationPayload>
          }
          createMany: {
            args: Prisma.PrivateIdentityVerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrivateIdentityVerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateIdentityVerificationPayload>[]
          }
          delete: {
            args: Prisma.PrivateIdentityVerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateIdentityVerificationPayload>
          }
          update: {
            args: Prisma.PrivateIdentityVerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateIdentityVerificationPayload>
          }
          deleteMany: {
            args: Prisma.PrivateIdentityVerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrivateIdentityVerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PrivateIdentityVerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateIdentityVerificationPayload>
          }
          aggregate: {
            args: Prisma.PrivateIdentityVerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrivateIdentityVerification>
          }
          groupBy: {
            args: Prisma.PrivateIdentityVerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrivateIdentityVerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrivateIdentityVerificationCountArgs<ExtArgs>
            result: $Utils.Optional<PrivateIdentityVerificationCountAggregateOutputType> | number
          }
        }
      }
      ContactMessage: {
        payload: Prisma.$ContactMessagePayload<ExtArgs>
        fields: Prisma.ContactMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>
          }
          findFirst: {
            args: Prisma.ContactMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>
          }
          findMany: {
            args: Prisma.ContactMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>[]
          }
          create: {
            args: Prisma.ContactMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>
          }
          createMany: {
            args: Prisma.ContactMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>[]
          }
          delete: {
            args: Prisma.ContactMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>
          }
          update: {
            args: Prisma.ContactMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>
          }
          deleteMany: {
            args: Prisma.ContactMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>
          }
          aggregate: {
            args: Prisma.ContactMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactMessage>
          }
          groupBy: {
            args: Prisma.ContactMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ContactMessageCountAggregateOutputType> | number
          }
        }
      }
      LaunchApplication: {
        payload: Prisma.$LaunchApplicationPayload<ExtArgs>
        fields: Prisma.LaunchApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LaunchApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaunchApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LaunchApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaunchApplicationPayload>
          }
          findFirst: {
            args: Prisma.LaunchApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaunchApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LaunchApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaunchApplicationPayload>
          }
          findMany: {
            args: Prisma.LaunchApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaunchApplicationPayload>[]
          }
          create: {
            args: Prisma.LaunchApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaunchApplicationPayload>
          }
          createMany: {
            args: Prisma.LaunchApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LaunchApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaunchApplicationPayload>[]
          }
          delete: {
            args: Prisma.LaunchApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaunchApplicationPayload>
          }
          update: {
            args: Prisma.LaunchApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaunchApplicationPayload>
          }
          deleteMany: {
            args: Prisma.LaunchApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LaunchApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LaunchApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaunchApplicationPayload>
          }
          aggregate: {
            args: Prisma.LaunchApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLaunchApplication>
          }
          groupBy: {
            args: Prisma.LaunchApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LaunchApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LaunchApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<LaunchApplicationCountAggregateOutputType> | number
          }
        }
      }
      TrustScoreEvent: {
        payload: Prisma.$TrustScoreEventPayload<ExtArgs>
        fields: Prisma.TrustScoreEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrustScoreEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustScoreEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrustScoreEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustScoreEventPayload>
          }
          findFirst: {
            args: Prisma.TrustScoreEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustScoreEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrustScoreEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustScoreEventPayload>
          }
          findMany: {
            args: Prisma.TrustScoreEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustScoreEventPayload>[]
          }
          create: {
            args: Prisma.TrustScoreEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustScoreEventPayload>
          }
          createMany: {
            args: Prisma.TrustScoreEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrustScoreEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustScoreEventPayload>[]
          }
          delete: {
            args: Prisma.TrustScoreEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustScoreEventPayload>
          }
          update: {
            args: Prisma.TrustScoreEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustScoreEventPayload>
          }
          deleteMany: {
            args: Prisma.TrustScoreEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrustScoreEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrustScoreEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrustScoreEventPayload>
          }
          aggregate: {
            args: Prisma.TrustScoreEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrustScoreEvent>
          }
          groupBy: {
            args: Prisma.TrustScoreEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrustScoreEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrustScoreEventCountArgs<ExtArgs>
            result: $Utils.Optional<TrustScoreEventCountAggregateOutputType> | number
          }
        }
      }
      AdminNote: {
        payload: Prisma.$AdminNotePayload<ExtArgs>
        fields: Prisma.AdminNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotePayload>
          }
          findFirst: {
            args: Prisma.AdminNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotePayload>
          }
          findMany: {
            args: Prisma.AdminNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotePayload>[]
          }
          create: {
            args: Prisma.AdminNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotePayload>
          }
          createMany: {
            args: Prisma.AdminNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotePayload>[]
          }
          delete: {
            args: Prisma.AdminNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotePayload>
          }
          update: {
            args: Prisma.AdminNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotePayload>
          }
          deleteMany: {
            args: Prisma.AdminNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminNotePayload>
          }
          aggregate: {
            args: Prisma.AdminNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminNote>
          }
          groupBy: {
            args: Prisma.AdminNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminNoteCountArgs<ExtArgs>
            result: $Utils.Optional<AdminNoteCountAggregateOutputType> | number
          }
        }
      }
      SystemLog: {
        payload: Prisma.$SystemLogPayload<ExtArgs>
        fields: Prisma.SystemLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          findFirst: {
            args: Prisma.SystemLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          findMany: {
            args: Prisma.SystemLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>[]
          }
          create: {
            args: Prisma.SystemLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          createMany: {
            args: Prisma.SystemLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>[]
          }
          delete: {
            args: Prisma.SystemLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          update: {
            args: Prisma.SystemLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          deleteMany: {
            args: Prisma.SystemLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          aggregate: {
            args: Prisma.SystemLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemLog>
          }
          groupBy: {
            args: Prisma.SystemLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemLogCountArgs<ExtArgs>
            result: $Utils.Optional<SystemLogCountAggregateOutputType> | number
          }
        }
      }
      DexPair: {
        payload: Prisma.$DexPairPayload<ExtArgs>
        fields: Prisma.DexPairFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DexPairFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DexPairPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DexPairFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DexPairPayload>
          }
          findFirst: {
            args: Prisma.DexPairFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DexPairPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DexPairFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DexPairPayload>
          }
          findMany: {
            args: Prisma.DexPairFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DexPairPayload>[]
          }
          create: {
            args: Prisma.DexPairCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DexPairPayload>
          }
          createMany: {
            args: Prisma.DexPairCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DexPairCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DexPairPayload>[]
          }
          delete: {
            args: Prisma.DexPairDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DexPairPayload>
          }
          update: {
            args: Prisma.DexPairUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DexPairPayload>
          }
          deleteMany: {
            args: Prisma.DexPairDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DexPairUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DexPairUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DexPairPayload>
          }
          aggregate: {
            args: Prisma.DexPairAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDexPair>
          }
          groupBy: {
            args: Prisma.DexPairGroupByArgs<ExtArgs>
            result: $Utils.Optional<DexPairGroupByOutputType>[]
          }
          count: {
            args: Prisma.DexPairCountArgs<ExtArgs>
            result: $Utils.Optional<DexPairCountAggregateOutputType> | number
          }
        }
      }
      RateLimitRecord: {
        payload: Prisma.$RateLimitRecordPayload<ExtArgs>
        fields: Prisma.RateLimitRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RateLimitRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RateLimitRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitRecordPayload>
          }
          findFirst: {
            args: Prisma.RateLimitRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RateLimitRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitRecordPayload>
          }
          findMany: {
            args: Prisma.RateLimitRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitRecordPayload>[]
          }
          create: {
            args: Prisma.RateLimitRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitRecordPayload>
          }
          createMany: {
            args: Prisma.RateLimitRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RateLimitRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitRecordPayload>[]
          }
          delete: {
            args: Prisma.RateLimitRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitRecordPayload>
          }
          update: {
            args: Prisma.RateLimitRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitRecordPayload>
          }
          deleteMany: {
            args: Prisma.RateLimitRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RateLimitRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RateLimitRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitRecordPayload>
          }
          aggregate: {
            args: Prisma.RateLimitRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRateLimitRecord>
          }
          groupBy: {
            args: Prisma.RateLimitRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<RateLimitRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.RateLimitRecordCountArgs<ExtArgs>
            result: $Utils.Optional<RateLimitRecordCountAggregateOutputType> | number
          }
        }
      }
      SecurityEvent: {
        payload: Prisma.$SecurityEventPayload<ExtArgs>
        fields: Prisma.SecurityEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SecurityEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SecurityEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          findFirst: {
            args: Prisma.SecurityEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SecurityEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          findMany: {
            args: Prisma.SecurityEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>[]
          }
          create: {
            args: Prisma.SecurityEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          createMany: {
            args: Prisma.SecurityEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SecurityEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>[]
          }
          delete: {
            args: Prisma.SecurityEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          update: {
            args: Prisma.SecurityEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          deleteMany: {
            args: Prisma.SecurityEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SecurityEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SecurityEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityEventPayload>
          }
          aggregate: {
            args: Prisma.SecurityEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSecurityEvent>
          }
          groupBy: {
            args: Prisma.SecurityEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<SecurityEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.SecurityEventCountArgs<ExtArgs>
            result: $Utils.Optional<SecurityEventCountAggregateOutputType> | number
          }
        }
      }
      BlockedEntity: {
        payload: Prisma.$BlockedEntityPayload<ExtArgs>
        fields: Prisma.BlockedEntityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlockedEntityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedEntityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockedEntityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedEntityPayload>
          }
          findFirst: {
            args: Prisma.BlockedEntityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedEntityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockedEntityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedEntityPayload>
          }
          findMany: {
            args: Prisma.BlockedEntityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedEntityPayload>[]
          }
          create: {
            args: Prisma.BlockedEntityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedEntityPayload>
          }
          createMany: {
            args: Prisma.BlockedEntityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlockedEntityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedEntityPayload>[]
          }
          delete: {
            args: Prisma.BlockedEntityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedEntityPayload>
          }
          update: {
            args: Prisma.BlockedEntityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedEntityPayload>
          }
          deleteMany: {
            args: Prisma.BlockedEntityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlockedEntityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlockedEntityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedEntityPayload>
          }
          aggregate: {
            args: Prisma.BlockedEntityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlockedEntity>
          }
          groupBy: {
            args: Prisma.BlockedEntityGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlockedEntityGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockedEntityCountArgs<ExtArgs>
            result: $Utils.Optional<BlockedEntityCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    cryptoProjects: number
    businesses: number
    sessions: number
    systemLogs: number
    trustScoreEvents: number
    contactMessages: number
    applications: number
    adminNotes: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cryptoProjects?: boolean | UserCountOutputTypeCountCryptoProjectsArgs
    businesses?: boolean | UserCountOutputTypeCountBusinessesArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    systemLogs?: boolean | UserCountOutputTypeCountSystemLogsArgs
    trustScoreEvents?: boolean | UserCountOutputTypeCountTrustScoreEventsArgs
    contactMessages?: boolean | UserCountOutputTypeCountContactMessagesArgs
    applications?: boolean | UserCountOutputTypeCountApplicationsArgs
    adminNotes?: boolean | UserCountOutputTypeCountAdminNotesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCryptoProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CryptoProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBusinessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSystemLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTrustScoreEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrustScoreEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountContactMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LaunchApplicationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdminNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminNoteWhereInput
  }


  /**
   * Count Type CryptoProjectCountOutputType
   */

  export type CryptoProjectCountOutputType = {
    trustScoreEvents: number
    adminNotes: number
    documents: number
  }

  export type CryptoProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trustScoreEvents?: boolean | CryptoProjectCountOutputTypeCountTrustScoreEventsArgs
    adminNotes?: boolean | CryptoProjectCountOutputTypeCountAdminNotesArgs
    documents?: boolean | CryptoProjectCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes
  /**
   * CryptoProjectCountOutputType without action
   */
  export type CryptoProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoProjectCountOutputType
     */
    select?: CryptoProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CryptoProjectCountOutputType without action
   */
  export type CryptoProjectCountOutputTypeCountTrustScoreEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrustScoreEventWhereInput
  }

  /**
   * CryptoProjectCountOutputType without action
   */
  export type CryptoProjectCountOutputTypeCountAdminNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminNoteWhereInput
  }

  /**
   * CryptoProjectCountOutputType without action
   */
  export type CryptoProjectCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectDocumentWhereInput
  }


  /**
   * Count Type BusinessCountOutputType
   */

  export type BusinessCountOutputType = {
    founders: number
    documents: number
    trustScoreEvents: number
    adminNotes: number
    revenueReports: number
  }

  export type BusinessCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    founders?: boolean | BusinessCountOutputTypeCountFoundersArgs
    documents?: boolean | BusinessCountOutputTypeCountDocumentsArgs
    trustScoreEvents?: boolean | BusinessCountOutputTypeCountTrustScoreEventsArgs
    adminNotes?: boolean | BusinessCountOutputTypeCountAdminNotesArgs
    revenueReports?: boolean | BusinessCountOutputTypeCountRevenueReportsArgs
  }

  // Custom InputTypes
  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCountOutputType
     */
    select?: BusinessCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountFoundersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessFounderWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessDocumentWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountTrustScoreEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrustScoreEventWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountAdminNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminNoteWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountRevenueReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RevenueReportWhereInput
  }


  /**
   * Count Type ContactMessageCountOutputType
   */

  export type ContactMessageCountOutputType = {
    adminNotes: number
  }

  export type ContactMessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminNotes?: boolean | ContactMessageCountOutputTypeCountAdminNotesArgs
  }

  // Custom InputTypes
  /**
   * ContactMessageCountOutputType without action
   */
  export type ContactMessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessageCountOutputType
     */
    select?: ContactMessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactMessageCountOutputType without action
   */
  export type ContactMessageCountOutputTypeCountAdminNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminNoteWhereInput
  }


  /**
   * Count Type LaunchApplicationCountOutputType
   */

  export type LaunchApplicationCountOutputType = {
    adminNotes: number
  }

  export type LaunchApplicationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminNotes?: boolean | LaunchApplicationCountOutputTypeCountAdminNotesArgs
  }

  // Custom InputTypes
  /**
   * LaunchApplicationCountOutputType without action
   */
  export type LaunchApplicationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaunchApplicationCountOutputType
     */
    select?: LaunchApplicationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LaunchApplicationCountOutputType without action
   */
  export type LaunchApplicationCountOutputTypeCountAdminNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminNoteWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    failedLoginCount: number | null
    apiCallCount: number | null
  }

  export type UserSumAggregateOutputType = {
    failedLoginCount: number | null
    apiCallCount: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    walletAddress: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    isEmailVerified: boolean | null
    emailVerifiedAt: Date | null
    lastLoginAt: Date | null
    lastLoginIp: string | null
    failedLoginCount: number | null
    lockedUntil: Date | null
    twoFactorEnabled: boolean | null
    twoFactorSecret: string | null
    displayName: string | null
    avatarUrl: string | null
    bio: string | null
    apiCallCount: number | null
    apiCallResetAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    walletAddress: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    isEmailVerified: boolean | null
    emailVerifiedAt: Date | null
    lastLoginAt: Date | null
    lastLoginIp: string | null
    failedLoginCount: number | null
    lockedUntil: Date | null
    twoFactorEnabled: boolean | null
    twoFactorSecret: string | null
    displayName: string | null
    avatarUrl: string | null
    bio: string | null
    apiCallCount: number | null
    apiCallResetAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    walletAddress: number
    role: number
    isActive: number
    isEmailVerified: number
    emailVerifiedAt: number
    lastLoginAt: number
    lastLoginIp: number
    failedLoginCount: number
    lockedUntil: number
    twoFactorEnabled: number
    twoFactorSecret: number
    displayName: number
    avatarUrl: number
    bio: number
    apiCallCount: number
    apiCallResetAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    failedLoginCount?: true
    apiCallCount?: true
  }

  export type UserSumAggregateInputType = {
    failedLoginCount?: true
    apiCallCount?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    walletAddress?: true
    role?: true
    isActive?: true
    isEmailVerified?: true
    emailVerifiedAt?: true
    lastLoginAt?: true
    lastLoginIp?: true
    failedLoginCount?: true
    lockedUntil?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    displayName?: true
    avatarUrl?: true
    bio?: true
    apiCallCount?: true
    apiCallResetAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    walletAddress?: true
    role?: true
    isActive?: true
    isEmailVerified?: true
    emailVerifiedAt?: true
    lastLoginAt?: true
    lastLoginIp?: true
    failedLoginCount?: true
    lockedUntil?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    displayName?: true
    avatarUrl?: true
    bio?: true
    apiCallCount?: true
    apiCallResetAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    walletAddress?: true
    role?: true
    isActive?: true
    isEmailVerified?: true
    emailVerifiedAt?: true
    lastLoginAt?: true
    lastLoginIp?: true
    failedLoginCount?: true
    lockedUntil?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    displayName?: true
    avatarUrl?: true
    bio?: true
    apiCallCount?: true
    apiCallResetAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    walletAddress: string | null
    role: $Enums.UserRole
    isActive: boolean
    isEmailVerified: boolean
    emailVerifiedAt: Date | null
    lastLoginAt: Date | null
    lastLoginIp: string | null
    failedLoginCount: number
    lockedUntil: Date | null
    twoFactorEnabled: boolean
    twoFactorSecret: string | null
    displayName: string | null
    avatarUrl: string | null
    bio: string | null
    apiCallCount: number
    apiCallResetAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    walletAddress?: boolean
    role?: boolean
    isActive?: boolean
    isEmailVerified?: boolean
    emailVerifiedAt?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    failedLoginCount?: boolean
    lockedUntil?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    bio?: boolean
    apiCallCount?: boolean
    apiCallResetAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cryptoProjects?: boolean | User$cryptoProjectsArgs<ExtArgs>
    businesses?: boolean | User$businessesArgs<ExtArgs>
    identityVerification?: boolean | User$identityVerificationArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    systemLogs?: boolean | User$systemLogsArgs<ExtArgs>
    trustScoreEvents?: boolean | User$trustScoreEventsArgs<ExtArgs>
    contactMessages?: boolean | User$contactMessagesArgs<ExtArgs>
    applications?: boolean | User$applicationsArgs<ExtArgs>
    adminNotes?: boolean | User$adminNotesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    walletAddress?: boolean
    role?: boolean
    isActive?: boolean
    isEmailVerified?: boolean
    emailVerifiedAt?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    failedLoginCount?: boolean
    lockedUntil?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    bio?: boolean
    apiCallCount?: boolean
    apiCallResetAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    walletAddress?: boolean
    role?: boolean
    isActive?: boolean
    isEmailVerified?: boolean
    emailVerifiedAt?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    failedLoginCount?: boolean
    lockedUntil?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    displayName?: boolean
    avatarUrl?: boolean
    bio?: boolean
    apiCallCount?: boolean
    apiCallResetAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cryptoProjects?: boolean | User$cryptoProjectsArgs<ExtArgs>
    businesses?: boolean | User$businessesArgs<ExtArgs>
    identityVerification?: boolean | User$identityVerificationArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    systemLogs?: boolean | User$systemLogsArgs<ExtArgs>
    trustScoreEvents?: boolean | User$trustScoreEventsArgs<ExtArgs>
    contactMessages?: boolean | User$contactMessagesArgs<ExtArgs>
    applications?: boolean | User$applicationsArgs<ExtArgs>
    adminNotes?: boolean | User$adminNotesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      cryptoProjects: Prisma.$CryptoProjectPayload<ExtArgs>[]
      businesses: Prisma.$BusinessPayload<ExtArgs>[]
      identityVerification: Prisma.$PrivateIdentityVerificationPayload<ExtArgs> | null
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      systemLogs: Prisma.$SystemLogPayload<ExtArgs>[]
      trustScoreEvents: Prisma.$TrustScoreEventPayload<ExtArgs>[]
      contactMessages: Prisma.$ContactMessagePayload<ExtArgs>[]
      applications: Prisma.$LaunchApplicationPayload<ExtArgs>[]
      adminNotes: Prisma.$AdminNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      walletAddress: string | null
      role: $Enums.UserRole
      isActive: boolean
      isEmailVerified: boolean
      emailVerifiedAt: Date | null
      lastLoginAt: Date | null
      lastLoginIp: string | null
      failedLoginCount: number
      lockedUntil: Date | null
      twoFactorEnabled: boolean
      twoFactorSecret: string | null
      displayName: string | null
      avatarUrl: string | null
      bio: string | null
      apiCallCount: number
      apiCallResetAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cryptoProjects<T extends User$cryptoProjectsArgs<ExtArgs> = {}>(args?: Subset<T, User$cryptoProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoProjectPayload<ExtArgs>, T, "findMany"> | Null>
    businesses<T extends User$businessesArgs<ExtArgs> = {}>(args?: Subset<T, User$businessesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findMany"> | Null>
    identityVerification<T extends User$identityVerificationArgs<ExtArgs> = {}>(args?: Subset<T, User$identityVerificationArgs<ExtArgs>>): Prisma__PrivateIdentityVerificationClient<$Result.GetResult<Prisma.$PrivateIdentityVerificationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    systemLogs<T extends User$systemLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$systemLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findMany"> | Null>
    trustScoreEvents<T extends User$trustScoreEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$trustScoreEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrustScoreEventPayload<ExtArgs>, T, "findMany"> | Null>
    contactMessages<T extends User$contactMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$contactMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "findMany"> | Null>
    applications<T extends User$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, User$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaunchApplicationPayload<ExtArgs>, T, "findMany"> | Null>
    adminNotes<T extends User$adminNotesArgs<ExtArgs> = {}>(args?: Subset<T, User$adminNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminNotePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly walletAddress: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly isEmailVerified: FieldRef<"User", 'Boolean'>
    readonly emailVerifiedAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginIp: FieldRef<"User", 'String'>
    readonly failedLoginCount: FieldRef<"User", 'Int'>
    readonly lockedUntil: FieldRef<"User", 'DateTime'>
    readonly twoFactorEnabled: FieldRef<"User", 'Boolean'>
    readonly twoFactorSecret: FieldRef<"User", 'String'>
    readonly displayName: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly apiCallCount: FieldRef<"User", 'Int'>
    readonly apiCallResetAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.cryptoProjects
   */
  export type User$cryptoProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoProject
     */
    select?: CryptoProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoProjectInclude<ExtArgs> | null
    where?: CryptoProjectWhereInput
    orderBy?: CryptoProjectOrderByWithRelationInput | CryptoProjectOrderByWithRelationInput[]
    cursor?: CryptoProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CryptoProjectScalarFieldEnum | CryptoProjectScalarFieldEnum[]
  }

  /**
   * User.businesses
   */
  export type User$businessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    where?: BusinessWhereInput
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    cursor?: BusinessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessScalarFieldEnum | BusinessScalarFieldEnum[]
  }

  /**
   * User.identityVerification
   */
  export type User$identityVerificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateIdentityVerification
     */
    select?: PrivateIdentityVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateIdentityVerificationInclude<ExtArgs> | null
    where?: PrivateIdentityVerificationWhereInput
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.systemLogs
   */
  export type User$systemLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    where?: SystemLogWhereInput
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    cursor?: SystemLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SystemLogScalarFieldEnum | SystemLogScalarFieldEnum[]
  }

  /**
   * User.trustScoreEvents
   */
  export type User$trustScoreEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScoreEvent
     */
    select?: TrustScoreEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreEventInclude<ExtArgs> | null
    where?: TrustScoreEventWhereInput
    orderBy?: TrustScoreEventOrderByWithRelationInput | TrustScoreEventOrderByWithRelationInput[]
    cursor?: TrustScoreEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrustScoreEventScalarFieldEnum | TrustScoreEventScalarFieldEnum[]
  }

  /**
   * User.contactMessages
   */
  export type User$contactMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactMessageInclude<ExtArgs> | null
    where?: ContactMessageWhereInput
    orderBy?: ContactMessageOrderByWithRelationInput | ContactMessageOrderByWithRelationInput[]
    cursor?: ContactMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactMessageScalarFieldEnum | ContactMessageScalarFieldEnum[]
  }

  /**
   * User.applications
   */
  export type User$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaunchApplication
     */
    select?: LaunchApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaunchApplicationInclude<ExtArgs> | null
    where?: LaunchApplicationWhereInput
    orderBy?: LaunchApplicationOrderByWithRelationInput | LaunchApplicationOrderByWithRelationInput[]
    cursor?: LaunchApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LaunchApplicationScalarFieldEnum | LaunchApplicationScalarFieldEnum[]
  }

  /**
   * User.adminNotes
   */
  export type User$adminNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNote
     */
    select?: AdminNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNoteInclude<ExtArgs> | null
    where?: AdminNoteWhereInput
    orderBy?: AdminNoteOrderByWithRelationInput | AdminNoteOrderByWithRelationInput[]
    cursor?: AdminNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminNoteScalarFieldEnum | AdminNoteScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    refreshToken: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date | null
    isRevoked: boolean | null
    revokedAt: Date | null
    revokedReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    refreshToken: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date | null
    isRevoked: boolean | null
    revokedAt: Date | null
    revokedReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    refreshToken: number
    ipAddress: number
    userAgent: number
    expiresAt: number
    isRevoked: number
    revokedAt: number
    revokedReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    refreshToken?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    isRevoked?: true
    revokedAt?: true
    revokedReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    refreshToken?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    isRevoked?: true
    revokedAt?: true
    revokedReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    refreshToken?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    isRevoked?: true
    revokedAt?: true
    revokedReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    token: string
    refreshToken: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date
    isRevoked: boolean
    revokedAt: Date | null
    revokedReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    refreshToken?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    isRevoked?: boolean
    revokedAt?: boolean
    revokedReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    refreshToken?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    isRevoked?: boolean
    revokedAt?: boolean
    revokedReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    refreshToken?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    isRevoked?: boolean
    revokedAt?: boolean
    revokedReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      refreshToken: string | null
      ipAddress: string | null
      userAgent: string | null
      expiresAt: Date
      isRevoked: boolean
      revokedAt: Date | null
      revokedReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly token: FieldRef<"Session", 'String'>
    readonly refreshToken: FieldRef<"Session", 'String'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly isRevoked: FieldRef<"Session", 'Boolean'>
    readonly revokedAt: FieldRef<"Session", 'DateTime'>
    readonly revokedReason: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model CryptoProject
   */

  export type AggregateCryptoProject = {
    _count: CryptoProjectCountAggregateOutputType | null
    _avg: CryptoProjectAvgAggregateOutputType | null
    _sum: CryptoProjectSumAggregateOutputType | null
    _min: CryptoProjectMinAggregateOutputType | null
    _max: CryptoProjectMaxAggregateOutputType | null
  }

  export type CryptoProjectAvgAggregateOutputType = {
    decimals: number | null
    teamAllocationPercent: number | null
    teamVestingMonths: number | null
    teamCliffMonths: number | null
    liquidityLockMonths: number | null
    trustScore: number | null
  }

  export type CryptoProjectSumAggregateOutputType = {
    decimals: number | null
    teamAllocationPercent: number | null
    teamVestingMonths: number | null
    teamCliffMonths: number | null
    liquidityLockMonths: number | null
    trustScore: number | null
  }

  export type CryptoProjectMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    symbol: string | null
    description: string | null
    category: string | null
    website: string | null
    whitepaper: string | null
    twitter: string | null
    discord: string | null
    telegram: string | null
    github: string | null
    tokenType: $Enums.TokenType | null
    totalSupply: string | null
    decimals: number | null
    teamAllocationPercent: number | null
    teamVestingMonths: number | null
    teamCliffMonths: number | null
    vestingType: $Enums.VestingType | null
    initialLiquidity: string | null
    liquidityLockMonths: number | null
    liquidityLockTxHash: string | null
    auditProvider: string | null
    auditReportUrl: string | null
    auditDate: Date | null
    contractAddress: string | null
    contractVerified: boolean | null
    status: $Enums.ProjectStatus | null
    submittedAt: Date | null
    reviewedAt: Date | null
    reviewedBy: string | null
    rejectionReason: string | null
    trustScore: number | null
    trustScoreUpdatedAt: Date | null
    launchDate: Date | null
    softCap: string | null
    hardCap: string | null
    minContribution: string | null
    maxContribution: string | null
    isVerified: boolean | null
    isFeatured: boolean | null
    isPaused: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CryptoProjectMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    symbol: string | null
    description: string | null
    category: string | null
    website: string | null
    whitepaper: string | null
    twitter: string | null
    discord: string | null
    telegram: string | null
    github: string | null
    tokenType: $Enums.TokenType | null
    totalSupply: string | null
    decimals: number | null
    teamAllocationPercent: number | null
    teamVestingMonths: number | null
    teamCliffMonths: number | null
    vestingType: $Enums.VestingType | null
    initialLiquidity: string | null
    liquidityLockMonths: number | null
    liquidityLockTxHash: string | null
    auditProvider: string | null
    auditReportUrl: string | null
    auditDate: Date | null
    contractAddress: string | null
    contractVerified: boolean | null
    status: $Enums.ProjectStatus | null
    submittedAt: Date | null
    reviewedAt: Date | null
    reviewedBy: string | null
    rejectionReason: string | null
    trustScore: number | null
    trustScoreUpdatedAt: Date | null
    launchDate: Date | null
    softCap: string | null
    hardCap: string | null
    minContribution: string | null
    maxContribution: string | null
    isVerified: boolean | null
    isFeatured: boolean | null
    isPaused: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CryptoProjectCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    symbol: number
    description: number
    category: number
    website: number
    whitepaper: number
    twitter: number
    discord: number
    telegram: number
    github: number
    tokenType: number
    totalSupply: number
    decimals: number
    teamAllocationPercent: number
    teamVestingMonths: number
    teamCliffMonths: number
    vestingType: number
    initialLiquidity: number
    liquidityLockMonths: number
    liquidityLockTxHash: number
    auditProvider: number
    auditReportUrl: number
    auditDate: number
    contractAddress: number
    contractVerified: number
    status: number
    submittedAt: number
    reviewedAt: number
    reviewedBy: number
    rejectionReason: number
    trustScore: number
    trustScoreUpdatedAt: number
    launchDate: number
    softCap: number
    hardCap: number
    minContribution: number
    maxContribution: number
    isVerified: number
    isFeatured: number
    isPaused: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CryptoProjectAvgAggregateInputType = {
    decimals?: true
    teamAllocationPercent?: true
    teamVestingMonths?: true
    teamCliffMonths?: true
    liquidityLockMonths?: true
    trustScore?: true
  }

  export type CryptoProjectSumAggregateInputType = {
    decimals?: true
    teamAllocationPercent?: true
    teamVestingMonths?: true
    teamCliffMonths?: true
    liquidityLockMonths?: true
    trustScore?: true
  }

  export type CryptoProjectMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    symbol?: true
    description?: true
    category?: true
    website?: true
    whitepaper?: true
    twitter?: true
    discord?: true
    telegram?: true
    github?: true
    tokenType?: true
    totalSupply?: true
    decimals?: true
    teamAllocationPercent?: true
    teamVestingMonths?: true
    teamCliffMonths?: true
    vestingType?: true
    initialLiquidity?: true
    liquidityLockMonths?: true
    liquidityLockTxHash?: true
    auditProvider?: true
    auditReportUrl?: true
    auditDate?: true
    contractAddress?: true
    contractVerified?: true
    status?: true
    submittedAt?: true
    reviewedAt?: true
    reviewedBy?: true
    rejectionReason?: true
    trustScore?: true
    trustScoreUpdatedAt?: true
    launchDate?: true
    softCap?: true
    hardCap?: true
    minContribution?: true
    maxContribution?: true
    isVerified?: true
    isFeatured?: true
    isPaused?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CryptoProjectMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    symbol?: true
    description?: true
    category?: true
    website?: true
    whitepaper?: true
    twitter?: true
    discord?: true
    telegram?: true
    github?: true
    tokenType?: true
    totalSupply?: true
    decimals?: true
    teamAllocationPercent?: true
    teamVestingMonths?: true
    teamCliffMonths?: true
    vestingType?: true
    initialLiquidity?: true
    liquidityLockMonths?: true
    liquidityLockTxHash?: true
    auditProvider?: true
    auditReportUrl?: true
    auditDate?: true
    contractAddress?: true
    contractVerified?: true
    status?: true
    submittedAt?: true
    reviewedAt?: true
    reviewedBy?: true
    rejectionReason?: true
    trustScore?: true
    trustScoreUpdatedAt?: true
    launchDate?: true
    softCap?: true
    hardCap?: true
    minContribution?: true
    maxContribution?: true
    isVerified?: true
    isFeatured?: true
    isPaused?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CryptoProjectCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    symbol?: true
    description?: true
    category?: true
    website?: true
    whitepaper?: true
    twitter?: true
    discord?: true
    telegram?: true
    github?: true
    tokenType?: true
    totalSupply?: true
    decimals?: true
    teamAllocationPercent?: true
    teamVestingMonths?: true
    teamCliffMonths?: true
    vestingType?: true
    initialLiquidity?: true
    liquidityLockMonths?: true
    liquidityLockTxHash?: true
    auditProvider?: true
    auditReportUrl?: true
    auditDate?: true
    contractAddress?: true
    contractVerified?: true
    status?: true
    submittedAt?: true
    reviewedAt?: true
    reviewedBy?: true
    rejectionReason?: true
    trustScore?: true
    trustScoreUpdatedAt?: true
    launchDate?: true
    softCap?: true
    hardCap?: true
    minContribution?: true
    maxContribution?: true
    isVerified?: true
    isFeatured?: true
    isPaused?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CryptoProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CryptoProject to aggregate.
     */
    where?: CryptoProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoProjects to fetch.
     */
    orderBy?: CryptoProjectOrderByWithRelationInput | CryptoProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CryptoProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CryptoProjects
    **/
    _count?: true | CryptoProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CryptoProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CryptoProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CryptoProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CryptoProjectMaxAggregateInputType
  }

  export type GetCryptoProjectAggregateType<T extends CryptoProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateCryptoProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCryptoProject[P]>
      : GetScalarType<T[P], AggregateCryptoProject[P]>
  }




  export type CryptoProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CryptoProjectWhereInput
    orderBy?: CryptoProjectOrderByWithAggregationInput | CryptoProjectOrderByWithAggregationInput[]
    by: CryptoProjectScalarFieldEnum[] | CryptoProjectScalarFieldEnum
    having?: CryptoProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CryptoProjectCountAggregateInputType | true
    _avg?: CryptoProjectAvgAggregateInputType
    _sum?: CryptoProjectSumAggregateInputType
    _min?: CryptoProjectMinAggregateInputType
    _max?: CryptoProjectMaxAggregateInputType
  }

  export type CryptoProjectGroupByOutputType = {
    id: string
    userId: string
    name: string
    symbol: string | null
    description: string | null
    category: string | null
    website: string | null
    whitepaper: string | null
    twitter: string | null
    discord: string | null
    telegram: string | null
    github: string | null
    tokenType: $Enums.TokenType
    totalSupply: string | null
    decimals: number
    teamAllocationPercent: number | null
    teamVestingMonths: number | null
    teamCliffMonths: number | null
    vestingType: $Enums.VestingType | null
    initialLiquidity: string | null
    liquidityLockMonths: number | null
    liquidityLockTxHash: string | null
    auditProvider: string | null
    auditReportUrl: string | null
    auditDate: Date | null
    contractAddress: string | null
    contractVerified: boolean
    status: $Enums.ProjectStatus
    submittedAt: Date | null
    reviewedAt: Date | null
    reviewedBy: string | null
    rejectionReason: string | null
    trustScore: number
    trustScoreUpdatedAt: Date | null
    launchDate: Date | null
    softCap: string | null
    hardCap: string | null
    minContribution: string | null
    maxContribution: string | null
    isVerified: boolean
    isFeatured: boolean
    isPaused: boolean
    createdAt: Date
    updatedAt: Date
    _count: CryptoProjectCountAggregateOutputType | null
    _avg: CryptoProjectAvgAggregateOutputType | null
    _sum: CryptoProjectSumAggregateOutputType | null
    _min: CryptoProjectMinAggregateOutputType | null
    _max: CryptoProjectMaxAggregateOutputType | null
  }

  type GetCryptoProjectGroupByPayload<T extends CryptoProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CryptoProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CryptoProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CryptoProjectGroupByOutputType[P]>
            : GetScalarType<T[P], CryptoProjectGroupByOutputType[P]>
        }
      >
    >


  export type CryptoProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    symbol?: boolean
    description?: boolean
    category?: boolean
    website?: boolean
    whitepaper?: boolean
    twitter?: boolean
    discord?: boolean
    telegram?: boolean
    github?: boolean
    tokenType?: boolean
    totalSupply?: boolean
    decimals?: boolean
    teamAllocationPercent?: boolean
    teamVestingMonths?: boolean
    teamCliffMonths?: boolean
    vestingType?: boolean
    initialLiquidity?: boolean
    liquidityLockMonths?: boolean
    liquidityLockTxHash?: boolean
    auditProvider?: boolean
    auditReportUrl?: boolean
    auditDate?: boolean
    contractAddress?: boolean
    contractVerified?: boolean
    status?: boolean
    submittedAt?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    rejectionReason?: boolean
    trustScore?: boolean
    trustScoreUpdatedAt?: boolean
    launchDate?: boolean
    softCap?: boolean
    hardCap?: boolean
    minContribution?: boolean
    maxContribution?: boolean
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    trustScoreEvents?: boolean | CryptoProject$trustScoreEventsArgs<ExtArgs>
    adminNotes?: boolean | CryptoProject$adminNotesArgs<ExtArgs>
    documents?: boolean | CryptoProject$documentsArgs<ExtArgs>
    _count?: boolean | CryptoProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cryptoProject"]>

  export type CryptoProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    symbol?: boolean
    description?: boolean
    category?: boolean
    website?: boolean
    whitepaper?: boolean
    twitter?: boolean
    discord?: boolean
    telegram?: boolean
    github?: boolean
    tokenType?: boolean
    totalSupply?: boolean
    decimals?: boolean
    teamAllocationPercent?: boolean
    teamVestingMonths?: boolean
    teamCliffMonths?: boolean
    vestingType?: boolean
    initialLiquidity?: boolean
    liquidityLockMonths?: boolean
    liquidityLockTxHash?: boolean
    auditProvider?: boolean
    auditReportUrl?: boolean
    auditDate?: boolean
    contractAddress?: boolean
    contractVerified?: boolean
    status?: boolean
    submittedAt?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    rejectionReason?: boolean
    trustScore?: boolean
    trustScoreUpdatedAt?: boolean
    launchDate?: boolean
    softCap?: boolean
    hardCap?: boolean
    minContribution?: boolean
    maxContribution?: boolean
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cryptoProject"]>

  export type CryptoProjectSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    symbol?: boolean
    description?: boolean
    category?: boolean
    website?: boolean
    whitepaper?: boolean
    twitter?: boolean
    discord?: boolean
    telegram?: boolean
    github?: boolean
    tokenType?: boolean
    totalSupply?: boolean
    decimals?: boolean
    teamAllocationPercent?: boolean
    teamVestingMonths?: boolean
    teamCliffMonths?: boolean
    vestingType?: boolean
    initialLiquidity?: boolean
    liquidityLockMonths?: boolean
    liquidityLockTxHash?: boolean
    auditProvider?: boolean
    auditReportUrl?: boolean
    auditDate?: boolean
    contractAddress?: boolean
    contractVerified?: boolean
    status?: boolean
    submittedAt?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    rejectionReason?: boolean
    trustScore?: boolean
    trustScoreUpdatedAt?: boolean
    launchDate?: boolean
    softCap?: boolean
    hardCap?: boolean
    minContribution?: boolean
    maxContribution?: boolean
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CryptoProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    trustScoreEvents?: boolean | CryptoProject$trustScoreEventsArgs<ExtArgs>
    adminNotes?: boolean | CryptoProject$adminNotesArgs<ExtArgs>
    documents?: boolean | CryptoProject$documentsArgs<ExtArgs>
    _count?: boolean | CryptoProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CryptoProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CryptoProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CryptoProject"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      trustScoreEvents: Prisma.$TrustScoreEventPayload<ExtArgs>[]
      adminNotes: Prisma.$AdminNotePayload<ExtArgs>[]
      documents: Prisma.$ProjectDocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      symbol: string | null
      description: string | null
      category: string | null
      website: string | null
      whitepaper: string | null
      twitter: string | null
      discord: string | null
      telegram: string | null
      github: string | null
      tokenType: $Enums.TokenType
      totalSupply: string | null
      decimals: number
      teamAllocationPercent: number | null
      teamVestingMonths: number | null
      teamCliffMonths: number | null
      vestingType: $Enums.VestingType | null
      initialLiquidity: string | null
      liquidityLockMonths: number | null
      liquidityLockTxHash: string | null
      auditProvider: string | null
      auditReportUrl: string | null
      auditDate: Date | null
      contractAddress: string | null
      contractVerified: boolean
      status: $Enums.ProjectStatus
      submittedAt: Date | null
      reviewedAt: Date | null
      reviewedBy: string | null
      rejectionReason: string | null
      trustScore: number
      trustScoreUpdatedAt: Date | null
      launchDate: Date | null
      softCap: string | null
      hardCap: string | null
      minContribution: string | null
      maxContribution: string | null
      isVerified: boolean
      isFeatured: boolean
      isPaused: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cryptoProject"]>
    composites: {}
  }

  type CryptoProjectGetPayload<S extends boolean | null | undefined | CryptoProjectDefaultArgs> = $Result.GetResult<Prisma.$CryptoProjectPayload, S>

  type CryptoProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CryptoProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CryptoProjectCountAggregateInputType | true
    }

  export interface CryptoProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CryptoProject'], meta: { name: 'CryptoProject' } }
    /**
     * Find zero or one CryptoProject that matches the filter.
     * @param {CryptoProjectFindUniqueArgs} args - Arguments to find a CryptoProject
     * @example
     * // Get one CryptoProject
     * const cryptoProject = await prisma.cryptoProject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CryptoProjectFindUniqueArgs>(args: SelectSubset<T, CryptoProjectFindUniqueArgs<ExtArgs>>): Prisma__CryptoProjectClient<$Result.GetResult<Prisma.$CryptoProjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CryptoProject that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CryptoProjectFindUniqueOrThrowArgs} args - Arguments to find a CryptoProject
     * @example
     * // Get one CryptoProject
     * const cryptoProject = await prisma.cryptoProject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CryptoProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, CryptoProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CryptoProjectClient<$Result.GetResult<Prisma.$CryptoProjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CryptoProject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoProjectFindFirstArgs} args - Arguments to find a CryptoProject
     * @example
     * // Get one CryptoProject
     * const cryptoProject = await prisma.cryptoProject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CryptoProjectFindFirstArgs>(args?: SelectSubset<T, CryptoProjectFindFirstArgs<ExtArgs>>): Prisma__CryptoProjectClient<$Result.GetResult<Prisma.$CryptoProjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CryptoProject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoProjectFindFirstOrThrowArgs} args - Arguments to find a CryptoProject
     * @example
     * // Get one CryptoProject
     * const cryptoProject = await prisma.cryptoProject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CryptoProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, CryptoProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__CryptoProjectClient<$Result.GetResult<Prisma.$CryptoProjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CryptoProjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CryptoProjects
     * const cryptoProjects = await prisma.cryptoProject.findMany()
     * 
     * // Get first 10 CryptoProjects
     * const cryptoProjects = await prisma.cryptoProject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cryptoProjectWithIdOnly = await prisma.cryptoProject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CryptoProjectFindManyArgs>(args?: SelectSubset<T, CryptoProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoProjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CryptoProject.
     * @param {CryptoProjectCreateArgs} args - Arguments to create a CryptoProject.
     * @example
     * // Create one CryptoProject
     * const CryptoProject = await prisma.cryptoProject.create({
     *   data: {
     *     // ... data to create a CryptoProject
     *   }
     * })
     * 
     */
    create<T extends CryptoProjectCreateArgs>(args: SelectSubset<T, CryptoProjectCreateArgs<ExtArgs>>): Prisma__CryptoProjectClient<$Result.GetResult<Prisma.$CryptoProjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CryptoProjects.
     * @param {CryptoProjectCreateManyArgs} args - Arguments to create many CryptoProjects.
     * @example
     * // Create many CryptoProjects
     * const cryptoProject = await prisma.cryptoProject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CryptoProjectCreateManyArgs>(args?: SelectSubset<T, CryptoProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CryptoProjects and returns the data saved in the database.
     * @param {CryptoProjectCreateManyAndReturnArgs} args - Arguments to create many CryptoProjects.
     * @example
     * // Create many CryptoProjects
     * const cryptoProject = await prisma.cryptoProject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CryptoProjects and only return the `id`
     * const cryptoProjectWithIdOnly = await prisma.cryptoProject.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CryptoProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, CryptoProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CryptoProjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CryptoProject.
     * @param {CryptoProjectDeleteArgs} args - Arguments to delete one CryptoProject.
     * @example
     * // Delete one CryptoProject
     * const CryptoProject = await prisma.cryptoProject.delete({
     *   where: {
     *     // ... filter to delete one CryptoProject
     *   }
     * })
     * 
     */
    delete<T extends CryptoProjectDeleteArgs>(args: SelectSubset<T, CryptoProjectDeleteArgs<ExtArgs>>): Prisma__CryptoProjectClient<$Result.GetResult<Prisma.$CryptoProjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CryptoProject.
     * @param {CryptoProjectUpdateArgs} args - Arguments to update one CryptoProject.
     * @example
     * // Update one CryptoProject
     * const cryptoProject = await prisma.cryptoProject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CryptoProjectUpdateArgs>(args: SelectSubset<T, CryptoProjectUpdateArgs<ExtArgs>>): Prisma__CryptoProjectClient<$Result.GetResult<Prisma.$CryptoProjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CryptoProjects.
     * @param {CryptoProjectDeleteManyArgs} args - Arguments to filter CryptoProjects to delete.
     * @example
     * // Delete a few CryptoProjects
     * const { count } = await prisma.cryptoProject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CryptoProjectDeleteManyArgs>(args?: SelectSubset<T, CryptoProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CryptoProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CryptoProjects
     * const cryptoProject = await prisma.cryptoProject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CryptoProjectUpdateManyArgs>(args: SelectSubset<T, CryptoProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CryptoProject.
     * @param {CryptoProjectUpsertArgs} args - Arguments to update or create a CryptoProject.
     * @example
     * // Update or create a CryptoProject
     * const cryptoProject = await prisma.cryptoProject.upsert({
     *   create: {
     *     // ... data to create a CryptoProject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CryptoProject we want to update
     *   }
     * })
     */
    upsert<T extends CryptoProjectUpsertArgs>(args: SelectSubset<T, CryptoProjectUpsertArgs<ExtArgs>>): Prisma__CryptoProjectClient<$Result.GetResult<Prisma.$CryptoProjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CryptoProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoProjectCountArgs} args - Arguments to filter CryptoProjects to count.
     * @example
     * // Count the number of CryptoProjects
     * const count = await prisma.cryptoProject.count({
     *   where: {
     *     // ... the filter for the CryptoProjects we want to count
     *   }
     * })
    **/
    count<T extends CryptoProjectCountArgs>(
      args?: Subset<T, CryptoProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CryptoProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CryptoProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CryptoProjectAggregateArgs>(args: Subset<T, CryptoProjectAggregateArgs>): Prisma.PrismaPromise<GetCryptoProjectAggregateType<T>>

    /**
     * Group by CryptoProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptoProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CryptoProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CryptoProjectGroupByArgs['orderBy'] }
        : { orderBy?: CryptoProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CryptoProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCryptoProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CryptoProject model
   */
  readonly fields: CryptoProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CryptoProject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CryptoProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    trustScoreEvents<T extends CryptoProject$trustScoreEventsArgs<ExtArgs> = {}>(args?: Subset<T, CryptoProject$trustScoreEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrustScoreEventPayload<ExtArgs>, T, "findMany"> | Null>
    adminNotes<T extends CryptoProject$adminNotesArgs<ExtArgs> = {}>(args?: Subset<T, CryptoProject$adminNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminNotePayload<ExtArgs>, T, "findMany"> | Null>
    documents<T extends CryptoProject$documentsArgs<ExtArgs> = {}>(args?: Subset<T, CryptoProject$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectDocumentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CryptoProject model
   */ 
  interface CryptoProjectFieldRefs {
    readonly id: FieldRef<"CryptoProject", 'String'>
    readonly userId: FieldRef<"CryptoProject", 'String'>
    readonly name: FieldRef<"CryptoProject", 'String'>
    readonly symbol: FieldRef<"CryptoProject", 'String'>
    readonly description: FieldRef<"CryptoProject", 'String'>
    readonly category: FieldRef<"CryptoProject", 'String'>
    readonly website: FieldRef<"CryptoProject", 'String'>
    readonly whitepaper: FieldRef<"CryptoProject", 'String'>
    readonly twitter: FieldRef<"CryptoProject", 'String'>
    readonly discord: FieldRef<"CryptoProject", 'String'>
    readonly telegram: FieldRef<"CryptoProject", 'String'>
    readonly github: FieldRef<"CryptoProject", 'String'>
    readonly tokenType: FieldRef<"CryptoProject", 'TokenType'>
    readonly totalSupply: FieldRef<"CryptoProject", 'String'>
    readonly decimals: FieldRef<"CryptoProject", 'Int'>
    readonly teamAllocationPercent: FieldRef<"CryptoProject", 'Float'>
    readonly teamVestingMonths: FieldRef<"CryptoProject", 'Int'>
    readonly teamCliffMonths: FieldRef<"CryptoProject", 'Int'>
    readonly vestingType: FieldRef<"CryptoProject", 'VestingType'>
    readonly initialLiquidity: FieldRef<"CryptoProject", 'String'>
    readonly liquidityLockMonths: FieldRef<"CryptoProject", 'Int'>
    readonly liquidityLockTxHash: FieldRef<"CryptoProject", 'String'>
    readonly auditProvider: FieldRef<"CryptoProject", 'String'>
    readonly auditReportUrl: FieldRef<"CryptoProject", 'String'>
    readonly auditDate: FieldRef<"CryptoProject", 'DateTime'>
    readonly contractAddress: FieldRef<"CryptoProject", 'String'>
    readonly contractVerified: FieldRef<"CryptoProject", 'Boolean'>
    readonly status: FieldRef<"CryptoProject", 'ProjectStatus'>
    readonly submittedAt: FieldRef<"CryptoProject", 'DateTime'>
    readonly reviewedAt: FieldRef<"CryptoProject", 'DateTime'>
    readonly reviewedBy: FieldRef<"CryptoProject", 'String'>
    readonly rejectionReason: FieldRef<"CryptoProject", 'String'>
    readonly trustScore: FieldRef<"CryptoProject", 'Int'>
    readonly trustScoreUpdatedAt: FieldRef<"CryptoProject", 'DateTime'>
    readonly launchDate: FieldRef<"CryptoProject", 'DateTime'>
    readonly softCap: FieldRef<"CryptoProject", 'String'>
    readonly hardCap: FieldRef<"CryptoProject", 'String'>
    readonly minContribution: FieldRef<"CryptoProject", 'String'>
    readonly maxContribution: FieldRef<"CryptoProject", 'String'>
    readonly isVerified: FieldRef<"CryptoProject", 'Boolean'>
    readonly isFeatured: FieldRef<"CryptoProject", 'Boolean'>
    readonly isPaused: FieldRef<"CryptoProject", 'Boolean'>
    readonly createdAt: FieldRef<"CryptoProject", 'DateTime'>
    readonly updatedAt: FieldRef<"CryptoProject", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CryptoProject findUnique
   */
  export type CryptoProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoProject
     */
    select?: CryptoProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoProjectInclude<ExtArgs> | null
    /**
     * Filter, which CryptoProject to fetch.
     */
    where: CryptoProjectWhereUniqueInput
  }

  /**
   * CryptoProject findUniqueOrThrow
   */
  export type CryptoProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoProject
     */
    select?: CryptoProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoProjectInclude<ExtArgs> | null
    /**
     * Filter, which CryptoProject to fetch.
     */
    where: CryptoProjectWhereUniqueInput
  }

  /**
   * CryptoProject findFirst
   */
  export type CryptoProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoProject
     */
    select?: CryptoProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoProjectInclude<ExtArgs> | null
    /**
     * Filter, which CryptoProject to fetch.
     */
    where?: CryptoProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoProjects to fetch.
     */
    orderBy?: CryptoProjectOrderByWithRelationInput | CryptoProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CryptoProjects.
     */
    cursor?: CryptoProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CryptoProjects.
     */
    distinct?: CryptoProjectScalarFieldEnum | CryptoProjectScalarFieldEnum[]
  }

  /**
   * CryptoProject findFirstOrThrow
   */
  export type CryptoProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoProject
     */
    select?: CryptoProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoProjectInclude<ExtArgs> | null
    /**
     * Filter, which CryptoProject to fetch.
     */
    where?: CryptoProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoProjects to fetch.
     */
    orderBy?: CryptoProjectOrderByWithRelationInput | CryptoProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CryptoProjects.
     */
    cursor?: CryptoProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CryptoProjects.
     */
    distinct?: CryptoProjectScalarFieldEnum | CryptoProjectScalarFieldEnum[]
  }

  /**
   * CryptoProject findMany
   */
  export type CryptoProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoProject
     */
    select?: CryptoProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoProjectInclude<ExtArgs> | null
    /**
     * Filter, which CryptoProjects to fetch.
     */
    where?: CryptoProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CryptoProjects to fetch.
     */
    orderBy?: CryptoProjectOrderByWithRelationInput | CryptoProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CryptoProjects.
     */
    cursor?: CryptoProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CryptoProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CryptoProjects.
     */
    skip?: number
    distinct?: CryptoProjectScalarFieldEnum | CryptoProjectScalarFieldEnum[]
  }

  /**
   * CryptoProject create
   */
  export type CryptoProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoProject
     */
    select?: CryptoProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a CryptoProject.
     */
    data: XOR<CryptoProjectCreateInput, CryptoProjectUncheckedCreateInput>
  }

  /**
   * CryptoProject createMany
   */
  export type CryptoProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CryptoProjects.
     */
    data: CryptoProjectCreateManyInput | CryptoProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CryptoProject createManyAndReturn
   */
  export type CryptoProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoProject
     */
    select?: CryptoProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CryptoProjects.
     */
    data: CryptoProjectCreateManyInput | CryptoProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CryptoProject update
   */
  export type CryptoProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoProject
     */
    select?: CryptoProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a CryptoProject.
     */
    data: XOR<CryptoProjectUpdateInput, CryptoProjectUncheckedUpdateInput>
    /**
     * Choose, which CryptoProject to update.
     */
    where: CryptoProjectWhereUniqueInput
  }

  /**
   * CryptoProject updateMany
   */
  export type CryptoProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CryptoProjects.
     */
    data: XOR<CryptoProjectUpdateManyMutationInput, CryptoProjectUncheckedUpdateManyInput>
    /**
     * Filter which CryptoProjects to update
     */
    where?: CryptoProjectWhereInput
  }

  /**
   * CryptoProject upsert
   */
  export type CryptoProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoProject
     */
    select?: CryptoProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the CryptoProject to update in case it exists.
     */
    where: CryptoProjectWhereUniqueInput
    /**
     * In case the CryptoProject found by the `where` argument doesn't exist, create a new CryptoProject with this data.
     */
    create: XOR<CryptoProjectCreateInput, CryptoProjectUncheckedCreateInput>
    /**
     * In case the CryptoProject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CryptoProjectUpdateInput, CryptoProjectUncheckedUpdateInput>
  }

  /**
   * CryptoProject delete
   */
  export type CryptoProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoProject
     */
    select?: CryptoProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoProjectInclude<ExtArgs> | null
    /**
     * Filter which CryptoProject to delete.
     */
    where: CryptoProjectWhereUniqueInput
  }

  /**
   * CryptoProject deleteMany
   */
  export type CryptoProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CryptoProjects to delete
     */
    where?: CryptoProjectWhereInput
  }

  /**
   * CryptoProject.trustScoreEvents
   */
  export type CryptoProject$trustScoreEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScoreEvent
     */
    select?: TrustScoreEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreEventInclude<ExtArgs> | null
    where?: TrustScoreEventWhereInput
    orderBy?: TrustScoreEventOrderByWithRelationInput | TrustScoreEventOrderByWithRelationInput[]
    cursor?: TrustScoreEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrustScoreEventScalarFieldEnum | TrustScoreEventScalarFieldEnum[]
  }

  /**
   * CryptoProject.adminNotes
   */
  export type CryptoProject$adminNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNote
     */
    select?: AdminNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNoteInclude<ExtArgs> | null
    where?: AdminNoteWhereInput
    orderBy?: AdminNoteOrderByWithRelationInput | AdminNoteOrderByWithRelationInput[]
    cursor?: AdminNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminNoteScalarFieldEnum | AdminNoteScalarFieldEnum[]
  }

  /**
   * CryptoProject.documents
   */
  export type CryptoProject$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDocument
     */
    select?: ProjectDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDocumentInclude<ExtArgs> | null
    where?: ProjectDocumentWhereInput
    orderBy?: ProjectDocumentOrderByWithRelationInput | ProjectDocumentOrderByWithRelationInput[]
    cursor?: ProjectDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectDocumentScalarFieldEnum | ProjectDocumentScalarFieldEnum[]
  }

  /**
   * CryptoProject without action
   */
  export type CryptoProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoProject
     */
    select?: CryptoProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoProjectInclude<ExtArgs> | null
  }


  /**
   * Model ProjectDocument
   */

  export type AggregateProjectDocument = {
    _count: ProjectDocumentCountAggregateOutputType | null
    _avg: ProjectDocumentAvgAggregateOutputType | null
    _sum: ProjectDocumentSumAggregateOutputType | null
    _min: ProjectDocumentMinAggregateOutputType | null
    _max: ProjectDocumentMaxAggregateOutputType | null
  }

  export type ProjectDocumentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type ProjectDocumentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type ProjectDocumentMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    type: string | null
    fileUrl: string | null
    fileHash: string | null
    fileSize: number | null
    mimeType: string | null
    isPublic: boolean | null
    uploadedAt: Date | null
  }

  export type ProjectDocumentMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    type: string | null
    fileUrl: string | null
    fileHash: string | null
    fileSize: number | null
    mimeType: string | null
    isPublic: boolean | null
    uploadedAt: Date | null
  }

  export type ProjectDocumentCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    type: number
    fileUrl: number
    fileHash: number
    fileSize: number
    mimeType: number
    isPublic: number
    uploadedAt: number
    _all: number
  }


  export type ProjectDocumentAvgAggregateInputType = {
    fileSize?: true
  }

  export type ProjectDocumentSumAggregateInputType = {
    fileSize?: true
  }

  export type ProjectDocumentMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    type?: true
    fileUrl?: true
    fileHash?: true
    fileSize?: true
    mimeType?: true
    isPublic?: true
    uploadedAt?: true
  }

  export type ProjectDocumentMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    type?: true
    fileUrl?: true
    fileHash?: true
    fileSize?: true
    mimeType?: true
    isPublic?: true
    uploadedAt?: true
  }

  export type ProjectDocumentCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    type?: true
    fileUrl?: true
    fileHash?: true
    fileSize?: true
    mimeType?: true
    isPublic?: true
    uploadedAt?: true
    _all?: true
  }

  export type ProjectDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectDocument to aggregate.
     */
    where?: ProjectDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectDocuments to fetch.
     */
    orderBy?: ProjectDocumentOrderByWithRelationInput | ProjectDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectDocuments
    **/
    _count?: true | ProjectDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectDocumentMaxAggregateInputType
  }

  export type GetProjectDocumentAggregateType<T extends ProjectDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectDocument[P]>
      : GetScalarType<T[P], AggregateProjectDocument[P]>
  }




  export type ProjectDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectDocumentWhereInput
    orderBy?: ProjectDocumentOrderByWithAggregationInput | ProjectDocumentOrderByWithAggregationInput[]
    by: ProjectDocumentScalarFieldEnum[] | ProjectDocumentScalarFieldEnum
    having?: ProjectDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectDocumentCountAggregateInputType | true
    _avg?: ProjectDocumentAvgAggregateInputType
    _sum?: ProjectDocumentSumAggregateInputType
    _min?: ProjectDocumentMinAggregateInputType
    _max?: ProjectDocumentMaxAggregateInputType
  }

  export type ProjectDocumentGroupByOutputType = {
    id: string
    projectId: string
    name: string
    type: string
    fileUrl: string
    fileHash: string | null
    fileSize: number | null
    mimeType: string | null
    isPublic: boolean
    uploadedAt: Date
    _count: ProjectDocumentCountAggregateOutputType | null
    _avg: ProjectDocumentAvgAggregateOutputType | null
    _sum: ProjectDocumentSumAggregateOutputType | null
    _min: ProjectDocumentMinAggregateOutputType | null
    _max: ProjectDocumentMaxAggregateOutputType | null
  }

  type GetProjectDocumentGroupByPayload<T extends ProjectDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectDocumentGroupByOutputType[P]>
        }
      >
    >


  export type ProjectDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    type?: boolean
    fileUrl?: boolean
    fileHash?: boolean
    fileSize?: boolean
    mimeType?: boolean
    isPublic?: boolean
    uploadedAt?: boolean
    project?: boolean | CryptoProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectDocument"]>

  export type ProjectDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    type?: boolean
    fileUrl?: boolean
    fileHash?: boolean
    fileSize?: boolean
    mimeType?: boolean
    isPublic?: boolean
    uploadedAt?: boolean
    project?: boolean | CryptoProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectDocument"]>

  export type ProjectDocumentSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    type?: boolean
    fileUrl?: boolean
    fileHash?: boolean
    fileSize?: boolean
    mimeType?: boolean
    isPublic?: boolean
    uploadedAt?: boolean
  }

  export type ProjectDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | CryptoProjectDefaultArgs<ExtArgs>
  }
  export type ProjectDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | CryptoProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectDocument"
    objects: {
      project: Prisma.$CryptoProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      name: string
      type: string
      fileUrl: string
      fileHash: string | null
      fileSize: number | null
      mimeType: string | null
      isPublic: boolean
      uploadedAt: Date
    }, ExtArgs["result"]["projectDocument"]>
    composites: {}
  }

  type ProjectDocumentGetPayload<S extends boolean | null | undefined | ProjectDocumentDefaultArgs> = $Result.GetResult<Prisma.$ProjectDocumentPayload, S>

  type ProjectDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectDocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectDocumentCountAggregateInputType | true
    }

  export interface ProjectDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectDocument'], meta: { name: 'ProjectDocument' } }
    /**
     * Find zero or one ProjectDocument that matches the filter.
     * @param {ProjectDocumentFindUniqueArgs} args - Arguments to find a ProjectDocument
     * @example
     * // Get one ProjectDocument
     * const projectDocument = await prisma.projectDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectDocumentFindUniqueArgs>(args: SelectSubset<T, ProjectDocumentFindUniqueArgs<ExtArgs>>): Prisma__ProjectDocumentClient<$Result.GetResult<Prisma.$ProjectDocumentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectDocument that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectDocumentFindUniqueOrThrowArgs} args - Arguments to find a ProjectDocument
     * @example
     * // Get one ProjectDocument
     * const projectDocument = await prisma.projectDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectDocumentClient<$Result.GetResult<Prisma.$ProjectDocumentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDocumentFindFirstArgs} args - Arguments to find a ProjectDocument
     * @example
     * // Get one ProjectDocument
     * const projectDocument = await prisma.projectDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectDocumentFindFirstArgs>(args?: SelectSubset<T, ProjectDocumentFindFirstArgs<ExtArgs>>): Prisma__ProjectDocumentClient<$Result.GetResult<Prisma.$ProjectDocumentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDocumentFindFirstOrThrowArgs} args - Arguments to find a ProjectDocument
     * @example
     * // Get one ProjectDocument
     * const projectDocument = await prisma.projectDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectDocumentClient<$Result.GetResult<Prisma.$ProjectDocumentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectDocuments
     * const projectDocuments = await prisma.projectDocument.findMany()
     * 
     * // Get first 10 ProjectDocuments
     * const projectDocuments = await prisma.projectDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectDocumentWithIdOnly = await prisma.projectDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectDocumentFindManyArgs>(args?: SelectSubset<T, ProjectDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectDocumentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectDocument.
     * @param {ProjectDocumentCreateArgs} args - Arguments to create a ProjectDocument.
     * @example
     * // Create one ProjectDocument
     * const ProjectDocument = await prisma.projectDocument.create({
     *   data: {
     *     // ... data to create a ProjectDocument
     *   }
     * })
     * 
     */
    create<T extends ProjectDocumentCreateArgs>(args: SelectSubset<T, ProjectDocumentCreateArgs<ExtArgs>>): Prisma__ProjectDocumentClient<$Result.GetResult<Prisma.$ProjectDocumentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectDocuments.
     * @param {ProjectDocumentCreateManyArgs} args - Arguments to create many ProjectDocuments.
     * @example
     * // Create many ProjectDocuments
     * const projectDocument = await prisma.projectDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectDocumentCreateManyArgs>(args?: SelectSubset<T, ProjectDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectDocuments and returns the data saved in the database.
     * @param {ProjectDocumentCreateManyAndReturnArgs} args - Arguments to create many ProjectDocuments.
     * @example
     * // Create many ProjectDocuments
     * const projectDocument = await prisma.projectDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectDocuments and only return the `id`
     * const projectDocumentWithIdOnly = await prisma.projectDocument.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectDocumentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProjectDocument.
     * @param {ProjectDocumentDeleteArgs} args - Arguments to delete one ProjectDocument.
     * @example
     * // Delete one ProjectDocument
     * const ProjectDocument = await prisma.projectDocument.delete({
     *   where: {
     *     // ... filter to delete one ProjectDocument
     *   }
     * })
     * 
     */
    delete<T extends ProjectDocumentDeleteArgs>(args: SelectSubset<T, ProjectDocumentDeleteArgs<ExtArgs>>): Prisma__ProjectDocumentClient<$Result.GetResult<Prisma.$ProjectDocumentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectDocument.
     * @param {ProjectDocumentUpdateArgs} args - Arguments to update one ProjectDocument.
     * @example
     * // Update one ProjectDocument
     * const projectDocument = await prisma.projectDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectDocumentUpdateArgs>(args: SelectSubset<T, ProjectDocumentUpdateArgs<ExtArgs>>): Prisma__ProjectDocumentClient<$Result.GetResult<Prisma.$ProjectDocumentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectDocuments.
     * @param {ProjectDocumentDeleteManyArgs} args - Arguments to filter ProjectDocuments to delete.
     * @example
     * // Delete a few ProjectDocuments
     * const { count } = await prisma.projectDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDocumentDeleteManyArgs>(args?: SelectSubset<T, ProjectDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectDocuments
     * const projectDocument = await prisma.projectDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectDocumentUpdateManyArgs>(args: SelectSubset<T, ProjectDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectDocument.
     * @param {ProjectDocumentUpsertArgs} args - Arguments to update or create a ProjectDocument.
     * @example
     * // Update or create a ProjectDocument
     * const projectDocument = await prisma.projectDocument.upsert({
     *   create: {
     *     // ... data to create a ProjectDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectDocument we want to update
     *   }
     * })
     */
    upsert<T extends ProjectDocumentUpsertArgs>(args: SelectSubset<T, ProjectDocumentUpsertArgs<ExtArgs>>): Prisma__ProjectDocumentClient<$Result.GetResult<Prisma.$ProjectDocumentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDocumentCountArgs} args - Arguments to filter ProjectDocuments to count.
     * @example
     * // Count the number of ProjectDocuments
     * const count = await prisma.projectDocument.count({
     *   where: {
     *     // ... the filter for the ProjectDocuments we want to count
     *   }
     * })
    **/
    count<T extends ProjectDocumentCountArgs>(
      args?: Subset<T, ProjectDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectDocumentAggregateArgs>(args: Subset<T, ProjectDocumentAggregateArgs>): Prisma.PrismaPromise<GetProjectDocumentAggregateType<T>>

    /**
     * Group by ProjectDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectDocumentGroupByArgs['orderBy'] }
        : { orderBy?: ProjectDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectDocument model
   */
  readonly fields: ProjectDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends CryptoProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CryptoProjectDefaultArgs<ExtArgs>>): Prisma__CryptoProjectClient<$Result.GetResult<Prisma.$CryptoProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectDocument model
   */ 
  interface ProjectDocumentFieldRefs {
    readonly id: FieldRef<"ProjectDocument", 'String'>
    readonly projectId: FieldRef<"ProjectDocument", 'String'>
    readonly name: FieldRef<"ProjectDocument", 'String'>
    readonly type: FieldRef<"ProjectDocument", 'String'>
    readonly fileUrl: FieldRef<"ProjectDocument", 'String'>
    readonly fileHash: FieldRef<"ProjectDocument", 'String'>
    readonly fileSize: FieldRef<"ProjectDocument", 'Int'>
    readonly mimeType: FieldRef<"ProjectDocument", 'String'>
    readonly isPublic: FieldRef<"ProjectDocument", 'Boolean'>
    readonly uploadedAt: FieldRef<"ProjectDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectDocument findUnique
   */
  export type ProjectDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDocument
     */
    select?: ProjectDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ProjectDocument to fetch.
     */
    where: ProjectDocumentWhereUniqueInput
  }

  /**
   * ProjectDocument findUniqueOrThrow
   */
  export type ProjectDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDocument
     */
    select?: ProjectDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ProjectDocument to fetch.
     */
    where: ProjectDocumentWhereUniqueInput
  }

  /**
   * ProjectDocument findFirst
   */
  export type ProjectDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDocument
     */
    select?: ProjectDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ProjectDocument to fetch.
     */
    where?: ProjectDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectDocuments to fetch.
     */
    orderBy?: ProjectDocumentOrderByWithRelationInput | ProjectDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectDocuments.
     */
    cursor?: ProjectDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectDocuments.
     */
    distinct?: ProjectDocumentScalarFieldEnum | ProjectDocumentScalarFieldEnum[]
  }

  /**
   * ProjectDocument findFirstOrThrow
   */
  export type ProjectDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDocument
     */
    select?: ProjectDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ProjectDocument to fetch.
     */
    where?: ProjectDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectDocuments to fetch.
     */
    orderBy?: ProjectDocumentOrderByWithRelationInput | ProjectDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectDocuments.
     */
    cursor?: ProjectDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectDocuments.
     */
    distinct?: ProjectDocumentScalarFieldEnum | ProjectDocumentScalarFieldEnum[]
  }

  /**
   * ProjectDocument findMany
   */
  export type ProjectDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDocument
     */
    select?: ProjectDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDocumentInclude<ExtArgs> | null
    /**
     * Filter, which ProjectDocuments to fetch.
     */
    where?: ProjectDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectDocuments to fetch.
     */
    orderBy?: ProjectDocumentOrderByWithRelationInput | ProjectDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectDocuments.
     */
    cursor?: ProjectDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectDocuments.
     */
    skip?: number
    distinct?: ProjectDocumentScalarFieldEnum | ProjectDocumentScalarFieldEnum[]
  }

  /**
   * ProjectDocument create
   */
  export type ProjectDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDocument
     */
    select?: ProjectDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectDocument.
     */
    data: XOR<ProjectDocumentCreateInput, ProjectDocumentUncheckedCreateInput>
  }

  /**
   * ProjectDocument createMany
   */
  export type ProjectDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectDocuments.
     */
    data: ProjectDocumentCreateManyInput | ProjectDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectDocument createManyAndReturn
   */
  export type ProjectDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDocument
     */
    select?: ProjectDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProjectDocuments.
     */
    data: ProjectDocumentCreateManyInput | ProjectDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectDocument update
   */
  export type ProjectDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDocument
     */
    select?: ProjectDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectDocument.
     */
    data: XOR<ProjectDocumentUpdateInput, ProjectDocumentUncheckedUpdateInput>
    /**
     * Choose, which ProjectDocument to update.
     */
    where: ProjectDocumentWhereUniqueInput
  }

  /**
   * ProjectDocument updateMany
   */
  export type ProjectDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectDocuments.
     */
    data: XOR<ProjectDocumentUpdateManyMutationInput, ProjectDocumentUncheckedUpdateManyInput>
    /**
     * Filter which ProjectDocuments to update
     */
    where?: ProjectDocumentWhereInput
  }

  /**
   * ProjectDocument upsert
   */
  export type ProjectDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDocument
     */
    select?: ProjectDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectDocument to update in case it exists.
     */
    where: ProjectDocumentWhereUniqueInput
    /**
     * In case the ProjectDocument found by the `where` argument doesn't exist, create a new ProjectDocument with this data.
     */
    create: XOR<ProjectDocumentCreateInput, ProjectDocumentUncheckedCreateInput>
    /**
     * In case the ProjectDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectDocumentUpdateInput, ProjectDocumentUncheckedUpdateInput>
  }

  /**
   * ProjectDocument delete
   */
  export type ProjectDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDocument
     */
    select?: ProjectDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDocumentInclude<ExtArgs> | null
    /**
     * Filter which ProjectDocument to delete.
     */
    where: ProjectDocumentWhereUniqueInput
  }

  /**
   * ProjectDocument deleteMany
   */
  export type ProjectDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectDocuments to delete
     */
    where?: ProjectDocumentWhereInput
  }

  /**
   * ProjectDocument without action
   */
  export type ProjectDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectDocument
     */
    select?: ProjectDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectDocumentInclude<ExtArgs> | null
  }


  /**
   * Model Business
   */

  export type AggregateBusiness = {
    _count: BusinessCountAggregateOutputType | null
    _avg: BusinessAvgAggregateOutputType | null
    _sum: BusinessSumAggregateOutputType | null
    _min: BusinessMinAggregateOutputType | null
    _max: BusinessMaxAggregateOutputType | null
  }

  export type BusinessAvgAggregateOutputType = {
    employeeCount: number | null
    equityPercent: number | null
    revenueSharePercent: number | null
    trustScore: number | null
  }

  export type BusinessSumAggregateOutputType = {
    employeeCount: number | null
    equityPercent: number | null
    revenueSharePercent: number | null
    trustScore: number | null
  }

  export type BusinessMinAggregateOutputType = {
    id: string | null
    userId: string | null
    legalName: string | null
    dba: string | null
    entityType: string | null
    jurisdiction: string | null
    ein: string | null
    registrationNumber: string | null
    incorporationDate: Date | null
    address: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    businessEmail: string | null
    businessPhone: string | null
    website: string | null
    description: string | null
    industry: string | null
    employeeCount: number | null
    annualRevenue: string | null
    linkedin: string | null
    twitter: string | null
    kybLevel: $Enums.KYBLevel | null
    kybProvider: string | null
    kybVerifiedAt: Date | null
    kybExpiresAt: Date | null
    kybRejectionReason: string | null
    tokenType: $Enums.TokenType | null
    raiseAmount: string | null
    equityPercent: number | null
    revenueSharePercent: number | null
    minInvestment: string | null
    maxInvestment: string | null
    status: $Enums.BusinessStatus | null
    submittedAt: Date | null
    reviewedAt: Date | null
    reviewedBy: string | null
    rejectionReason: string | null
    trustScore: number | null
    trustScoreUpdatedAt: Date | null
    isVerified: boolean | null
    isFeatured: boolean | null
    isPaused: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    legalName: string | null
    dba: string | null
    entityType: string | null
    jurisdiction: string | null
    ein: string | null
    registrationNumber: string | null
    incorporationDate: Date | null
    address: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    businessEmail: string | null
    businessPhone: string | null
    website: string | null
    description: string | null
    industry: string | null
    employeeCount: number | null
    annualRevenue: string | null
    linkedin: string | null
    twitter: string | null
    kybLevel: $Enums.KYBLevel | null
    kybProvider: string | null
    kybVerifiedAt: Date | null
    kybExpiresAt: Date | null
    kybRejectionReason: string | null
    tokenType: $Enums.TokenType | null
    raiseAmount: string | null
    equityPercent: number | null
    revenueSharePercent: number | null
    minInvestment: string | null
    maxInvestment: string | null
    status: $Enums.BusinessStatus | null
    submittedAt: Date | null
    reviewedAt: Date | null
    reviewedBy: string | null
    rejectionReason: string | null
    trustScore: number | null
    trustScoreUpdatedAt: Date | null
    isVerified: boolean | null
    isFeatured: boolean | null
    isPaused: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessCountAggregateOutputType = {
    id: number
    userId: number
    legalName: number
    dba: number
    entityType: number
    jurisdiction: number
    ein: number
    registrationNumber: number
    incorporationDate: number
    address: number
    city: number
    state: number
    postalCode: number
    country: number
    businessEmail: number
    businessPhone: number
    website: number
    description: number
    industry: number
    employeeCount: number
    annualRevenue: number
    linkedin: number
    twitter: number
    kybLevel: number
    kybProvider: number
    kybVerifiedAt: number
    kybExpiresAt: number
    kybRejectionReason: number
    tokenType: number
    raiseAmount: number
    equityPercent: number
    revenueSharePercent: number
    minInvestment: number
    maxInvestment: number
    status: number
    submittedAt: number
    reviewedAt: number
    reviewedBy: number
    rejectionReason: number
    trustScore: number
    trustScoreUpdatedAt: number
    isVerified: number
    isFeatured: number
    isPaused: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BusinessAvgAggregateInputType = {
    employeeCount?: true
    equityPercent?: true
    revenueSharePercent?: true
    trustScore?: true
  }

  export type BusinessSumAggregateInputType = {
    employeeCount?: true
    equityPercent?: true
    revenueSharePercent?: true
    trustScore?: true
  }

  export type BusinessMinAggregateInputType = {
    id?: true
    userId?: true
    legalName?: true
    dba?: true
    entityType?: true
    jurisdiction?: true
    ein?: true
    registrationNumber?: true
    incorporationDate?: true
    address?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    businessEmail?: true
    businessPhone?: true
    website?: true
    description?: true
    industry?: true
    employeeCount?: true
    annualRevenue?: true
    linkedin?: true
    twitter?: true
    kybLevel?: true
    kybProvider?: true
    kybVerifiedAt?: true
    kybExpiresAt?: true
    kybRejectionReason?: true
    tokenType?: true
    raiseAmount?: true
    equityPercent?: true
    revenueSharePercent?: true
    minInvestment?: true
    maxInvestment?: true
    status?: true
    submittedAt?: true
    reviewedAt?: true
    reviewedBy?: true
    rejectionReason?: true
    trustScore?: true
    trustScoreUpdatedAt?: true
    isVerified?: true
    isFeatured?: true
    isPaused?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessMaxAggregateInputType = {
    id?: true
    userId?: true
    legalName?: true
    dba?: true
    entityType?: true
    jurisdiction?: true
    ein?: true
    registrationNumber?: true
    incorporationDate?: true
    address?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    businessEmail?: true
    businessPhone?: true
    website?: true
    description?: true
    industry?: true
    employeeCount?: true
    annualRevenue?: true
    linkedin?: true
    twitter?: true
    kybLevel?: true
    kybProvider?: true
    kybVerifiedAt?: true
    kybExpiresAt?: true
    kybRejectionReason?: true
    tokenType?: true
    raiseAmount?: true
    equityPercent?: true
    revenueSharePercent?: true
    minInvestment?: true
    maxInvestment?: true
    status?: true
    submittedAt?: true
    reviewedAt?: true
    reviewedBy?: true
    rejectionReason?: true
    trustScore?: true
    trustScoreUpdatedAt?: true
    isVerified?: true
    isFeatured?: true
    isPaused?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessCountAggregateInputType = {
    id?: true
    userId?: true
    legalName?: true
    dba?: true
    entityType?: true
    jurisdiction?: true
    ein?: true
    registrationNumber?: true
    incorporationDate?: true
    address?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    businessEmail?: true
    businessPhone?: true
    website?: true
    description?: true
    industry?: true
    employeeCount?: true
    annualRevenue?: true
    linkedin?: true
    twitter?: true
    kybLevel?: true
    kybProvider?: true
    kybVerifiedAt?: true
    kybExpiresAt?: true
    kybRejectionReason?: true
    tokenType?: true
    raiseAmount?: true
    equityPercent?: true
    revenueSharePercent?: true
    minInvestment?: true
    maxInvestment?: true
    status?: true
    submittedAt?: true
    reviewedAt?: true
    reviewedBy?: true
    rejectionReason?: true
    trustScore?: true
    trustScoreUpdatedAt?: true
    isVerified?: true
    isFeatured?: true
    isPaused?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BusinessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Business to aggregate.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Businesses
    **/
    _count?: true | BusinessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusinessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusinessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessMaxAggregateInputType
  }

  export type GetBusinessAggregateType<T extends BusinessAggregateArgs> = {
        [P in keyof T & keyof AggregateBusiness]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusiness[P]>
      : GetScalarType<T[P], AggregateBusiness[P]>
  }




  export type BusinessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessWhereInput
    orderBy?: BusinessOrderByWithAggregationInput | BusinessOrderByWithAggregationInput[]
    by: BusinessScalarFieldEnum[] | BusinessScalarFieldEnum
    having?: BusinessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessCountAggregateInputType | true
    _avg?: BusinessAvgAggregateInputType
    _sum?: BusinessSumAggregateInputType
    _min?: BusinessMinAggregateInputType
    _max?: BusinessMaxAggregateInputType
  }

  export type BusinessGroupByOutputType = {
    id: string
    userId: string
    legalName: string
    dba: string | null
    entityType: string | null
    jurisdiction: string | null
    ein: string | null
    registrationNumber: string | null
    incorporationDate: Date | null
    address: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    businessEmail: string | null
    businessPhone: string | null
    website: string | null
    description: string | null
    industry: string | null
    employeeCount: number | null
    annualRevenue: string | null
    linkedin: string | null
    twitter: string | null
    kybLevel: $Enums.KYBLevel
    kybProvider: string | null
    kybVerifiedAt: Date | null
    kybExpiresAt: Date | null
    kybRejectionReason: string | null
    tokenType: $Enums.TokenType | null
    raiseAmount: string | null
    equityPercent: number | null
    revenueSharePercent: number | null
    minInvestment: string | null
    maxInvestment: string | null
    status: $Enums.BusinessStatus
    submittedAt: Date | null
    reviewedAt: Date | null
    reviewedBy: string | null
    rejectionReason: string | null
    trustScore: number
    trustScoreUpdatedAt: Date | null
    isVerified: boolean
    isFeatured: boolean
    isPaused: boolean
    createdAt: Date
    updatedAt: Date
    _count: BusinessCountAggregateOutputType | null
    _avg: BusinessAvgAggregateOutputType | null
    _sum: BusinessSumAggregateOutputType | null
    _min: BusinessMinAggregateOutputType | null
    _max: BusinessMaxAggregateOutputType | null
  }

  type GetBusinessGroupByPayload<T extends BusinessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessGroupByOutputType[P]>
        }
      >
    >


  export type BusinessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    legalName?: boolean
    dba?: boolean
    entityType?: boolean
    jurisdiction?: boolean
    ein?: boolean
    registrationNumber?: boolean
    incorporationDate?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    businessEmail?: boolean
    businessPhone?: boolean
    website?: boolean
    description?: boolean
    industry?: boolean
    employeeCount?: boolean
    annualRevenue?: boolean
    linkedin?: boolean
    twitter?: boolean
    kybLevel?: boolean
    kybProvider?: boolean
    kybVerifiedAt?: boolean
    kybExpiresAt?: boolean
    kybRejectionReason?: boolean
    tokenType?: boolean
    raiseAmount?: boolean
    equityPercent?: boolean
    revenueSharePercent?: boolean
    minInvestment?: boolean
    maxInvestment?: boolean
    status?: boolean
    submittedAt?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    rejectionReason?: boolean
    trustScore?: boolean
    trustScoreUpdatedAt?: boolean
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    founders?: boolean | Business$foundersArgs<ExtArgs>
    documents?: boolean | Business$documentsArgs<ExtArgs>
    trustScoreEvents?: boolean | Business$trustScoreEventsArgs<ExtArgs>
    adminNotes?: boolean | Business$adminNotesArgs<ExtArgs>
    revenueReports?: boolean | Business$revenueReportsArgs<ExtArgs>
    _count?: boolean | BusinessCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["business"]>

  export type BusinessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    legalName?: boolean
    dba?: boolean
    entityType?: boolean
    jurisdiction?: boolean
    ein?: boolean
    registrationNumber?: boolean
    incorporationDate?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    businessEmail?: boolean
    businessPhone?: boolean
    website?: boolean
    description?: boolean
    industry?: boolean
    employeeCount?: boolean
    annualRevenue?: boolean
    linkedin?: boolean
    twitter?: boolean
    kybLevel?: boolean
    kybProvider?: boolean
    kybVerifiedAt?: boolean
    kybExpiresAt?: boolean
    kybRejectionReason?: boolean
    tokenType?: boolean
    raiseAmount?: boolean
    equityPercent?: boolean
    revenueSharePercent?: boolean
    minInvestment?: boolean
    maxInvestment?: boolean
    status?: boolean
    submittedAt?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    rejectionReason?: boolean
    trustScore?: boolean
    trustScoreUpdatedAt?: boolean
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["business"]>

  export type BusinessSelectScalar = {
    id?: boolean
    userId?: boolean
    legalName?: boolean
    dba?: boolean
    entityType?: boolean
    jurisdiction?: boolean
    ein?: boolean
    registrationNumber?: boolean
    incorporationDate?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    businessEmail?: boolean
    businessPhone?: boolean
    website?: boolean
    description?: boolean
    industry?: boolean
    employeeCount?: boolean
    annualRevenue?: boolean
    linkedin?: boolean
    twitter?: boolean
    kybLevel?: boolean
    kybProvider?: boolean
    kybVerifiedAt?: boolean
    kybExpiresAt?: boolean
    kybRejectionReason?: boolean
    tokenType?: boolean
    raiseAmount?: boolean
    equityPercent?: boolean
    revenueSharePercent?: boolean
    minInvestment?: boolean
    maxInvestment?: boolean
    status?: boolean
    submittedAt?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    rejectionReason?: boolean
    trustScore?: boolean
    trustScoreUpdatedAt?: boolean
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BusinessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    founders?: boolean | Business$foundersArgs<ExtArgs>
    documents?: boolean | Business$documentsArgs<ExtArgs>
    trustScoreEvents?: boolean | Business$trustScoreEventsArgs<ExtArgs>
    adminNotes?: boolean | Business$adminNotesArgs<ExtArgs>
    revenueReports?: boolean | Business$revenueReportsArgs<ExtArgs>
    _count?: boolean | BusinessCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BusinessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BusinessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Business"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      founders: Prisma.$BusinessFounderPayload<ExtArgs>[]
      documents: Prisma.$BusinessDocumentPayload<ExtArgs>[]
      trustScoreEvents: Prisma.$TrustScoreEventPayload<ExtArgs>[]
      adminNotes: Prisma.$AdminNotePayload<ExtArgs>[]
      revenueReports: Prisma.$RevenueReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      legalName: string
      dba: string | null
      entityType: string | null
      jurisdiction: string | null
      ein: string | null
      registrationNumber: string | null
      incorporationDate: Date | null
      address: string | null
      city: string | null
      state: string | null
      postalCode: string | null
      country: string | null
      businessEmail: string | null
      businessPhone: string | null
      website: string | null
      description: string | null
      industry: string | null
      employeeCount: number | null
      annualRevenue: string | null
      linkedin: string | null
      twitter: string | null
      kybLevel: $Enums.KYBLevel
      kybProvider: string | null
      kybVerifiedAt: Date | null
      kybExpiresAt: Date | null
      kybRejectionReason: string | null
      tokenType: $Enums.TokenType | null
      raiseAmount: string | null
      equityPercent: number | null
      revenueSharePercent: number | null
      minInvestment: string | null
      maxInvestment: string | null
      status: $Enums.BusinessStatus
      submittedAt: Date | null
      reviewedAt: Date | null
      reviewedBy: string | null
      rejectionReason: string | null
      trustScore: number
      trustScoreUpdatedAt: Date | null
      isVerified: boolean
      isFeatured: boolean
      isPaused: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["business"]>
    composites: {}
  }

  type BusinessGetPayload<S extends boolean | null | undefined | BusinessDefaultArgs> = $Result.GetResult<Prisma.$BusinessPayload, S>

  type BusinessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BusinessFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BusinessCountAggregateInputType | true
    }

  export interface BusinessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Business'], meta: { name: 'Business' } }
    /**
     * Find zero or one Business that matches the filter.
     * @param {BusinessFindUniqueArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessFindUniqueArgs>(args: SelectSubset<T, BusinessFindUniqueArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Business that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BusinessFindUniqueOrThrowArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Business that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFindFirstArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessFindFirstArgs>(args?: SelectSubset<T, BusinessFindFirstArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Business that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFindFirstOrThrowArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Businesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Businesses
     * const businesses = await prisma.business.findMany()
     * 
     * // Get first 10 Businesses
     * const businesses = await prisma.business.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessWithIdOnly = await prisma.business.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessFindManyArgs>(args?: SelectSubset<T, BusinessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Business.
     * @param {BusinessCreateArgs} args - Arguments to create a Business.
     * @example
     * // Create one Business
     * const Business = await prisma.business.create({
     *   data: {
     *     // ... data to create a Business
     *   }
     * })
     * 
     */
    create<T extends BusinessCreateArgs>(args: SelectSubset<T, BusinessCreateArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Businesses.
     * @param {BusinessCreateManyArgs} args - Arguments to create many Businesses.
     * @example
     * // Create many Businesses
     * const business = await prisma.business.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessCreateManyArgs>(args?: SelectSubset<T, BusinessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Businesses and returns the data saved in the database.
     * @param {BusinessCreateManyAndReturnArgs} args - Arguments to create many Businesses.
     * @example
     * // Create many Businesses
     * const business = await prisma.business.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Businesses and only return the `id`
     * const businessWithIdOnly = await prisma.business.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Business.
     * @param {BusinessDeleteArgs} args - Arguments to delete one Business.
     * @example
     * // Delete one Business
     * const Business = await prisma.business.delete({
     *   where: {
     *     // ... filter to delete one Business
     *   }
     * })
     * 
     */
    delete<T extends BusinessDeleteArgs>(args: SelectSubset<T, BusinessDeleteArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Business.
     * @param {BusinessUpdateArgs} args - Arguments to update one Business.
     * @example
     * // Update one Business
     * const business = await prisma.business.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessUpdateArgs>(args: SelectSubset<T, BusinessUpdateArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Businesses.
     * @param {BusinessDeleteManyArgs} args - Arguments to filter Businesses to delete.
     * @example
     * // Delete a few Businesses
     * const { count } = await prisma.business.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessDeleteManyArgs>(args?: SelectSubset<T, BusinessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Businesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Businesses
     * const business = await prisma.business.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessUpdateManyArgs>(args: SelectSubset<T, BusinessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Business.
     * @param {BusinessUpsertArgs} args - Arguments to update or create a Business.
     * @example
     * // Update or create a Business
     * const business = await prisma.business.upsert({
     *   create: {
     *     // ... data to create a Business
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Business we want to update
     *   }
     * })
     */
    upsert<T extends BusinessUpsertArgs>(args: SelectSubset<T, BusinessUpsertArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Businesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessCountArgs} args - Arguments to filter Businesses to count.
     * @example
     * // Count the number of Businesses
     * const count = await prisma.business.count({
     *   where: {
     *     // ... the filter for the Businesses we want to count
     *   }
     * })
    **/
    count<T extends BusinessCountArgs>(
      args?: Subset<T, BusinessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Business.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessAggregateArgs>(args: Subset<T, BusinessAggregateArgs>): Prisma.PrismaPromise<GetBusinessAggregateType<T>>

    /**
     * Group by Business.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessGroupByArgs['orderBy'] }
        : { orderBy?: BusinessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Business model
   */
  readonly fields: BusinessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Business.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    founders<T extends Business$foundersArgs<ExtArgs> = {}>(args?: Subset<T, Business$foundersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessFounderPayload<ExtArgs>, T, "findMany"> | Null>
    documents<T extends Business$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Business$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessDocumentPayload<ExtArgs>, T, "findMany"> | Null>
    trustScoreEvents<T extends Business$trustScoreEventsArgs<ExtArgs> = {}>(args?: Subset<T, Business$trustScoreEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrustScoreEventPayload<ExtArgs>, T, "findMany"> | Null>
    adminNotes<T extends Business$adminNotesArgs<ExtArgs> = {}>(args?: Subset<T, Business$adminNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminNotePayload<ExtArgs>, T, "findMany"> | Null>
    revenueReports<T extends Business$revenueReportsArgs<ExtArgs> = {}>(args?: Subset<T, Business$revenueReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevenueReportPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Business model
   */ 
  interface BusinessFieldRefs {
    readonly id: FieldRef<"Business", 'String'>
    readonly userId: FieldRef<"Business", 'String'>
    readonly legalName: FieldRef<"Business", 'String'>
    readonly dba: FieldRef<"Business", 'String'>
    readonly entityType: FieldRef<"Business", 'String'>
    readonly jurisdiction: FieldRef<"Business", 'String'>
    readonly ein: FieldRef<"Business", 'String'>
    readonly registrationNumber: FieldRef<"Business", 'String'>
    readonly incorporationDate: FieldRef<"Business", 'DateTime'>
    readonly address: FieldRef<"Business", 'String'>
    readonly city: FieldRef<"Business", 'String'>
    readonly state: FieldRef<"Business", 'String'>
    readonly postalCode: FieldRef<"Business", 'String'>
    readonly country: FieldRef<"Business", 'String'>
    readonly businessEmail: FieldRef<"Business", 'String'>
    readonly businessPhone: FieldRef<"Business", 'String'>
    readonly website: FieldRef<"Business", 'String'>
    readonly description: FieldRef<"Business", 'String'>
    readonly industry: FieldRef<"Business", 'String'>
    readonly employeeCount: FieldRef<"Business", 'Int'>
    readonly annualRevenue: FieldRef<"Business", 'String'>
    readonly linkedin: FieldRef<"Business", 'String'>
    readonly twitter: FieldRef<"Business", 'String'>
    readonly kybLevel: FieldRef<"Business", 'KYBLevel'>
    readonly kybProvider: FieldRef<"Business", 'String'>
    readonly kybVerifiedAt: FieldRef<"Business", 'DateTime'>
    readonly kybExpiresAt: FieldRef<"Business", 'DateTime'>
    readonly kybRejectionReason: FieldRef<"Business", 'String'>
    readonly tokenType: FieldRef<"Business", 'TokenType'>
    readonly raiseAmount: FieldRef<"Business", 'String'>
    readonly equityPercent: FieldRef<"Business", 'Float'>
    readonly revenueSharePercent: FieldRef<"Business", 'Float'>
    readonly minInvestment: FieldRef<"Business", 'String'>
    readonly maxInvestment: FieldRef<"Business", 'String'>
    readonly status: FieldRef<"Business", 'BusinessStatus'>
    readonly submittedAt: FieldRef<"Business", 'DateTime'>
    readonly reviewedAt: FieldRef<"Business", 'DateTime'>
    readonly reviewedBy: FieldRef<"Business", 'String'>
    readonly rejectionReason: FieldRef<"Business", 'String'>
    readonly trustScore: FieldRef<"Business", 'Int'>
    readonly trustScoreUpdatedAt: FieldRef<"Business", 'DateTime'>
    readonly isVerified: FieldRef<"Business", 'Boolean'>
    readonly isFeatured: FieldRef<"Business", 'Boolean'>
    readonly isPaused: FieldRef<"Business", 'Boolean'>
    readonly createdAt: FieldRef<"Business", 'DateTime'>
    readonly updatedAt: FieldRef<"Business", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Business findUnique
   */
  export type BusinessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business findUniqueOrThrow
   */
  export type BusinessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business findFirst
   */
  export type BusinessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Businesses.
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Businesses.
     */
    distinct?: BusinessScalarFieldEnum | BusinessScalarFieldEnum[]
  }

  /**
   * Business findFirstOrThrow
   */
  export type BusinessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Businesses.
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Businesses.
     */
    distinct?: BusinessScalarFieldEnum | BusinessScalarFieldEnum[]
  }

  /**
   * Business findMany
   */
  export type BusinessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Businesses to fetch.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Businesses.
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    distinct?: BusinessScalarFieldEnum | BusinessScalarFieldEnum[]
  }

  /**
   * Business create
   */
  export type BusinessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * The data needed to create a Business.
     */
    data: XOR<BusinessCreateInput, BusinessUncheckedCreateInput>
  }

  /**
   * Business createMany
   */
  export type BusinessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Businesses.
     */
    data: BusinessCreateManyInput | BusinessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Business createManyAndReturn
   */
  export type BusinessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Businesses.
     */
    data: BusinessCreateManyInput | BusinessCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Business update
   */
  export type BusinessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * The data needed to update a Business.
     */
    data: XOR<BusinessUpdateInput, BusinessUncheckedUpdateInput>
    /**
     * Choose, which Business to update.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business updateMany
   */
  export type BusinessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Businesses.
     */
    data: XOR<BusinessUpdateManyMutationInput, BusinessUncheckedUpdateManyInput>
    /**
     * Filter which Businesses to update
     */
    where?: BusinessWhereInput
  }

  /**
   * Business upsert
   */
  export type BusinessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * The filter to search for the Business to update in case it exists.
     */
    where: BusinessWhereUniqueInput
    /**
     * In case the Business found by the `where` argument doesn't exist, create a new Business with this data.
     */
    create: XOR<BusinessCreateInput, BusinessUncheckedCreateInput>
    /**
     * In case the Business was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessUpdateInput, BusinessUncheckedUpdateInput>
  }

  /**
   * Business delete
   */
  export type BusinessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter which Business to delete.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business deleteMany
   */
  export type BusinessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Businesses to delete
     */
    where?: BusinessWhereInput
  }

  /**
   * Business.founders
   */
  export type Business$foundersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessFounder
     */
    select?: BusinessFounderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessFounderInclude<ExtArgs> | null
    where?: BusinessFounderWhereInput
    orderBy?: BusinessFounderOrderByWithRelationInput | BusinessFounderOrderByWithRelationInput[]
    cursor?: BusinessFounderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessFounderScalarFieldEnum | BusinessFounderScalarFieldEnum[]
  }

  /**
   * Business.documents
   */
  export type Business$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDocument
     */
    select?: BusinessDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessDocumentInclude<ExtArgs> | null
    where?: BusinessDocumentWhereInput
    orderBy?: BusinessDocumentOrderByWithRelationInput | BusinessDocumentOrderByWithRelationInput[]
    cursor?: BusinessDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessDocumentScalarFieldEnum | BusinessDocumentScalarFieldEnum[]
  }

  /**
   * Business.trustScoreEvents
   */
  export type Business$trustScoreEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScoreEvent
     */
    select?: TrustScoreEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreEventInclude<ExtArgs> | null
    where?: TrustScoreEventWhereInput
    orderBy?: TrustScoreEventOrderByWithRelationInput | TrustScoreEventOrderByWithRelationInput[]
    cursor?: TrustScoreEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrustScoreEventScalarFieldEnum | TrustScoreEventScalarFieldEnum[]
  }

  /**
   * Business.adminNotes
   */
  export type Business$adminNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNote
     */
    select?: AdminNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNoteInclude<ExtArgs> | null
    where?: AdminNoteWhereInput
    orderBy?: AdminNoteOrderByWithRelationInput | AdminNoteOrderByWithRelationInput[]
    cursor?: AdminNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminNoteScalarFieldEnum | AdminNoteScalarFieldEnum[]
  }

  /**
   * Business.revenueReports
   */
  export type Business$revenueReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueReport
     */
    select?: RevenueReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueReportInclude<ExtArgs> | null
    where?: RevenueReportWhereInput
    orderBy?: RevenueReportOrderByWithRelationInput | RevenueReportOrderByWithRelationInput[]
    cursor?: RevenueReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RevenueReportScalarFieldEnum | RevenueReportScalarFieldEnum[]
  }

  /**
   * Business without action
   */
  export type BusinessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
  }


  /**
   * Model BusinessFounder
   */

  export type AggregateBusinessFounder = {
    _count: BusinessFounderCountAggregateOutputType | null
    _avg: BusinessFounderAvgAggregateOutputType | null
    _sum: BusinessFounderSumAggregateOutputType | null
    _min: BusinessFounderMinAggregateOutputType | null
    _max: BusinessFounderMaxAggregateOutputType | null
  }

  export type BusinessFounderAvgAggregateOutputType = {
    ownershipPercent: number | null
  }

  export type BusinessFounderSumAggregateOutputType = {
    ownershipPercent: number | null
  }

  export type BusinessFounderMinAggregateOutputType = {
    id: string | null
    businessId: string | null
    name: string | null
    role: string | null
    email: string | null
    ownershipPercent: number | null
    walletAddress: string | null
    linkedinUrl: string | null
    kycVerified: boolean | null
    kycVerifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessFounderMaxAggregateOutputType = {
    id: string | null
    businessId: string | null
    name: string | null
    role: string | null
    email: string | null
    ownershipPercent: number | null
    walletAddress: string | null
    linkedinUrl: string | null
    kycVerified: boolean | null
    kycVerifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessFounderCountAggregateOutputType = {
    id: number
    businessId: number
    name: number
    role: number
    email: number
    ownershipPercent: number
    walletAddress: number
    linkedinUrl: number
    kycVerified: number
    kycVerifiedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BusinessFounderAvgAggregateInputType = {
    ownershipPercent?: true
  }

  export type BusinessFounderSumAggregateInputType = {
    ownershipPercent?: true
  }

  export type BusinessFounderMinAggregateInputType = {
    id?: true
    businessId?: true
    name?: true
    role?: true
    email?: true
    ownershipPercent?: true
    walletAddress?: true
    linkedinUrl?: true
    kycVerified?: true
    kycVerifiedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessFounderMaxAggregateInputType = {
    id?: true
    businessId?: true
    name?: true
    role?: true
    email?: true
    ownershipPercent?: true
    walletAddress?: true
    linkedinUrl?: true
    kycVerified?: true
    kycVerifiedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessFounderCountAggregateInputType = {
    id?: true
    businessId?: true
    name?: true
    role?: true
    email?: true
    ownershipPercent?: true
    walletAddress?: true
    linkedinUrl?: true
    kycVerified?: true
    kycVerifiedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BusinessFounderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessFounder to aggregate.
     */
    where?: BusinessFounderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessFounders to fetch.
     */
    orderBy?: BusinessFounderOrderByWithRelationInput | BusinessFounderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessFounderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessFounders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessFounders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessFounders
    **/
    _count?: true | BusinessFounderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusinessFounderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusinessFounderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessFounderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessFounderMaxAggregateInputType
  }

  export type GetBusinessFounderAggregateType<T extends BusinessFounderAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessFounder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessFounder[P]>
      : GetScalarType<T[P], AggregateBusinessFounder[P]>
  }




  export type BusinessFounderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessFounderWhereInput
    orderBy?: BusinessFounderOrderByWithAggregationInput | BusinessFounderOrderByWithAggregationInput[]
    by: BusinessFounderScalarFieldEnum[] | BusinessFounderScalarFieldEnum
    having?: BusinessFounderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessFounderCountAggregateInputType | true
    _avg?: BusinessFounderAvgAggregateInputType
    _sum?: BusinessFounderSumAggregateInputType
    _min?: BusinessFounderMinAggregateInputType
    _max?: BusinessFounderMaxAggregateInputType
  }

  export type BusinessFounderGroupByOutputType = {
    id: string
    businessId: string
    name: string
    role: string
    email: string | null
    ownershipPercent: number | null
    walletAddress: string | null
    linkedinUrl: string | null
    kycVerified: boolean
    kycVerifiedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: BusinessFounderCountAggregateOutputType | null
    _avg: BusinessFounderAvgAggregateOutputType | null
    _sum: BusinessFounderSumAggregateOutputType | null
    _min: BusinessFounderMinAggregateOutputType | null
    _max: BusinessFounderMaxAggregateOutputType | null
  }

  type GetBusinessFounderGroupByPayload<T extends BusinessFounderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessFounderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessFounderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessFounderGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessFounderGroupByOutputType[P]>
        }
      >
    >


  export type BusinessFounderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    name?: boolean
    role?: boolean
    email?: boolean
    ownershipPercent?: boolean
    walletAddress?: boolean
    linkedinUrl?: boolean
    kycVerified?: boolean
    kycVerifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessFounder"]>

  export type BusinessFounderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    name?: boolean
    role?: boolean
    email?: boolean
    ownershipPercent?: boolean
    walletAddress?: boolean
    linkedinUrl?: boolean
    kycVerified?: boolean
    kycVerifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessFounder"]>

  export type BusinessFounderSelectScalar = {
    id?: boolean
    businessId?: boolean
    name?: boolean
    role?: boolean
    email?: boolean
    ownershipPercent?: boolean
    walletAddress?: boolean
    linkedinUrl?: boolean
    kycVerified?: boolean
    kycVerifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BusinessFounderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }
  export type BusinessFounderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }

  export type $BusinessFounderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessFounder"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessId: string
      name: string
      role: string
      email: string | null
      ownershipPercent: number | null
      walletAddress: string | null
      linkedinUrl: string | null
      kycVerified: boolean
      kycVerifiedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["businessFounder"]>
    composites: {}
  }

  type BusinessFounderGetPayload<S extends boolean | null | undefined | BusinessFounderDefaultArgs> = $Result.GetResult<Prisma.$BusinessFounderPayload, S>

  type BusinessFounderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BusinessFounderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BusinessFounderCountAggregateInputType | true
    }

  export interface BusinessFounderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessFounder'], meta: { name: 'BusinessFounder' } }
    /**
     * Find zero or one BusinessFounder that matches the filter.
     * @param {BusinessFounderFindUniqueArgs} args - Arguments to find a BusinessFounder
     * @example
     * // Get one BusinessFounder
     * const businessFounder = await prisma.businessFounder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessFounderFindUniqueArgs>(args: SelectSubset<T, BusinessFounderFindUniqueArgs<ExtArgs>>): Prisma__BusinessFounderClient<$Result.GetResult<Prisma.$BusinessFounderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BusinessFounder that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BusinessFounderFindUniqueOrThrowArgs} args - Arguments to find a BusinessFounder
     * @example
     * // Get one BusinessFounder
     * const businessFounder = await prisma.businessFounder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessFounderFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessFounderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessFounderClient<$Result.GetResult<Prisma.$BusinessFounderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BusinessFounder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFounderFindFirstArgs} args - Arguments to find a BusinessFounder
     * @example
     * // Get one BusinessFounder
     * const businessFounder = await prisma.businessFounder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessFounderFindFirstArgs>(args?: SelectSubset<T, BusinessFounderFindFirstArgs<ExtArgs>>): Prisma__BusinessFounderClient<$Result.GetResult<Prisma.$BusinessFounderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BusinessFounder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFounderFindFirstOrThrowArgs} args - Arguments to find a BusinessFounder
     * @example
     * // Get one BusinessFounder
     * const businessFounder = await prisma.businessFounder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessFounderFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessFounderFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessFounderClient<$Result.GetResult<Prisma.$BusinessFounderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BusinessFounders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFounderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessFounders
     * const businessFounders = await prisma.businessFounder.findMany()
     * 
     * // Get first 10 BusinessFounders
     * const businessFounders = await prisma.businessFounder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessFounderWithIdOnly = await prisma.businessFounder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessFounderFindManyArgs>(args?: SelectSubset<T, BusinessFounderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessFounderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BusinessFounder.
     * @param {BusinessFounderCreateArgs} args - Arguments to create a BusinessFounder.
     * @example
     * // Create one BusinessFounder
     * const BusinessFounder = await prisma.businessFounder.create({
     *   data: {
     *     // ... data to create a BusinessFounder
     *   }
     * })
     * 
     */
    create<T extends BusinessFounderCreateArgs>(args: SelectSubset<T, BusinessFounderCreateArgs<ExtArgs>>): Prisma__BusinessFounderClient<$Result.GetResult<Prisma.$BusinessFounderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BusinessFounders.
     * @param {BusinessFounderCreateManyArgs} args - Arguments to create many BusinessFounders.
     * @example
     * // Create many BusinessFounders
     * const businessFounder = await prisma.businessFounder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessFounderCreateManyArgs>(args?: SelectSubset<T, BusinessFounderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessFounders and returns the data saved in the database.
     * @param {BusinessFounderCreateManyAndReturnArgs} args - Arguments to create many BusinessFounders.
     * @example
     * // Create many BusinessFounders
     * const businessFounder = await prisma.businessFounder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessFounders and only return the `id`
     * const businessFounderWithIdOnly = await prisma.businessFounder.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessFounderCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessFounderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessFounderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BusinessFounder.
     * @param {BusinessFounderDeleteArgs} args - Arguments to delete one BusinessFounder.
     * @example
     * // Delete one BusinessFounder
     * const BusinessFounder = await prisma.businessFounder.delete({
     *   where: {
     *     // ... filter to delete one BusinessFounder
     *   }
     * })
     * 
     */
    delete<T extends BusinessFounderDeleteArgs>(args: SelectSubset<T, BusinessFounderDeleteArgs<ExtArgs>>): Prisma__BusinessFounderClient<$Result.GetResult<Prisma.$BusinessFounderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BusinessFounder.
     * @param {BusinessFounderUpdateArgs} args - Arguments to update one BusinessFounder.
     * @example
     * // Update one BusinessFounder
     * const businessFounder = await prisma.businessFounder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessFounderUpdateArgs>(args: SelectSubset<T, BusinessFounderUpdateArgs<ExtArgs>>): Prisma__BusinessFounderClient<$Result.GetResult<Prisma.$BusinessFounderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BusinessFounders.
     * @param {BusinessFounderDeleteManyArgs} args - Arguments to filter BusinessFounders to delete.
     * @example
     * // Delete a few BusinessFounders
     * const { count } = await prisma.businessFounder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessFounderDeleteManyArgs>(args?: SelectSubset<T, BusinessFounderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessFounders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFounderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessFounders
     * const businessFounder = await prisma.businessFounder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessFounderUpdateManyArgs>(args: SelectSubset<T, BusinessFounderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessFounder.
     * @param {BusinessFounderUpsertArgs} args - Arguments to update or create a BusinessFounder.
     * @example
     * // Update or create a BusinessFounder
     * const businessFounder = await prisma.businessFounder.upsert({
     *   create: {
     *     // ... data to create a BusinessFounder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessFounder we want to update
     *   }
     * })
     */
    upsert<T extends BusinessFounderUpsertArgs>(args: SelectSubset<T, BusinessFounderUpsertArgs<ExtArgs>>): Prisma__BusinessFounderClient<$Result.GetResult<Prisma.$BusinessFounderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BusinessFounders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFounderCountArgs} args - Arguments to filter BusinessFounders to count.
     * @example
     * // Count the number of BusinessFounders
     * const count = await prisma.businessFounder.count({
     *   where: {
     *     // ... the filter for the BusinessFounders we want to count
     *   }
     * })
    **/
    count<T extends BusinessFounderCountArgs>(
      args?: Subset<T, BusinessFounderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessFounderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessFounder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFounderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessFounderAggregateArgs>(args: Subset<T, BusinessFounderAggregateArgs>): Prisma.PrismaPromise<GetBusinessFounderAggregateType<T>>

    /**
     * Group by BusinessFounder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFounderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessFounderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessFounderGroupByArgs['orderBy'] }
        : { orderBy?: BusinessFounderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessFounderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessFounderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessFounder model
   */
  readonly fields: BusinessFounderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessFounder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessFounderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends BusinessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDefaultArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessFounder model
   */ 
  interface BusinessFounderFieldRefs {
    readonly id: FieldRef<"BusinessFounder", 'String'>
    readonly businessId: FieldRef<"BusinessFounder", 'String'>
    readonly name: FieldRef<"BusinessFounder", 'String'>
    readonly role: FieldRef<"BusinessFounder", 'String'>
    readonly email: FieldRef<"BusinessFounder", 'String'>
    readonly ownershipPercent: FieldRef<"BusinessFounder", 'Float'>
    readonly walletAddress: FieldRef<"BusinessFounder", 'String'>
    readonly linkedinUrl: FieldRef<"BusinessFounder", 'String'>
    readonly kycVerified: FieldRef<"BusinessFounder", 'Boolean'>
    readonly kycVerifiedAt: FieldRef<"BusinessFounder", 'DateTime'>
    readonly createdAt: FieldRef<"BusinessFounder", 'DateTime'>
    readonly updatedAt: FieldRef<"BusinessFounder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BusinessFounder findUnique
   */
  export type BusinessFounderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessFounder
     */
    select?: BusinessFounderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessFounderInclude<ExtArgs> | null
    /**
     * Filter, which BusinessFounder to fetch.
     */
    where: BusinessFounderWhereUniqueInput
  }

  /**
   * BusinessFounder findUniqueOrThrow
   */
  export type BusinessFounderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessFounder
     */
    select?: BusinessFounderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessFounderInclude<ExtArgs> | null
    /**
     * Filter, which BusinessFounder to fetch.
     */
    where: BusinessFounderWhereUniqueInput
  }

  /**
   * BusinessFounder findFirst
   */
  export type BusinessFounderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessFounder
     */
    select?: BusinessFounderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessFounderInclude<ExtArgs> | null
    /**
     * Filter, which BusinessFounder to fetch.
     */
    where?: BusinessFounderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessFounders to fetch.
     */
    orderBy?: BusinessFounderOrderByWithRelationInput | BusinessFounderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessFounders.
     */
    cursor?: BusinessFounderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessFounders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessFounders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessFounders.
     */
    distinct?: BusinessFounderScalarFieldEnum | BusinessFounderScalarFieldEnum[]
  }

  /**
   * BusinessFounder findFirstOrThrow
   */
  export type BusinessFounderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessFounder
     */
    select?: BusinessFounderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessFounderInclude<ExtArgs> | null
    /**
     * Filter, which BusinessFounder to fetch.
     */
    where?: BusinessFounderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessFounders to fetch.
     */
    orderBy?: BusinessFounderOrderByWithRelationInput | BusinessFounderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessFounders.
     */
    cursor?: BusinessFounderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessFounders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessFounders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessFounders.
     */
    distinct?: BusinessFounderScalarFieldEnum | BusinessFounderScalarFieldEnum[]
  }

  /**
   * BusinessFounder findMany
   */
  export type BusinessFounderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessFounder
     */
    select?: BusinessFounderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessFounderInclude<ExtArgs> | null
    /**
     * Filter, which BusinessFounders to fetch.
     */
    where?: BusinessFounderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessFounders to fetch.
     */
    orderBy?: BusinessFounderOrderByWithRelationInput | BusinessFounderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessFounders.
     */
    cursor?: BusinessFounderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessFounders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessFounders.
     */
    skip?: number
    distinct?: BusinessFounderScalarFieldEnum | BusinessFounderScalarFieldEnum[]
  }

  /**
   * BusinessFounder create
   */
  export type BusinessFounderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessFounder
     */
    select?: BusinessFounderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessFounderInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessFounder.
     */
    data: XOR<BusinessFounderCreateInput, BusinessFounderUncheckedCreateInput>
  }

  /**
   * BusinessFounder createMany
   */
  export type BusinessFounderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessFounders.
     */
    data: BusinessFounderCreateManyInput | BusinessFounderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessFounder createManyAndReturn
   */
  export type BusinessFounderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessFounder
     */
    select?: BusinessFounderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BusinessFounders.
     */
    data: BusinessFounderCreateManyInput | BusinessFounderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessFounderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessFounder update
   */
  export type BusinessFounderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessFounder
     */
    select?: BusinessFounderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessFounderInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessFounder.
     */
    data: XOR<BusinessFounderUpdateInput, BusinessFounderUncheckedUpdateInput>
    /**
     * Choose, which BusinessFounder to update.
     */
    where: BusinessFounderWhereUniqueInput
  }

  /**
   * BusinessFounder updateMany
   */
  export type BusinessFounderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessFounders.
     */
    data: XOR<BusinessFounderUpdateManyMutationInput, BusinessFounderUncheckedUpdateManyInput>
    /**
     * Filter which BusinessFounders to update
     */
    where?: BusinessFounderWhereInput
  }

  /**
   * BusinessFounder upsert
   */
  export type BusinessFounderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessFounder
     */
    select?: BusinessFounderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessFounderInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessFounder to update in case it exists.
     */
    where: BusinessFounderWhereUniqueInput
    /**
     * In case the BusinessFounder found by the `where` argument doesn't exist, create a new BusinessFounder with this data.
     */
    create: XOR<BusinessFounderCreateInput, BusinessFounderUncheckedCreateInput>
    /**
     * In case the BusinessFounder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessFounderUpdateInput, BusinessFounderUncheckedUpdateInput>
  }

  /**
   * BusinessFounder delete
   */
  export type BusinessFounderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessFounder
     */
    select?: BusinessFounderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessFounderInclude<ExtArgs> | null
    /**
     * Filter which BusinessFounder to delete.
     */
    where: BusinessFounderWhereUniqueInput
  }

  /**
   * BusinessFounder deleteMany
   */
  export type BusinessFounderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessFounders to delete
     */
    where?: BusinessFounderWhereInput
  }

  /**
   * BusinessFounder without action
   */
  export type BusinessFounderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessFounder
     */
    select?: BusinessFounderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessFounderInclude<ExtArgs> | null
  }


  /**
   * Model BusinessDocument
   */

  export type AggregateBusinessDocument = {
    _count: BusinessDocumentCountAggregateOutputType | null
    _avg: BusinessDocumentAvgAggregateOutputType | null
    _sum: BusinessDocumentSumAggregateOutputType | null
    _min: BusinessDocumentMinAggregateOutputType | null
    _max: BusinessDocumentMaxAggregateOutputType | null
  }

  export type BusinessDocumentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type BusinessDocumentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type BusinessDocumentMinAggregateOutputType = {
    id: string | null
    businessId: string | null
    name: string | null
    type: string | null
    fileUrl: string | null
    fileHash: string | null
    fileSize: number | null
    mimeType: string | null
    isPublic: boolean | null
    isVerified: boolean | null
    verifiedBy: string | null
    verifiedAt: Date | null
    uploadedAt: Date | null
  }

  export type BusinessDocumentMaxAggregateOutputType = {
    id: string | null
    businessId: string | null
    name: string | null
    type: string | null
    fileUrl: string | null
    fileHash: string | null
    fileSize: number | null
    mimeType: string | null
    isPublic: boolean | null
    isVerified: boolean | null
    verifiedBy: string | null
    verifiedAt: Date | null
    uploadedAt: Date | null
  }

  export type BusinessDocumentCountAggregateOutputType = {
    id: number
    businessId: number
    name: number
    type: number
    fileUrl: number
    fileHash: number
    fileSize: number
    mimeType: number
    isPublic: number
    isVerified: number
    verifiedBy: number
    verifiedAt: number
    uploadedAt: number
    _all: number
  }


  export type BusinessDocumentAvgAggregateInputType = {
    fileSize?: true
  }

  export type BusinessDocumentSumAggregateInputType = {
    fileSize?: true
  }

  export type BusinessDocumentMinAggregateInputType = {
    id?: true
    businessId?: true
    name?: true
    type?: true
    fileUrl?: true
    fileHash?: true
    fileSize?: true
    mimeType?: true
    isPublic?: true
    isVerified?: true
    verifiedBy?: true
    verifiedAt?: true
    uploadedAt?: true
  }

  export type BusinessDocumentMaxAggregateInputType = {
    id?: true
    businessId?: true
    name?: true
    type?: true
    fileUrl?: true
    fileHash?: true
    fileSize?: true
    mimeType?: true
    isPublic?: true
    isVerified?: true
    verifiedBy?: true
    verifiedAt?: true
    uploadedAt?: true
  }

  export type BusinessDocumentCountAggregateInputType = {
    id?: true
    businessId?: true
    name?: true
    type?: true
    fileUrl?: true
    fileHash?: true
    fileSize?: true
    mimeType?: true
    isPublic?: true
    isVerified?: true
    verifiedBy?: true
    verifiedAt?: true
    uploadedAt?: true
    _all?: true
  }

  export type BusinessDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessDocument to aggregate.
     */
    where?: BusinessDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessDocuments to fetch.
     */
    orderBy?: BusinessDocumentOrderByWithRelationInput | BusinessDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessDocuments
    **/
    _count?: true | BusinessDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusinessDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusinessDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessDocumentMaxAggregateInputType
  }

  export type GetBusinessDocumentAggregateType<T extends BusinessDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessDocument[P]>
      : GetScalarType<T[P], AggregateBusinessDocument[P]>
  }




  export type BusinessDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessDocumentWhereInput
    orderBy?: BusinessDocumentOrderByWithAggregationInput | BusinessDocumentOrderByWithAggregationInput[]
    by: BusinessDocumentScalarFieldEnum[] | BusinessDocumentScalarFieldEnum
    having?: BusinessDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessDocumentCountAggregateInputType | true
    _avg?: BusinessDocumentAvgAggregateInputType
    _sum?: BusinessDocumentSumAggregateInputType
    _min?: BusinessDocumentMinAggregateInputType
    _max?: BusinessDocumentMaxAggregateInputType
  }

  export type BusinessDocumentGroupByOutputType = {
    id: string
    businessId: string
    name: string
    type: string
    fileUrl: string
    fileHash: string | null
    fileSize: number | null
    mimeType: string | null
    isPublic: boolean
    isVerified: boolean
    verifiedBy: string | null
    verifiedAt: Date | null
    uploadedAt: Date
    _count: BusinessDocumentCountAggregateOutputType | null
    _avg: BusinessDocumentAvgAggregateOutputType | null
    _sum: BusinessDocumentSumAggregateOutputType | null
    _min: BusinessDocumentMinAggregateOutputType | null
    _max: BusinessDocumentMaxAggregateOutputType | null
  }

  type GetBusinessDocumentGroupByPayload<T extends BusinessDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessDocumentGroupByOutputType[P]>
        }
      >
    >


  export type BusinessDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    name?: boolean
    type?: boolean
    fileUrl?: boolean
    fileHash?: boolean
    fileSize?: boolean
    mimeType?: boolean
    isPublic?: boolean
    isVerified?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    uploadedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessDocument"]>

  export type BusinessDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    name?: boolean
    type?: boolean
    fileUrl?: boolean
    fileHash?: boolean
    fileSize?: boolean
    mimeType?: boolean
    isPublic?: boolean
    isVerified?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    uploadedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessDocument"]>

  export type BusinessDocumentSelectScalar = {
    id?: boolean
    businessId?: boolean
    name?: boolean
    type?: boolean
    fileUrl?: boolean
    fileHash?: boolean
    fileSize?: boolean
    mimeType?: boolean
    isPublic?: boolean
    isVerified?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    uploadedAt?: boolean
  }

  export type BusinessDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }
  export type BusinessDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }

  export type $BusinessDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessDocument"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessId: string
      name: string
      type: string
      fileUrl: string
      fileHash: string | null
      fileSize: number | null
      mimeType: string | null
      isPublic: boolean
      isVerified: boolean
      verifiedBy: string | null
      verifiedAt: Date | null
      uploadedAt: Date
    }, ExtArgs["result"]["businessDocument"]>
    composites: {}
  }

  type BusinessDocumentGetPayload<S extends boolean | null | undefined | BusinessDocumentDefaultArgs> = $Result.GetResult<Prisma.$BusinessDocumentPayload, S>

  type BusinessDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BusinessDocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BusinessDocumentCountAggregateInputType | true
    }

  export interface BusinessDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessDocument'], meta: { name: 'BusinessDocument' } }
    /**
     * Find zero or one BusinessDocument that matches the filter.
     * @param {BusinessDocumentFindUniqueArgs} args - Arguments to find a BusinessDocument
     * @example
     * // Get one BusinessDocument
     * const businessDocument = await prisma.businessDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessDocumentFindUniqueArgs>(args: SelectSubset<T, BusinessDocumentFindUniqueArgs<ExtArgs>>): Prisma__BusinessDocumentClient<$Result.GetResult<Prisma.$BusinessDocumentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BusinessDocument that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BusinessDocumentFindUniqueOrThrowArgs} args - Arguments to find a BusinessDocument
     * @example
     * // Get one BusinessDocument
     * const businessDocument = await prisma.businessDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessDocumentClient<$Result.GetResult<Prisma.$BusinessDocumentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BusinessDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessDocumentFindFirstArgs} args - Arguments to find a BusinessDocument
     * @example
     * // Get one BusinessDocument
     * const businessDocument = await prisma.businessDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessDocumentFindFirstArgs>(args?: SelectSubset<T, BusinessDocumentFindFirstArgs<ExtArgs>>): Prisma__BusinessDocumentClient<$Result.GetResult<Prisma.$BusinessDocumentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BusinessDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessDocumentFindFirstOrThrowArgs} args - Arguments to find a BusinessDocument
     * @example
     * // Get one BusinessDocument
     * const businessDocument = await prisma.businessDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessDocumentClient<$Result.GetResult<Prisma.$BusinessDocumentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BusinessDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessDocuments
     * const businessDocuments = await prisma.businessDocument.findMany()
     * 
     * // Get first 10 BusinessDocuments
     * const businessDocuments = await prisma.businessDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessDocumentWithIdOnly = await prisma.businessDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessDocumentFindManyArgs>(args?: SelectSubset<T, BusinessDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessDocumentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BusinessDocument.
     * @param {BusinessDocumentCreateArgs} args - Arguments to create a BusinessDocument.
     * @example
     * // Create one BusinessDocument
     * const BusinessDocument = await prisma.businessDocument.create({
     *   data: {
     *     // ... data to create a BusinessDocument
     *   }
     * })
     * 
     */
    create<T extends BusinessDocumentCreateArgs>(args: SelectSubset<T, BusinessDocumentCreateArgs<ExtArgs>>): Prisma__BusinessDocumentClient<$Result.GetResult<Prisma.$BusinessDocumentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BusinessDocuments.
     * @param {BusinessDocumentCreateManyArgs} args - Arguments to create many BusinessDocuments.
     * @example
     * // Create many BusinessDocuments
     * const businessDocument = await prisma.businessDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessDocumentCreateManyArgs>(args?: SelectSubset<T, BusinessDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessDocuments and returns the data saved in the database.
     * @param {BusinessDocumentCreateManyAndReturnArgs} args - Arguments to create many BusinessDocuments.
     * @example
     * // Create many BusinessDocuments
     * const businessDocument = await prisma.businessDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessDocuments and only return the `id`
     * const businessDocumentWithIdOnly = await prisma.businessDocument.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessDocumentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BusinessDocument.
     * @param {BusinessDocumentDeleteArgs} args - Arguments to delete one BusinessDocument.
     * @example
     * // Delete one BusinessDocument
     * const BusinessDocument = await prisma.businessDocument.delete({
     *   where: {
     *     // ... filter to delete one BusinessDocument
     *   }
     * })
     * 
     */
    delete<T extends BusinessDocumentDeleteArgs>(args: SelectSubset<T, BusinessDocumentDeleteArgs<ExtArgs>>): Prisma__BusinessDocumentClient<$Result.GetResult<Prisma.$BusinessDocumentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BusinessDocument.
     * @param {BusinessDocumentUpdateArgs} args - Arguments to update one BusinessDocument.
     * @example
     * // Update one BusinessDocument
     * const businessDocument = await prisma.businessDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessDocumentUpdateArgs>(args: SelectSubset<T, BusinessDocumentUpdateArgs<ExtArgs>>): Prisma__BusinessDocumentClient<$Result.GetResult<Prisma.$BusinessDocumentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BusinessDocuments.
     * @param {BusinessDocumentDeleteManyArgs} args - Arguments to filter BusinessDocuments to delete.
     * @example
     * // Delete a few BusinessDocuments
     * const { count } = await prisma.businessDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessDocumentDeleteManyArgs>(args?: SelectSubset<T, BusinessDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessDocuments
     * const businessDocument = await prisma.businessDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessDocumentUpdateManyArgs>(args: SelectSubset<T, BusinessDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusinessDocument.
     * @param {BusinessDocumentUpsertArgs} args - Arguments to update or create a BusinessDocument.
     * @example
     * // Update or create a BusinessDocument
     * const businessDocument = await prisma.businessDocument.upsert({
     *   create: {
     *     // ... data to create a BusinessDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessDocument we want to update
     *   }
     * })
     */
    upsert<T extends BusinessDocumentUpsertArgs>(args: SelectSubset<T, BusinessDocumentUpsertArgs<ExtArgs>>): Prisma__BusinessDocumentClient<$Result.GetResult<Prisma.$BusinessDocumentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BusinessDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessDocumentCountArgs} args - Arguments to filter BusinessDocuments to count.
     * @example
     * // Count the number of BusinessDocuments
     * const count = await prisma.businessDocument.count({
     *   where: {
     *     // ... the filter for the BusinessDocuments we want to count
     *   }
     * })
    **/
    count<T extends BusinessDocumentCountArgs>(
      args?: Subset<T, BusinessDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessDocumentAggregateArgs>(args: Subset<T, BusinessDocumentAggregateArgs>): Prisma.PrismaPromise<GetBusinessDocumentAggregateType<T>>

    /**
     * Group by BusinessDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessDocumentGroupByArgs['orderBy'] }
        : { orderBy?: BusinessDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessDocument model
   */
  readonly fields: BusinessDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends BusinessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDefaultArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessDocument model
   */ 
  interface BusinessDocumentFieldRefs {
    readonly id: FieldRef<"BusinessDocument", 'String'>
    readonly businessId: FieldRef<"BusinessDocument", 'String'>
    readonly name: FieldRef<"BusinessDocument", 'String'>
    readonly type: FieldRef<"BusinessDocument", 'String'>
    readonly fileUrl: FieldRef<"BusinessDocument", 'String'>
    readonly fileHash: FieldRef<"BusinessDocument", 'String'>
    readonly fileSize: FieldRef<"BusinessDocument", 'Int'>
    readonly mimeType: FieldRef<"BusinessDocument", 'String'>
    readonly isPublic: FieldRef<"BusinessDocument", 'Boolean'>
    readonly isVerified: FieldRef<"BusinessDocument", 'Boolean'>
    readonly verifiedBy: FieldRef<"BusinessDocument", 'String'>
    readonly verifiedAt: FieldRef<"BusinessDocument", 'DateTime'>
    readonly uploadedAt: FieldRef<"BusinessDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BusinessDocument findUnique
   */
  export type BusinessDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDocument
     */
    select?: BusinessDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessDocumentInclude<ExtArgs> | null
    /**
     * Filter, which BusinessDocument to fetch.
     */
    where: BusinessDocumentWhereUniqueInput
  }

  /**
   * BusinessDocument findUniqueOrThrow
   */
  export type BusinessDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDocument
     */
    select?: BusinessDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessDocumentInclude<ExtArgs> | null
    /**
     * Filter, which BusinessDocument to fetch.
     */
    where: BusinessDocumentWhereUniqueInput
  }

  /**
   * BusinessDocument findFirst
   */
  export type BusinessDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDocument
     */
    select?: BusinessDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessDocumentInclude<ExtArgs> | null
    /**
     * Filter, which BusinessDocument to fetch.
     */
    where?: BusinessDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessDocuments to fetch.
     */
    orderBy?: BusinessDocumentOrderByWithRelationInput | BusinessDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessDocuments.
     */
    cursor?: BusinessDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessDocuments.
     */
    distinct?: BusinessDocumentScalarFieldEnum | BusinessDocumentScalarFieldEnum[]
  }

  /**
   * BusinessDocument findFirstOrThrow
   */
  export type BusinessDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDocument
     */
    select?: BusinessDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessDocumentInclude<ExtArgs> | null
    /**
     * Filter, which BusinessDocument to fetch.
     */
    where?: BusinessDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessDocuments to fetch.
     */
    orderBy?: BusinessDocumentOrderByWithRelationInput | BusinessDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessDocuments.
     */
    cursor?: BusinessDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessDocuments.
     */
    distinct?: BusinessDocumentScalarFieldEnum | BusinessDocumentScalarFieldEnum[]
  }

  /**
   * BusinessDocument findMany
   */
  export type BusinessDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDocument
     */
    select?: BusinessDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessDocumentInclude<ExtArgs> | null
    /**
     * Filter, which BusinessDocuments to fetch.
     */
    where?: BusinessDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessDocuments to fetch.
     */
    orderBy?: BusinessDocumentOrderByWithRelationInput | BusinessDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessDocuments.
     */
    cursor?: BusinessDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessDocuments.
     */
    skip?: number
    distinct?: BusinessDocumentScalarFieldEnum | BusinessDocumentScalarFieldEnum[]
  }

  /**
   * BusinessDocument create
   */
  export type BusinessDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDocument
     */
    select?: BusinessDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessDocument.
     */
    data: XOR<BusinessDocumentCreateInput, BusinessDocumentUncheckedCreateInput>
  }

  /**
   * BusinessDocument createMany
   */
  export type BusinessDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessDocuments.
     */
    data: BusinessDocumentCreateManyInput | BusinessDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessDocument createManyAndReturn
   */
  export type BusinessDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDocument
     */
    select?: BusinessDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BusinessDocuments.
     */
    data: BusinessDocumentCreateManyInput | BusinessDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessDocument update
   */
  export type BusinessDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDocument
     */
    select?: BusinessDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessDocument.
     */
    data: XOR<BusinessDocumentUpdateInput, BusinessDocumentUncheckedUpdateInput>
    /**
     * Choose, which BusinessDocument to update.
     */
    where: BusinessDocumentWhereUniqueInput
  }

  /**
   * BusinessDocument updateMany
   */
  export type BusinessDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessDocuments.
     */
    data: XOR<BusinessDocumentUpdateManyMutationInput, BusinessDocumentUncheckedUpdateManyInput>
    /**
     * Filter which BusinessDocuments to update
     */
    where?: BusinessDocumentWhereInput
  }

  /**
   * BusinessDocument upsert
   */
  export type BusinessDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDocument
     */
    select?: BusinessDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessDocument to update in case it exists.
     */
    where: BusinessDocumentWhereUniqueInput
    /**
     * In case the BusinessDocument found by the `where` argument doesn't exist, create a new BusinessDocument with this data.
     */
    create: XOR<BusinessDocumentCreateInput, BusinessDocumentUncheckedCreateInput>
    /**
     * In case the BusinessDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessDocumentUpdateInput, BusinessDocumentUncheckedUpdateInput>
  }

  /**
   * BusinessDocument delete
   */
  export type BusinessDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDocument
     */
    select?: BusinessDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessDocumentInclude<ExtArgs> | null
    /**
     * Filter which BusinessDocument to delete.
     */
    where: BusinessDocumentWhereUniqueInput
  }

  /**
   * BusinessDocument deleteMany
   */
  export type BusinessDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessDocuments to delete
     */
    where?: BusinessDocumentWhereInput
  }

  /**
   * BusinessDocument without action
   */
  export type BusinessDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessDocument
     */
    select?: BusinessDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessDocumentInclude<ExtArgs> | null
  }


  /**
   * Model RevenueReport
   */

  export type AggregateRevenueReport = {
    _count: RevenueReportCountAggregateOutputType | null
    _min: RevenueReportMinAggregateOutputType | null
    _max: RevenueReportMaxAggregateOutputType | null
  }

  export type RevenueReportMinAggregateOutputType = {
    id: string | null
    businessId: string | null
    period: string | null
    periodStart: Date | null
    periodEnd: Date | null
    grossRevenue: string | null
    eligibleRevenue: string | null
    distributionAmount: string | null
    documentUrl: string | null
    documentHash: string | null
    isVerified: boolean | null
    verifiedBy: string | null
    verifiedAt: Date | null
    submittedAt: Date | null
  }

  export type RevenueReportMaxAggregateOutputType = {
    id: string | null
    businessId: string | null
    period: string | null
    periodStart: Date | null
    periodEnd: Date | null
    grossRevenue: string | null
    eligibleRevenue: string | null
    distributionAmount: string | null
    documentUrl: string | null
    documentHash: string | null
    isVerified: boolean | null
    verifiedBy: string | null
    verifiedAt: Date | null
    submittedAt: Date | null
  }

  export type RevenueReportCountAggregateOutputType = {
    id: number
    businessId: number
    period: number
    periodStart: number
    periodEnd: number
    grossRevenue: number
    eligibleRevenue: number
    distributionAmount: number
    documentUrl: number
    documentHash: number
    isVerified: number
    verifiedBy: number
    verifiedAt: number
    submittedAt: number
    _all: number
  }


  export type RevenueReportMinAggregateInputType = {
    id?: true
    businessId?: true
    period?: true
    periodStart?: true
    periodEnd?: true
    grossRevenue?: true
    eligibleRevenue?: true
    distributionAmount?: true
    documentUrl?: true
    documentHash?: true
    isVerified?: true
    verifiedBy?: true
    verifiedAt?: true
    submittedAt?: true
  }

  export type RevenueReportMaxAggregateInputType = {
    id?: true
    businessId?: true
    period?: true
    periodStart?: true
    periodEnd?: true
    grossRevenue?: true
    eligibleRevenue?: true
    distributionAmount?: true
    documentUrl?: true
    documentHash?: true
    isVerified?: true
    verifiedBy?: true
    verifiedAt?: true
    submittedAt?: true
  }

  export type RevenueReportCountAggregateInputType = {
    id?: true
    businessId?: true
    period?: true
    periodStart?: true
    periodEnd?: true
    grossRevenue?: true
    eligibleRevenue?: true
    distributionAmount?: true
    documentUrl?: true
    documentHash?: true
    isVerified?: true
    verifiedBy?: true
    verifiedAt?: true
    submittedAt?: true
    _all?: true
  }

  export type RevenueReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RevenueReport to aggregate.
     */
    where?: RevenueReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevenueReports to fetch.
     */
    orderBy?: RevenueReportOrderByWithRelationInput | RevenueReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RevenueReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevenueReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevenueReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RevenueReports
    **/
    _count?: true | RevenueReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RevenueReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RevenueReportMaxAggregateInputType
  }

  export type GetRevenueReportAggregateType<T extends RevenueReportAggregateArgs> = {
        [P in keyof T & keyof AggregateRevenueReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRevenueReport[P]>
      : GetScalarType<T[P], AggregateRevenueReport[P]>
  }




  export type RevenueReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RevenueReportWhereInput
    orderBy?: RevenueReportOrderByWithAggregationInput | RevenueReportOrderByWithAggregationInput[]
    by: RevenueReportScalarFieldEnum[] | RevenueReportScalarFieldEnum
    having?: RevenueReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RevenueReportCountAggregateInputType | true
    _min?: RevenueReportMinAggregateInputType
    _max?: RevenueReportMaxAggregateInputType
  }

  export type RevenueReportGroupByOutputType = {
    id: string
    businessId: string
    period: string
    periodStart: Date
    periodEnd: Date
    grossRevenue: string
    eligibleRevenue: string | null
    distributionAmount: string | null
    documentUrl: string | null
    documentHash: string | null
    isVerified: boolean
    verifiedBy: string | null
    verifiedAt: Date | null
    submittedAt: Date
    _count: RevenueReportCountAggregateOutputType | null
    _min: RevenueReportMinAggregateOutputType | null
    _max: RevenueReportMaxAggregateOutputType | null
  }

  type GetRevenueReportGroupByPayload<T extends RevenueReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RevenueReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RevenueReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RevenueReportGroupByOutputType[P]>
            : GetScalarType<T[P], RevenueReportGroupByOutputType[P]>
        }
      >
    >


  export type RevenueReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    grossRevenue?: boolean
    eligibleRevenue?: boolean
    distributionAmount?: boolean
    documentUrl?: boolean
    documentHash?: boolean
    isVerified?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    submittedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["revenueReport"]>

  export type RevenueReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    grossRevenue?: boolean
    eligibleRevenue?: boolean
    distributionAmount?: boolean
    documentUrl?: boolean
    documentHash?: boolean
    isVerified?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    submittedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["revenueReport"]>

  export type RevenueReportSelectScalar = {
    id?: boolean
    businessId?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    grossRevenue?: boolean
    eligibleRevenue?: boolean
    distributionAmount?: boolean
    documentUrl?: boolean
    documentHash?: boolean
    isVerified?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    submittedAt?: boolean
  }

  export type RevenueReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }
  export type RevenueReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }

  export type $RevenueReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RevenueReport"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessId: string
      period: string
      periodStart: Date
      periodEnd: Date
      grossRevenue: string
      eligibleRevenue: string | null
      distributionAmount: string | null
      documentUrl: string | null
      documentHash: string | null
      isVerified: boolean
      verifiedBy: string | null
      verifiedAt: Date | null
      submittedAt: Date
    }, ExtArgs["result"]["revenueReport"]>
    composites: {}
  }

  type RevenueReportGetPayload<S extends boolean | null | undefined | RevenueReportDefaultArgs> = $Result.GetResult<Prisma.$RevenueReportPayload, S>

  type RevenueReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RevenueReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RevenueReportCountAggregateInputType | true
    }

  export interface RevenueReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RevenueReport'], meta: { name: 'RevenueReport' } }
    /**
     * Find zero or one RevenueReport that matches the filter.
     * @param {RevenueReportFindUniqueArgs} args - Arguments to find a RevenueReport
     * @example
     * // Get one RevenueReport
     * const revenueReport = await prisma.revenueReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RevenueReportFindUniqueArgs>(args: SelectSubset<T, RevenueReportFindUniqueArgs<ExtArgs>>): Prisma__RevenueReportClient<$Result.GetResult<Prisma.$RevenueReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RevenueReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RevenueReportFindUniqueOrThrowArgs} args - Arguments to find a RevenueReport
     * @example
     * // Get one RevenueReport
     * const revenueReport = await prisma.revenueReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RevenueReportFindUniqueOrThrowArgs>(args: SelectSubset<T, RevenueReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RevenueReportClient<$Result.GetResult<Prisma.$RevenueReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RevenueReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueReportFindFirstArgs} args - Arguments to find a RevenueReport
     * @example
     * // Get one RevenueReport
     * const revenueReport = await prisma.revenueReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RevenueReportFindFirstArgs>(args?: SelectSubset<T, RevenueReportFindFirstArgs<ExtArgs>>): Prisma__RevenueReportClient<$Result.GetResult<Prisma.$RevenueReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RevenueReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueReportFindFirstOrThrowArgs} args - Arguments to find a RevenueReport
     * @example
     * // Get one RevenueReport
     * const revenueReport = await prisma.revenueReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RevenueReportFindFirstOrThrowArgs>(args?: SelectSubset<T, RevenueReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__RevenueReportClient<$Result.GetResult<Prisma.$RevenueReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RevenueReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RevenueReports
     * const revenueReports = await prisma.revenueReport.findMany()
     * 
     * // Get first 10 RevenueReports
     * const revenueReports = await prisma.revenueReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const revenueReportWithIdOnly = await prisma.revenueReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RevenueReportFindManyArgs>(args?: SelectSubset<T, RevenueReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevenueReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RevenueReport.
     * @param {RevenueReportCreateArgs} args - Arguments to create a RevenueReport.
     * @example
     * // Create one RevenueReport
     * const RevenueReport = await prisma.revenueReport.create({
     *   data: {
     *     // ... data to create a RevenueReport
     *   }
     * })
     * 
     */
    create<T extends RevenueReportCreateArgs>(args: SelectSubset<T, RevenueReportCreateArgs<ExtArgs>>): Prisma__RevenueReportClient<$Result.GetResult<Prisma.$RevenueReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RevenueReports.
     * @param {RevenueReportCreateManyArgs} args - Arguments to create many RevenueReports.
     * @example
     * // Create many RevenueReports
     * const revenueReport = await prisma.revenueReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RevenueReportCreateManyArgs>(args?: SelectSubset<T, RevenueReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RevenueReports and returns the data saved in the database.
     * @param {RevenueReportCreateManyAndReturnArgs} args - Arguments to create many RevenueReports.
     * @example
     * // Create many RevenueReports
     * const revenueReport = await prisma.revenueReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RevenueReports and only return the `id`
     * const revenueReportWithIdOnly = await prisma.revenueReport.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RevenueReportCreateManyAndReturnArgs>(args?: SelectSubset<T, RevenueReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevenueReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RevenueReport.
     * @param {RevenueReportDeleteArgs} args - Arguments to delete one RevenueReport.
     * @example
     * // Delete one RevenueReport
     * const RevenueReport = await prisma.revenueReport.delete({
     *   where: {
     *     // ... filter to delete one RevenueReport
     *   }
     * })
     * 
     */
    delete<T extends RevenueReportDeleteArgs>(args: SelectSubset<T, RevenueReportDeleteArgs<ExtArgs>>): Prisma__RevenueReportClient<$Result.GetResult<Prisma.$RevenueReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RevenueReport.
     * @param {RevenueReportUpdateArgs} args - Arguments to update one RevenueReport.
     * @example
     * // Update one RevenueReport
     * const revenueReport = await prisma.revenueReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RevenueReportUpdateArgs>(args: SelectSubset<T, RevenueReportUpdateArgs<ExtArgs>>): Prisma__RevenueReportClient<$Result.GetResult<Prisma.$RevenueReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RevenueReports.
     * @param {RevenueReportDeleteManyArgs} args - Arguments to filter RevenueReports to delete.
     * @example
     * // Delete a few RevenueReports
     * const { count } = await prisma.revenueReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RevenueReportDeleteManyArgs>(args?: SelectSubset<T, RevenueReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RevenueReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RevenueReports
     * const revenueReport = await prisma.revenueReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RevenueReportUpdateManyArgs>(args: SelectSubset<T, RevenueReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RevenueReport.
     * @param {RevenueReportUpsertArgs} args - Arguments to update or create a RevenueReport.
     * @example
     * // Update or create a RevenueReport
     * const revenueReport = await prisma.revenueReport.upsert({
     *   create: {
     *     // ... data to create a RevenueReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RevenueReport we want to update
     *   }
     * })
     */
    upsert<T extends RevenueReportUpsertArgs>(args: SelectSubset<T, RevenueReportUpsertArgs<ExtArgs>>): Prisma__RevenueReportClient<$Result.GetResult<Prisma.$RevenueReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RevenueReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueReportCountArgs} args - Arguments to filter RevenueReports to count.
     * @example
     * // Count the number of RevenueReports
     * const count = await prisma.revenueReport.count({
     *   where: {
     *     // ... the filter for the RevenueReports we want to count
     *   }
     * })
    **/
    count<T extends RevenueReportCountArgs>(
      args?: Subset<T, RevenueReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RevenueReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RevenueReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RevenueReportAggregateArgs>(args: Subset<T, RevenueReportAggregateArgs>): Prisma.PrismaPromise<GetRevenueReportAggregateType<T>>

    /**
     * Group by RevenueReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RevenueReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RevenueReportGroupByArgs['orderBy'] }
        : { orderBy?: RevenueReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RevenueReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRevenueReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RevenueReport model
   */
  readonly fields: RevenueReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RevenueReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RevenueReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends BusinessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDefaultArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RevenueReport model
   */ 
  interface RevenueReportFieldRefs {
    readonly id: FieldRef<"RevenueReport", 'String'>
    readonly businessId: FieldRef<"RevenueReport", 'String'>
    readonly period: FieldRef<"RevenueReport", 'String'>
    readonly periodStart: FieldRef<"RevenueReport", 'DateTime'>
    readonly periodEnd: FieldRef<"RevenueReport", 'DateTime'>
    readonly grossRevenue: FieldRef<"RevenueReport", 'String'>
    readonly eligibleRevenue: FieldRef<"RevenueReport", 'String'>
    readonly distributionAmount: FieldRef<"RevenueReport", 'String'>
    readonly documentUrl: FieldRef<"RevenueReport", 'String'>
    readonly documentHash: FieldRef<"RevenueReport", 'String'>
    readonly isVerified: FieldRef<"RevenueReport", 'Boolean'>
    readonly verifiedBy: FieldRef<"RevenueReport", 'String'>
    readonly verifiedAt: FieldRef<"RevenueReport", 'DateTime'>
    readonly submittedAt: FieldRef<"RevenueReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RevenueReport findUnique
   */
  export type RevenueReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueReport
     */
    select?: RevenueReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueReportInclude<ExtArgs> | null
    /**
     * Filter, which RevenueReport to fetch.
     */
    where: RevenueReportWhereUniqueInput
  }

  /**
   * RevenueReport findUniqueOrThrow
   */
  export type RevenueReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueReport
     */
    select?: RevenueReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueReportInclude<ExtArgs> | null
    /**
     * Filter, which RevenueReport to fetch.
     */
    where: RevenueReportWhereUniqueInput
  }

  /**
   * RevenueReport findFirst
   */
  export type RevenueReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueReport
     */
    select?: RevenueReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueReportInclude<ExtArgs> | null
    /**
     * Filter, which RevenueReport to fetch.
     */
    where?: RevenueReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevenueReports to fetch.
     */
    orderBy?: RevenueReportOrderByWithRelationInput | RevenueReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RevenueReports.
     */
    cursor?: RevenueReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevenueReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevenueReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RevenueReports.
     */
    distinct?: RevenueReportScalarFieldEnum | RevenueReportScalarFieldEnum[]
  }

  /**
   * RevenueReport findFirstOrThrow
   */
  export type RevenueReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueReport
     */
    select?: RevenueReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueReportInclude<ExtArgs> | null
    /**
     * Filter, which RevenueReport to fetch.
     */
    where?: RevenueReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevenueReports to fetch.
     */
    orderBy?: RevenueReportOrderByWithRelationInput | RevenueReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RevenueReports.
     */
    cursor?: RevenueReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevenueReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevenueReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RevenueReports.
     */
    distinct?: RevenueReportScalarFieldEnum | RevenueReportScalarFieldEnum[]
  }

  /**
   * RevenueReport findMany
   */
  export type RevenueReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueReport
     */
    select?: RevenueReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueReportInclude<ExtArgs> | null
    /**
     * Filter, which RevenueReports to fetch.
     */
    where?: RevenueReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevenueReports to fetch.
     */
    orderBy?: RevenueReportOrderByWithRelationInput | RevenueReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RevenueReports.
     */
    cursor?: RevenueReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevenueReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevenueReports.
     */
    skip?: number
    distinct?: RevenueReportScalarFieldEnum | RevenueReportScalarFieldEnum[]
  }

  /**
   * RevenueReport create
   */
  export type RevenueReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueReport
     */
    select?: RevenueReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueReportInclude<ExtArgs> | null
    /**
     * The data needed to create a RevenueReport.
     */
    data: XOR<RevenueReportCreateInput, RevenueReportUncheckedCreateInput>
  }

  /**
   * RevenueReport createMany
   */
  export type RevenueReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RevenueReports.
     */
    data: RevenueReportCreateManyInput | RevenueReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RevenueReport createManyAndReturn
   */
  export type RevenueReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueReport
     */
    select?: RevenueReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RevenueReports.
     */
    data: RevenueReportCreateManyInput | RevenueReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RevenueReport update
   */
  export type RevenueReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueReport
     */
    select?: RevenueReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueReportInclude<ExtArgs> | null
    /**
     * The data needed to update a RevenueReport.
     */
    data: XOR<RevenueReportUpdateInput, RevenueReportUncheckedUpdateInput>
    /**
     * Choose, which RevenueReport to update.
     */
    where: RevenueReportWhereUniqueInput
  }

  /**
   * RevenueReport updateMany
   */
  export type RevenueReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RevenueReports.
     */
    data: XOR<RevenueReportUpdateManyMutationInput, RevenueReportUncheckedUpdateManyInput>
    /**
     * Filter which RevenueReports to update
     */
    where?: RevenueReportWhereInput
  }

  /**
   * RevenueReport upsert
   */
  export type RevenueReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueReport
     */
    select?: RevenueReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueReportInclude<ExtArgs> | null
    /**
     * The filter to search for the RevenueReport to update in case it exists.
     */
    where: RevenueReportWhereUniqueInput
    /**
     * In case the RevenueReport found by the `where` argument doesn't exist, create a new RevenueReport with this data.
     */
    create: XOR<RevenueReportCreateInput, RevenueReportUncheckedCreateInput>
    /**
     * In case the RevenueReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RevenueReportUpdateInput, RevenueReportUncheckedUpdateInput>
  }

  /**
   * RevenueReport delete
   */
  export type RevenueReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueReport
     */
    select?: RevenueReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueReportInclude<ExtArgs> | null
    /**
     * Filter which RevenueReport to delete.
     */
    where: RevenueReportWhereUniqueInput
  }

  /**
   * RevenueReport deleteMany
   */
  export type RevenueReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RevenueReports to delete
     */
    where?: RevenueReportWhereInput
  }

  /**
   * RevenueReport without action
   */
  export type RevenueReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueReport
     */
    select?: RevenueReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RevenueReportInclude<ExtArgs> | null
  }


  /**
   * Model PrivateIdentityVerification
   */

  export type AggregatePrivateIdentityVerification = {
    _count: PrivateIdentityVerificationCountAggregateOutputType | null
    _avg: PrivateIdentityVerificationAvgAggregateOutputType | null
    _sum: PrivateIdentityVerificationSumAggregateOutputType | null
    _min: PrivateIdentityVerificationMinAggregateOutputType | null
    _max: PrivateIdentityVerificationMaxAggregateOutputType | null
  }

  export type PrivateIdentityVerificationAvgAggregateOutputType = {
    retryCount: number | null
  }

  export type PrivateIdentityVerificationSumAggregateOutputType = {
    retryCount: number | null
  }

  export type PrivateIdentityVerificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.IdentityStatus | null
    level: string | null
    provider: string | null
    providerSessionId: string | null
    providerStatus: string | null
    verifiedAt: Date | null
    expiresAt: Date | null
    rejectionReason: string | null
    retryCount: number | null
    lastAttemptAt: Date | null
    isAccredited: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PrivateIdentityVerificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.IdentityStatus | null
    level: string | null
    provider: string | null
    providerSessionId: string | null
    providerStatus: string | null
    verifiedAt: Date | null
    expiresAt: Date | null
    rejectionReason: string | null
    retryCount: number | null
    lastAttemptAt: Date | null
    isAccredited: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PrivateIdentityVerificationCountAggregateOutputType = {
    id: number
    userId: number
    status: number
    level: number
    provider: number
    providerSessionId: number
    providerStatus: number
    verifiedAt: number
    expiresAt: number
    rejectionReason: number
    retryCount: number
    lastAttemptAt: number
    isAccredited: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PrivateIdentityVerificationAvgAggregateInputType = {
    retryCount?: true
  }

  export type PrivateIdentityVerificationSumAggregateInputType = {
    retryCount?: true
  }

  export type PrivateIdentityVerificationMinAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    level?: true
    provider?: true
    providerSessionId?: true
    providerStatus?: true
    verifiedAt?: true
    expiresAt?: true
    rejectionReason?: true
    retryCount?: true
    lastAttemptAt?: true
    isAccredited?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PrivateIdentityVerificationMaxAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    level?: true
    provider?: true
    providerSessionId?: true
    providerStatus?: true
    verifiedAt?: true
    expiresAt?: true
    rejectionReason?: true
    retryCount?: true
    lastAttemptAt?: true
    isAccredited?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PrivateIdentityVerificationCountAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    level?: true
    provider?: true
    providerSessionId?: true
    providerStatus?: true
    verifiedAt?: true
    expiresAt?: true
    rejectionReason?: true
    retryCount?: true
    lastAttemptAt?: true
    isAccredited?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PrivateIdentityVerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrivateIdentityVerification to aggregate.
     */
    where?: PrivateIdentityVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateIdentityVerifications to fetch.
     */
    orderBy?: PrivateIdentityVerificationOrderByWithRelationInput | PrivateIdentityVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrivateIdentityVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateIdentityVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateIdentityVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrivateIdentityVerifications
    **/
    _count?: true | PrivateIdentityVerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrivateIdentityVerificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrivateIdentityVerificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrivateIdentityVerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrivateIdentityVerificationMaxAggregateInputType
  }

  export type GetPrivateIdentityVerificationAggregateType<T extends PrivateIdentityVerificationAggregateArgs> = {
        [P in keyof T & keyof AggregatePrivateIdentityVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrivateIdentityVerification[P]>
      : GetScalarType<T[P], AggregatePrivateIdentityVerification[P]>
  }




  export type PrivateIdentityVerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrivateIdentityVerificationWhereInput
    orderBy?: PrivateIdentityVerificationOrderByWithAggregationInput | PrivateIdentityVerificationOrderByWithAggregationInput[]
    by: PrivateIdentityVerificationScalarFieldEnum[] | PrivateIdentityVerificationScalarFieldEnum
    having?: PrivateIdentityVerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrivateIdentityVerificationCountAggregateInputType | true
    _avg?: PrivateIdentityVerificationAvgAggregateInputType
    _sum?: PrivateIdentityVerificationSumAggregateInputType
    _min?: PrivateIdentityVerificationMinAggregateInputType
    _max?: PrivateIdentityVerificationMaxAggregateInputType
  }

  export type PrivateIdentityVerificationGroupByOutputType = {
    id: string
    userId: string
    status: $Enums.IdentityStatus
    level: string | null
    provider: string | null
    providerSessionId: string | null
    providerStatus: string | null
    verifiedAt: Date | null
    expiresAt: Date | null
    rejectionReason: string | null
    retryCount: number
    lastAttemptAt: Date | null
    isAccredited: boolean
    createdAt: Date
    updatedAt: Date
    _count: PrivateIdentityVerificationCountAggregateOutputType | null
    _avg: PrivateIdentityVerificationAvgAggregateOutputType | null
    _sum: PrivateIdentityVerificationSumAggregateOutputType | null
    _min: PrivateIdentityVerificationMinAggregateOutputType | null
    _max: PrivateIdentityVerificationMaxAggregateOutputType | null
  }

  type GetPrivateIdentityVerificationGroupByPayload<T extends PrivateIdentityVerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrivateIdentityVerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrivateIdentityVerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrivateIdentityVerificationGroupByOutputType[P]>
            : GetScalarType<T[P], PrivateIdentityVerificationGroupByOutputType[P]>
        }
      >
    >


  export type PrivateIdentityVerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    level?: boolean
    provider?: boolean
    providerSessionId?: boolean
    providerStatus?: boolean
    verifiedAt?: boolean
    expiresAt?: boolean
    rejectionReason?: boolean
    retryCount?: boolean
    lastAttemptAt?: boolean
    isAccredited?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["privateIdentityVerification"]>

  export type PrivateIdentityVerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    level?: boolean
    provider?: boolean
    providerSessionId?: boolean
    providerStatus?: boolean
    verifiedAt?: boolean
    expiresAt?: boolean
    rejectionReason?: boolean
    retryCount?: boolean
    lastAttemptAt?: boolean
    isAccredited?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["privateIdentityVerification"]>

  export type PrivateIdentityVerificationSelectScalar = {
    id?: boolean
    userId?: boolean
    status?: boolean
    level?: boolean
    provider?: boolean
    providerSessionId?: boolean
    providerStatus?: boolean
    verifiedAt?: boolean
    expiresAt?: boolean
    rejectionReason?: boolean
    retryCount?: boolean
    lastAttemptAt?: boolean
    isAccredited?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PrivateIdentityVerificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PrivateIdentityVerificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PrivateIdentityVerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrivateIdentityVerification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      status: $Enums.IdentityStatus
      level: string | null
      provider: string | null
      providerSessionId: string | null
      providerStatus: string | null
      verifiedAt: Date | null
      expiresAt: Date | null
      rejectionReason: string | null
      retryCount: number
      lastAttemptAt: Date | null
      isAccredited: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["privateIdentityVerification"]>
    composites: {}
  }

  type PrivateIdentityVerificationGetPayload<S extends boolean | null | undefined | PrivateIdentityVerificationDefaultArgs> = $Result.GetResult<Prisma.$PrivateIdentityVerificationPayload, S>

  type PrivateIdentityVerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PrivateIdentityVerificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PrivateIdentityVerificationCountAggregateInputType | true
    }

  export interface PrivateIdentityVerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrivateIdentityVerification'], meta: { name: 'PrivateIdentityVerification' } }
    /**
     * Find zero or one PrivateIdentityVerification that matches the filter.
     * @param {PrivateIdentityVerificationFindUniqueArgs} args - Arguments to find a PrivateIdentityVerification
     * @example
     * // Get one PrivateIdentityVerification
     * const privateIdentityVerification = await prisma.privateIdentityVerification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrivateIdentityVerificationFindUniqueArgs>(args: SelectSubset<T, PrivateIdentityVerificationFindUniqueArgs<ExtArgs>>): Prisma__PrivateIdentityVerificationClient<$Result.GetResult<Prisma.$PrivateIdentityVerificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PrivateIdentityVerification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PrivateIdentityVerificationFindUniqueOrThrowArgs} args - Arguments to find a PrivateIdentityVerification
     * @example
     * // Get one PrivateIdentityVerification
     * const privateIdentityVerification = await prisma.privateIdentityVerification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrivateIdentityVerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, PrivateIdentityVerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrivateIdentityVerificationClient<$Result.GetResult<Prisma.$PrivateIdentityVerificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PrivateIdentityVerification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateIdentityVerificationFindFirstArgs} args - Arguments to find a PrivateIdentityVerification
     * @example
     * // Get one PrivateIdentityVerification
     * const privateIdentityVerification = await prisma.privateIdentityVerification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrivateIdentityVerificationFindFirstArgs>(args?: SelectSubset<T, PrivateIdentityVerificationFindFirstArgs<ExtArgs>>): Prisma__PrivateIdentityVerificationClient<$Result.GetResult<Prisma.$PrivateIdentityVerificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PrivateIdentityVerification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateIdentityVerificationFindFirstOrThrowArgs} args - Arguments to find a PrivateIdentityVerification
     * @example
     * // Get one PrivateIdentityVerification
     * const privateIdentityVerification = await prisma.privateIdentityVerification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrivateIdentityVerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, PrivateIdentityVerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrivateIdentityVerificationClient<$Result.GetResult<Prisma.$PrivateIdentityVerificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PrivateIdentityVerifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateIdentityVerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrivateIdentityVerifications
     * const privateIdentityVerifications = await prisma.privateIdentityVerification.findMany()
     * 
     * // Get first 10 PrivateIdentityVerifications
     * const privateIdentityVerifications = await prisma.privateIdentityVerification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const privateIdentityVerificationWithIdOnly = await prisma.privateIdentityVerification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrivateIdentityVerificationFindManyArgs>(args?: SelectSubset<T, PrivateIdentityVerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateIdentityVerificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PrivateIdentityVerification.
     * @param {PrivateIdentityVerificationCreateArgs} args - Arguments to create a PrivateIdentityVerification.
     * @example
     * // Create one PrivateIdentityVerification
     * const PrivateIdentityVerification = await prisma.privateIdentityVerification.create({
     *   data: {
     *     // ... data to create a PrivateIdentityVerification
     *   }
     * })
     * 
     */
    create<T extends PrivateIdentityVerificationCreateArgs>(args: SelectSubset<T, PrivateIdentityVerificationCreateArgs<ExtArgs>>): Prisma__PrivateIdentityVerificationClient<$Result.GetResult<Prisma.$PrivateIdentityVerificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PrivateIdentityVerifications.
     * @param {PrivateIdentityVerificationCreateManyArgs} args - Arguments to create many PrivateIdentityVerifications.
     * @example
     * // Create many PrivateIdentityVerifications
     * const privateIdentityVerification = await prisma.privateIdentityVerification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrivateIdentityVerificationCreateManyArgs>(args?: SelectSubset<T, PrivateIdentityVerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PrivateIdentityVerifications and returns the data saved in the database.
     * @param {PrivateIdentityVerificationCreateManyAndReturnArgs} args - Arguments to create many PrivateIdentityVerifications.
     * @example
     * // Create many PrivateIdentityVerifications
     * const privateIdentityVerification = await prisma.privateIdentityVerification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PrivateIdentityVerifications and only return the `id`
     * const privateIdentityVerificationWithIdOnly = await prisma.privateIdentityVerification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrivateIdentityVerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, PrivateIdentityVerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateIdentityVerificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PrivateIdentityVerification.
     * @param {PrivateIdentityVerificationDeleteArgs} args - Arguments to delete one PrivateIdentityVerification.
     * @example
     * // Delete one PrivateIdentityVerification
     * const PrivateIdentityVerification = await prisma.privateIdentityVerification.delete({
     *   where: {
     *     // ... filter to delete one PrivateIdentityVerification
     *   }
     * })
     * 
     */
    delete<T extends PrivateIdentityVerificationDeleteArgs>(args: SelectSubset<T, PrivateIdentityVerificationDeleteArgs<ExtArgs>>): Prisma__PrivateIdentityVerificationClient<$Result.GetResult<Prisma.$PrivateIdentityVerificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PrivateIdentityVerification.
     * @param {PrivateIdentityVerificationUpdateArgs} args - Arguments to update one PrivateIdentityVerification.
     * @example
     * // Update one PrivateIdentityVerification
     * const privateIdentityVerification = await prisma.privateIdentityVerification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrivateIdentityVerificationUpdateArgs>(args: SelectSubset<T, PrivateIdentityVerificationUpdateArgs<ExtArgs>>): Prisma__PrivateIdentityVerificationClient<$Result.GetResult<Prisma.$PrivateIdentityVerificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PrivateIdentityVerifications.
     * @param {PrivateIdentityVerificationDeleteManyArgs} args - Arguments to filter PrivateIdentityVerifications to delete.
     * @example
     * // Delete a few PrivateIdentityVerifications
     * const { count } = await prisma.privateIdentityVerification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrivateIdentityVerificationDeleteManyArgs>(args?: SelectSubset<T, PrivateIdentityVerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrivateIdentityVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateIdentityVerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrivateIdentityVerifications
     * const privateIdentityVerification = await prisma.privateIdentityVerification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrivateIdentityVerificationUpdateManyArgs>(args: SelectSubset<T, PrivateIdentityVerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PrivateIdentityVerification.
     * @param {PrivateIdentityVerificationUpsertArgs} args - Arguments to update or create a PrivateIdentityVerification.
     * @example
     * // Update or create a PrivateIdentityVerification
     * const privateIdentityVerification = await prisma.privateIdentityVerification.upsert({
     *   create: {
     *     // ... data to create a PrivateIdentityVerification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrivateIdentityVerification we want to update
     *   }
     * })
     */
    upsert<T extends PrivateIdentityVerificationUpsertArgs>(args: SelectSubset<T, PrivateIdentityVerificationUpsertArgs<ExtArgs>>): Prisma__PrivateIdentityVerificationClient<$Result.GetResult<Prisma.$PrivateIdentityVerificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PrivateIdentityVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateIdentityVerificationCountArgs} args - Arguments to filter PrivateIdentityVerifications to count.
     * @example
     * // Count the number of PrivateIdentityVerifications
     * const count = await prisma.privateIdentityVerification.count({
     *   where: {
     *     // ... the filter for the PrivateIdentityVerifications we want to count
     *   }
     * })
    **/
    count<T extends PrivateIdentityVerificationCountArgs>(
      args?: Subset<T, PrivateIdentityVerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrivateIdentityVerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrivateIdentityVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateIdentityVerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrivateIdentityVerificationAggregateArgs>(args: Subset<T, PrivateIdentityVerificationAggregateArgs>): Prisma.PrismaPromise<GetPrivateIdentityVerificationAggregateType<T>>

    /**
     * Group by PrivateIdentityVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateIdentityVerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrivateIdentityVerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrivateIdentityVerificationGroupByArgs['orderBy'] }
        : { orderBy?: PrivateIdentityVerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrivateIdentityVerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrivateIdentityVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrivateIdentityVerification model
   */
  readonly fields: PrivateIdentityVerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrivateIdentityVerification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrivateIdentityVerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrivateIdentityVerification model
   */ 
  interface PrivateIdentityVerificationFieldRefs {
    readonly id: FieldRef<"PrivateIdentityVerification", 'String'>
    readonly userId: FieldRef<"PrivateIdentityVerification", 'String'>
    readonly status: FieldRef<"PrivateIdentityVerification", 'IdentityStatus'>
    readonly level: FieldRef<"PrivateIdentityVerification", 'String'>
    readonly provider: FieldRef<"PrivateIdentityVerification", 'String'>
    readonly providerSessionId: FieldRef<"PrivateIdentityVerification", 'String'>
    readonly providerStatus: FieldRef<"PrivateIdentityVerification", 'String'>
    readonly verifiedAt: FieldRef<"PrivateIdentityVerification", 'DateTime'>
    readonly expiresAt: FieldRef<"PrivateIdentityVerification", 'DateTime'>
    readonly rejectionReason: FieldRef<"PrivateIdentityVerification", 'String'>
    readonly retryCount: FieldRef<"PrivateIdentityVerification", 'Int'>
    readonly lastAttemptAt: FieldRef<"PrivateIdentityVerification", 'DateTime'>
    readonly isAccredited: FieldRef<"PrivateIdentityVerification", 'Boolean'>
    readonly createdAt: FieldRef<"PrivateIdentityVerification", 'DateTime'>
    readonly updatedAt: FieldRef<"PrivateIdentityVerification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PrivateIdentityVerification findUnique
   */
  export type PrivateIdentityVerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateIdentityVerification
     */
    select?: PrivateIdentityVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateIdentityVerificationInclude<ExtArgs> | null
    /**
     * Filter, which PrivateIdentityVerification to fetch.
     */
    where: PrivateIdentityVerificationWhereUniqueInput
  }

  /**
   * PrivateIdentityVerification findUniqueOrThrow
   */
  export type PrivateIdentityVerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateIdentityVerification
     */
    select?: PrivateIdentityVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateIdentityVerificationInclude<ExtArgs> | null
    /**
     * Filter, which PrivateIdentityVerification to fetch.
     */
    where: PrivateIdentityVerificationWhereUniqueInput
  }

  /**
   * PrivateIdentityVerification findFirst
   */
  export type PrivateIdentityVerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateIdentityVerification
     */
    select?: PrivateIdentityVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateIdentityVerificationInclude<ExtArgs> | null
    /**
     * Filter, which PrivateIdentityVerification to fetch.
     */
    where?: PrivateIdentityVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateIdentityVerifications to fetch.
     */
    orderBy?: PrivateIdentityVerificationOrderByWithRelationInput | PrivateIdentityVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrivateIdentityVerifications.
     */
    cursor?: PrivateIdentityVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateIdentityVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateIdentityVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrivateIdentityVerifications.
     */
    distinct?: PrivateIdentityVerificationScalarFieldEnum | PrivateIdentityVerificationScalarFieldEnum[]
  }

  /**
   * PrivateIdentityVerification findFirstOrThrow
   */
  export type PrivateIdentityVerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateIdentityVerification
     */
    select?: PrivateIdentityVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateIdentityVerificationInclude<ExtArgs> | null
    /**
     * Filter, which PrivateIdentityVerification to fetch.
     */
    where?: PrivateIdentityVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateIdentityVerifications to fetch.
     */
    orderBy?: PrivateIdentityVerificationOrderByWithRelationInput | PrivateIdentityVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrivateIdentityVerifications.
     */
    cursor?: PrivateIdentityVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateIdentityVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateIdentityVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrivateIdentityVerifications.
     */
    distinct?: PrivateIdentityVerificationScalarFieldEnum | PrivateIdentityVerificationScalarFieldEnum[]
  }

  /**
   * PrivateIdentityVerification findMany
   */
  export type PrivateIdentityVerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateIdentityVerification
     */
    select?: PrivateIdentityVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateIdentityVerificationInclude<ExtArgs> | null
    /**
     * Filter, which PrivateIdentityVerifications to fetch.
     */
    where?: PrivateIdentityVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateIdentityVerifications to fetch.
     */
    orderBy?: PrivateIdentityVerificationOrderByWithRelationInput | PrivateIdentityVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrivateIdentityVerifications.
     */
    cursor?: PrivateIdentityVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateIdentityVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateIdentityVerifications.
     */
    skip?: number
    distinct?: PrivateIdentityVerificationScalarFieldEnum | PrivateIdentityVerificationScalarFieldEnum[]
  }

  /**
   * PrivateIdentityVerification create
   */
  export type PrivateIdentityVerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateIdentityVerification
     */
    select?: PrivateIdentityVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateIdentityVerificationInclude<ExtArgs> | null
    /**
     * The data needed to create a PrivateIdentityVerification.
     */
    data: XOR<PrivateIdentityVerificationCreateInput, PrivateIdentityVerificationUncheckedCreateInput>
  }

  /**
   * PrivateIdentityVerification createMany
   */
  export type PrivateIdentityVerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrivateIdentityVerifications.
     */
    data: PrivateIdentityVerificationCreateManyInput | PrivateIdentityVerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrivateIdentityVerification createManyAndReturn
   */
  export type PrivateIdentityVerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateIdentityVerification
     */
    select?: PrivateIdentityVerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PrivateIdentityVerifications.
     */
    data: PrivateIdentityVerificationCreateManyInput | PrivateIdentityVerificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateIdentityVerificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrivateIdentityVerification update
   */
  export type PrivateIdentityVerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateIdentityVerification
     */
    select?: PrivateIdentityVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateIdentityVerificationInclude<ExtArgs> | null
    /**
     * The data needed to update a PrivateIdentityVerification.
     */
    data: XOR<PrivateIdentityVerificationUpdateInput, PrivateIdentityVerificationUncheckedUpdateInput>
    /**
     * Choose, which PrivateIdentityVerification to update.
     */
    where: PrivateIdentityVerificationWhereUniqueInput
  }

  /**
   * PrivateIdentityVerification updateMany
   */
  export type PrivateIdentityVerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrivateIdentityVerifications.
     */
    data: XOR<PrivateIdentityVerificationUpdateManyMutationInput, PrivateIdentityVerificationUncheckedUpdateManyInput>
    /**
     * Filter which PrivateIdentityVerifications to update
     */
    where?: PrivateIdentityVerificationWhereInput
  }

  /**
   * PrivateIdentityVerification upsert
   */
  export type PrivateIdentityVerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateIdentityVerification
     */
    select?: PrivateIdentityVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateIdentityVerificationInclude<ExtArgs> | null
    /**
     * The filter to search for the PrivateIdentityVerification to update in case it exists.
     */
    where: PrivateIdentityVerificationWhereUniqueInput
    /**
     * In case the PrivateIdentityVerification found by the `where` argument doesn't exist, create a new PrivateIdentityVerification with this data.
     */
    create: XOR<PrivateIdentityVerificationCreateInput, PrivateIdentityVerificationUncheckedCreateInput>
    /**
     * In case the PrivateIdentityVerification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrivateIdentityVerificationUpdateInput, PrivateIdentityVerificationUncheckedUpdateInput>
  }

  /**
   * PrivateIdentityVerification delete
   */
  export type PrivateIdentityVerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateIdentityVerification
     */
    select?: PrivateIdentityVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateIdentityVerificationInclude<ExtArgs> | null
    /**
     * Filter which PrivateIdentityVerification to delete.
     */
    where: PrivateIdentityVerificationWhereUniqueInput
  }

  /**
   * PrivateIdentityVerification deleteMany
   */
  export type PrivateIdentityVerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrivateIdentityVerifications to delete
     */
    where?: PrivateIdentityVerificationWhereInput
  }

  /**
   * PrivateIdentityVerification without action
   */
  export type PrivateIdentityVerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateIdentityVerification
     */
    select?: PrivateIdentityVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateIdentityVerificationInclude<ExtArgs> | null
  }


  /**
   * Model ContactMessage
   */

  export type AggregateContactMessage = {
    _count: ContactMessageCountAggregateOutputType | null
    _min: ContactMessageMinAggregateOutputType | null
    _max: ContactMessageMaxAggregateOutputType | null
  }

  export type ContactMessageMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    email: string | null
    subject: string | null
    message: string | null
    category: string | null
    status: $Enums.MessageStatus | null
    assignedTo: string | null
    responseText: string | null
    respondedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactMessageMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    email: string | null
    subject: string | null
    message: string | null
    category: string | null
    status: $Enums.MessageStatus | null
    assignedTo: string | null
    responseText: string | null
    respondedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactMessageCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    email: number
    subject: number
    message: number
    category: number
    status: number
    assignedTo: number
    responseText: number
    respondedAt: number
    ipAddress: number
    userAgent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactMessageMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    category?: true
    status?: true
    assignedTo?: true
    responseText?: true
    respondedAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactMessageMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    category?: true
    status?: true
    assignedTo?: true
    responseText?: true
    respondedAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactMessageCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    category?: true
    status?: true
    assignedTo?: true
    responseText?: true
    respondedAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactMessage to aggregate.
     */
    where?: ContactMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactMessages to fetch.
     */
    orderBy?: ContactMessageOrderByWithRelationInput | ContactMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactMessages
    **/
    _count?: true | ContactMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMessageMaxAggregateInputType
  }

  export type GetContactMessageAggregateType<T extends ContactMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateContactMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactMessage[P]>
      : GetScalarType<T[P], AggregateContactMessage[P]>
  }




  export type ContactMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactMessageWhereInput
    orderBy?: ContactMessageOrderByWithAggregationInput | ContactMessageOrderByWithAggregationInput[]
    by: ContactMessageScalarFieldEnum[] | ContactMessageScalarFieldEnum
    having?: ContactMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactMessageCountAggregateInputType | true
    _min?: ContactMessageMinAggregateInputType
    _max?: ContactMessageMaxAggregateInputType
  }

  export type ContactMessageGroupByOutputType = {
    id: string
    userId: string | null
    name: string
    email: string
    subject: string | null
    message: string
    category: string | null
    status: $Enums.MessageStatus
    assignedTo: string | null
    responseText: string | null
    respondedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    updatedAt: Date
    _count: ContactMessageCountAggregateOutputType | null
    _min: ContactMessageMinAggregateOutputType | null
    _max: ContactMessageMaxAggregateOutputType | null
  }

  type GetContactMessageGroupByPayload<T extends ContactMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ContactMessageGroupByOutputType[P]>
        }
      >
    >


  export type ContactMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    category?: boolean
    status?: boolean
    assignedTo?: boolean
    responseText?: boolean
    respondedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | ContactMessage$userArgs<ExtArgs>
    adminNotes?: boolean | ContactMessage$adminNotesArgs<ExtArgs>
    _count?: boolean | ContactMessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactMessage"]>

  export type ContactMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    category?: boolean
    status?: boolean
    assignedTo?: boolean
    responseText?: boolean
    respondedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | ContactMessage$userArgs<ExtArgs>
  }, ExtArgs["result"]["contactMessage"]>

  export type ContactMessageSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    category?: boolean
    status?: boolean
    assignedTo?: boolean
    responseText?: boolean
    respondedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ContactMessage$userArgs<ExtArgs>
    adminNotes?: boolean | ContactMessage$adminNotesArgs<ExtArgs>
    _count?: boolean | ContactMessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContactMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ContactMessage$userArgs<ExtArgs>
  }

  export type $ContactMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactMessage"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      adminNotes: Prisma.$AdminNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      name: string
      email: string
      subject: string | null
      message: string
      category: string | null
      status: $Enums.MessageStatus
      assignedTo: string | null
      responseText: string | null
      respondedAt: Date | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contactMessage"]>
    composites: {}
  }

  type ContactMessageGetPayload<S extends boolean | null | undefined | ContactMessageDefaultArgs> = $Result.GetResult<Prisma.$ContactMessagePayload, S>

  type ContactMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContactMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContactMessageCountAggregateInputType | true
    }

  export interface ContactMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactMessage'], meta: { name: 'ContactMessage' } }
    /**
     * Find zero or one ContactMessage that matches the filter.
     * @param {ContactMessageFindUniqueArgs} args - Arguments to find a ContactMessage
     * @example
     * // Get one ContactMessage
     * const contactMessage = await prisma.contactMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactMessageFindUniqueArgs>(args: SelectSubset<T, ContactMessageFindUniqueArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ContactMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContactMessageFindUniqueOrThrowArgs} args - Arguments to find a ContactMessage
     * @example
     * // Get one ContactMessage
     * const contactMessage = await prisma.contactMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ContactMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageFindFirstArgs} args - Arguments to find a ContactMessage
     * @example
     * // Get one ContactMessage
     * const contactMessage = await prisma.contactMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactMessageFindFirstArgs>(args?: SelectSubset<T, ContactMessageFindFirstArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ContactMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageFindFirstOrThrowArgs} args - Arguments to find a ContactMessage
     * @example
     * // Get one ContactMessage
     * const contactMessage = await prisma.contactMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ContactMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactMessages
     * const contactMessages = await prisma.contactMessage.findMany()
     * 
     * // Get first 10 ContactMessages
     * const contactMessages = await prisma.contactMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactMessageWithIdOnly = await prisma.contactMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactMessageFindManyArgs>(args?: SelectSubset<T, ContactMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ContactMessage.
     * @param {ContactMessageCreateArgs} args - Arguments to create a ContactMessage.
     * @example
     * // Create one ContactMessage
     * const ContactMessage = await prisma.contactMessage.create({
     *   data: {
     *     // ... data to create a ContactMessage
     *   }
     * })
     * 
     */
    create<T extends ContactMessageCreateArgs>(args: SelectSubset<T, ContactMessageCreateArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ContactMessages.
     * @param {ContactMessageCreateManyArgs} args - Arguments to create many ContactMessages.
     * @example
     * // Create many ContactMessages
     * const contactMessage = await prisma.contactMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactMessageCreateManyArgs>(args?: SelectSubset<T, ContactMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactMessages and returns the data saved in the database.
     * @param {ContactMessageCreateManyAndReturnArgs} args - Arguments to create many ContactMessages.
     * @example
     * // Create many ContactMessages
     * const contactMessage = await prisma.contactMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactMessages and only return the `id`
     * const contactMessageWithIdOnly = await prisma.contactMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ContactMessage.
     * @param {ContactMessageDeleteArgs} args - Arguments to delete one ContactMessage.
     * @example
     * // Delete one ContactMessage
     * const ContactMessage = await prisma.contactMessage.delete({
     *   where: {
     *     // ... filter to delete one ContactMessage
     *   }
     * })
     * 
     */
    delete<T extends ContactMessageDeleteArgs>(args: SelectSubset<T, ContactMessageDeleteArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ContactMessage.
     * @param {ContactMessageUpdateArgs} args - Arguments to update one ContactMessage.
     * @example
     * // Update one ContactMessage
     * const contactMessage = await prisma.contactMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactMessageUpdateArgs>(args: SelectSubset<T, ContactMessageUpdateArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ContactMessages.
     * @param {ContactMessageDeleteManyArgs} args - Arguments to filter ContactMessages to delete.
     * @example
     * // Delete a few ContactMessages
     * const { count } = await prisma.contactMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactMessageDeleteManyArgs>(args?: SelectSubset<T, ContactMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactMessages
     * const contactMessage = await prisma.contactMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactMessageUpdateManyArgs>(args: SelectSubset<T, ContactMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContactMessage.
     * @param {ContactMessageUpsertArgs} args - Arguments to update or create a ContactMessage.
     * @example
     * // Update or create a ContactMessage
     * const contactMessage = await prisma.contactMessage.upsert({
     *   create: {
     *     // ... data to create a ContactMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactMessage we want to update
     *   }
     * })
     */
    upsert<T extends ContactMessageUpsertArgs>(args: SelectSubset<T, ContactMessageUpsertArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ContactMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageCountArgs} args - Arguments to filter ContactMessages to count.
     * @example
     * // Count the number of ContactMessages
     * const count = await prisma.contactMessage.count({
     *   where: {
     *     // ... the filter for the ContactMessages we want to count
     *   }
     * })
    **/
    count<T extends ContactMessageCountArgs>(
      args?: Subset<T, ContactMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactMessageAggregateArgs>(args: Subset<T, ContactMessageAggregateArgs>): Prisma.PrismaPromise<GetContactMessageAggregateType<T>>

    /**
     * Group by ContactMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactMessageGroupByArgs['orderBy'] }
        : { orderBy?: ContactMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactMessage model
   */
  readonly fields: ContactMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends ContactMessage$userArgs<ExtArgs> = {}>(args?: Subset<T, ContactMessage$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    adminNotes<T extends ContactMessage$adminNotesArgs<ExtArgs> = {}>(args?: Subset<T, ContactMessage$adminNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminNotePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactMessage model
   */ 
  interface ContactMessageFieldRefs {
    readonly id: FieldRef<"ContactMessage", 'String'>
    readonly userId: FieldRef<"ContactMessage", 'String'>
    readonly name: FieldRef<"ContactMessage", 'String'>
    readonly email: FieldRef<"ContactMessage", 'String'>
    readonly subject: FieldRef<"ContactMessage", 'String'>
    readonly message: FieldRef<"ContactMessage", 'String'>
    readonly category: FieldRef<"ContactMessage", 'String'>
    readonly status: FieldRef<"ContactMessage", 'MessageStatus'>
    readonly assignedTo: FieldRef<"ContactMessage", 'String'>
    readonly responseText: FieldRef<"ContactMessage", 'String'>
    readonly respondedAt: FieldRef<"ContactMessage", 'DateTime'>
    readonly ipAddress: FieldRef<"ContactMessage", 'String'>
    readonly userAgent: FieldRef<"ContactMessage", 'String'>
    readonly createdAt: FieldRef<"ContactMessage", 'DateTime'>
    readonly updatedAt: FieldRef<"ContactMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactMessage findUnique
   */
  export type ContactMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactMessageInclude<ExtArgs> | null
    /**
     * Filter, which ContactMessage to fetch.
     */
    where: ContactMessageWhereUniqueInput
  }

  /**
   * ContactMessage findUniqueOrThrow
   */
  export type ContactMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactMessageInclude<ExtArgs> | null
    /**
     * Filter, which ContactMessage to fetch.
     */
    where: ContactMessageWhereUniqueInput
  }

  /**
   * ContactMessage findFirst
   */
  export type ContactMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactMessageInclude<ExtArgs> | null
    /**
     * Filter, which ContactMessage to fetch.
     */
    where?: ContactMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactMessages to fetch.
     */
    orderBy?: ContactMessageOrderByWithRelationInput | ContactMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactMessages.
     */
    cursor?: ContactMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactMessages.
     */
    distinct?: ContactMessageScalarFieldEnum | ContactMessageScalarFieldEnum[]
  }

  /**
   * ContactMessage findFirstOrThrow
   */
  export type ContactMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactMessageInclude<ExtArgs> | null
    /**
     * Filter, which ContactMessage to fetch.
     */
    where?: ContactMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactMessages to fetch.
     */
    orderBy?: ContactMessageOrderByWithRelationInput | ContactMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactMessages.
     */
    cursor?: ContactMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactMessages.
     */
    distinct?: ContactMessageScalarFieldEnum | ContactMessageScalarFieldEnum[]
  }

  /**
   * ContactMessage findMany
   */
  export type ContactMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactMessageInclude<ExtArgs> | null
    /**
     * Filter, which ContactMessages to fetch.
     */
    where?: ContactMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactMessages to fetch.
     */
    orderBy?: ContactMessageOrderByWithRelationInput | ContactMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactMessages.
     */
    cursor?: ContactMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactMessages.
     */
    skip?: number
    distinct?: ContactMessageScalarFieldEnum | ContactMessageScalarFieldEnum[]
  }

  /**
   * ContactMessage create
   */
  export type ContactMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactMessage.
     */
    data: XOR<ContactMessageCreateInput, ContactMessageUncheckedCreateInput>
  }

  /**
   * ContactMessage createMany
   */
  export type ContactMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactMessages.
     */
    data: ContactMessageCreateManyInput | ContactMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactMessage createManyAndReturn
   */
  export type ContactMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ContactMessages.
     */
    data: ContactMessageCreateManyInput | ContactMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactMessage update
   */
  export type ContactMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactMessage.
     */
    data: XOR<ContactMessageUpdateInput, ContactMessageUncheckedUpdateInput>
    /**
     * Choose, which ContactMessage to update.
     */
    where: ContactMessageWhereUniqueInput
  }

  /**
   * ContactMessage updateMany
   */
  export type ContactMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactMessages.
     */
    data: XOR<ContactMessageUpdateManyMutationInput, ContactMessageUncheckedUpdateManyInput>
    /**
     * Filter which ContactMessages to update
     */
    where?: ContactMessageWhereInput
  }

  /**
   * ContactMessage upsert
   */
  export type ContactMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactMessage to update in case it exists.
     */
    where: ContactMessageWhereUniqueInput
    /**
     * In case the ContactMessage found by the `where` argument doesn't exist, create a new ContactMessage with this data.
     */
    create: XOR<ContactMessageCreateInput, ContactMessageUncheckedCreateInput>
    /**
     * In case the ContactMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactMessageUpdateInput, ContactMessageUncheckedUpdateInput>
  }

  /**
   * ContactMessage delete
   */
  export type ContactMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactMessageInclude<ExtArgs> | null
    /**
     * Filter which ContactMessage to delete.
     */
    where: ContactMessageWhereUniqueInput
  }

  /**
   * ContactMessage deleteMany
   */
  export type ContactMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactMessages to delete
     */
    where?: ContactMessageWhereInput
  }

  /**
   * ContactMessage.user
   */
  export type ContactMessage$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ContactMessage.adminNotes
   */
  export type ContactMessage$adminNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNote
     */
    select?: AdminNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNoteInclude<ExtArgs> | null
    where?: AdminNoteWhereInput
    orderBy?: AdminNoteOrderByWithRelationInput | AdminNoteOrderByWithRelationInput[]
    cursor?: AdminNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminNoteScalarFieldEnum | AdminNoteScalarFieldEnum[]
  }

  /**
   * ContactMessage without action
   */
  export type ContactMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactMessageInclude<ExtArgs> | null
  }


  /**
   * Model LaunchApplication
   */

  export type AggregateLaunchApplication = {
    _count: LaunchApplicationCountAggregateOutputType | null
    _min: LaunchApplicationMinAggregateOutputType | null
    _max: LaunchApplicationMaxAggregateOutputType | null
  }

  export type LaunchApplicationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    applicantName: string | null
    applicantEmail: string | null
    applicantRole: string | null
    companyName: string | null
    website: string | null
    type: $Enums.ApplicationType | null
    description: string | null
    raiseAmount: string | null
    timeline: string | null
    twitter: string | null
    discord: string | null
    telegram: string | null
    referralSource: string | null
    status: $Enums.ApplicationStatus | null
    reviewedBy: string | null
    reviewedAt: Date | null
    rejectionReason: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaunchApplicationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    applicantName: string | null
    applicantEmail: string | null
    applicantRole: string | null
    companyName: string | null
    website: string | null
    type: $Enums.ApplicationType | null
    description: string | null
    raiseAmount: string | null
    timeline: string | null
    twitter: string | null
    discord: string | null
    telegram: string | null
    referralSource: string | null
    status: $Enums.ApplicationStatus | null
    reviewedBy: string | null
    reviewedAt: Date | null
    rejectionReason: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LaunchApplicationCountAggregateOutputType = {
    id: number
    userId: number
    applicantName: number
    applicantEmail: number
    applicantRole: number
    companyName: number
    website: number
    type: number
    description: number
    raiseAmount: number
    timeline: number
    twitter: number
    discord: number
    telegram: number
    referralSource: number
    status: number
    reviewedBy: number
    reviewedAt: number
    rejectionReason: number
    ipAddress: number
    userAgent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LaunchApplicationMinAggregateInputType = {
    id?: true
    userId?: true
    applicantName?: true
    applicantEmail?: true
    applicantRole?: true
    companyName?: true
    website?: true
    type?: true
    description?: true
    raiseAmount?: true
    timeline?: true
    twitter?: true
    discord?: true
    telegram?: true
    referralSource?: true
    status?: true
    reviewedBy?: true
    reviewedAt?: true
    rejectionReason?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaunchApplicationMaxAggregateInputType = {
    id?: true
    userId?: true
    applicantName?: true
    applicantEmail?: true
    applicantRole?: true
    companyName?: true
    website?: true
    type?: true
    description?: true
    raiseAmount?: true
    timeline?: true
    twitter?: true
    discord?: true
    telegram?: true
    referralSource?: true
    status?: true
    reviewedBy?: true
    reviewedAt?: true
    rejectionReason?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LaunchApplicationCountAggregateInputType = {
    id?: true
    userId?: true
    applicantName?: true
    applicantEmail?: true
    applicantRole?: true
    companyName?: true
    website?: true
    type?: true
    description?: true
    raiseAmount?: true
    timeline?: true
    twitter?: true
    discord?: true
    telegram?: true
    referralSource?: true
    status?: true
    reviewedBy?: true
    reviewedAt?: true
    rejectionReason?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LaunchApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LaunchApplication to aggregate.
     */
    where?: LaunchApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaunchApplications to fetch.
     */
    orderBy?: LaunchApplicationOrderByWithRelationInput | LaunchApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaunchApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaunchApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaunchApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LaunchApplications
    **/
    _count?: true | LaunchApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaunchApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaunchApplicationMaxAggregateInputType
  }

  export type GetLaunchApplicationAggregateType<T extends LaunchApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateLaunchApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaunchApplication[P]>
      : GetScalarType<T[P], AggregateLaunchApplication[P]>
  }




  export type LaunchApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LaunchApplicationWhereInput
    orderBy?: LaunchApplicationOrderByWithAggregationInput | LaunchApplicationOrderByWithAggregationInput[]
    by: LaunchApplicationScalarFieldEnum[] | LaunchApplicationScalarFieldEnum
    having?: LaunchApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaunchApplicationCountAggregateInputType | true
    _min?: LaunchApplicationMinAggregateInputType
    _max?: LaunchApplicationMaxAggregateInputType
  }

  export type LaunchApplicationGroupByOutputType = {
    id: string
    userId: string | null
    applicantName: string
    applicantEmail: string
    applicantRole: string | null
    companyName: string | null
    website: string | null
    type: $Enums.ApplicationType
    description: string
    raiseAmount: string | null
    timeline: string | null
    twitter: string | null
    discord: string | null
    telegram: string | null
    referralSource: string | null
    status: $Enums.ApplicationStatus
    reviewedBy: string | null
    reviewedAt: Date | null
    rejectionReason: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    updatedAt: Date
    _count: LaunchApplicationCountAggregateOutputType | null
    _min: LaunchApplicationMinAggregateOutputType | null
    _max: LaunchApplicationMaxAggregateOutputType | null
  }

  type GetLaunchApplicationGroupByPayload<T extends LaunchApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LaunchApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaunchApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaunchApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], LaunchApplicationGroupByOutputType[P]>
        }
      >
    >


  export type LaunchApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    applicantName?: boolean
    applicantEmail?: boolean
    applicantRole?: boolean
    companyName?: boolean
    website?: boolean
    type?: boolean
    description?: boolean
    raiseAmount?: boolean
    timeline?: boolean
    twitter?: boolean
    discord?: boolean
    telegram?: boolean
    referralSource?: boolean
    status?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    rejectionReason?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | LaunchApplication$userArgs<ExtArgs>
    adminNotes?: boolean | LaunchApplication$adminNotesArgs<ExtArgs>
    _count?: boolean | LaunchApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["launchApplication"]>

  export type LaunchApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    applicantName?: boolean
    applicantEmail?: boolean
    applicantRole?: boolean
    companyName?: boolean
    website?: boolean
    type?: boolean
    description?: boolean
    raiseAmount?: boolean
    timeline?: boolean
    twitter?: boolean
    discord?: boolean
    telegram?: boolean
    referralSource?: boolean
    status?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    rejectionReason?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | LaunchApplication$userArgs<ExtArgs>
  }, ExtArgs["result"]["launchApplication"]>

  export type LaunchApplicationSelectScalar = {
    id?: boolean
    userId?: boolean
    applicantName?: boolean
    applicantEmail?: boolean
    applicantRole?: boolean
    companyName?: boolean
    website?: boolean
    type?: boolean
    description?: boolean
    raiseAmount?: boolean
    timeline?: boolean
    twitter?: boolean
    discord?: boolean
    telegram?: boolean
    referralSource?: boolean
    status?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    rejectionReason?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LaunchApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | LaunchApplication$userArgs<ExtArgs>
    adminNotes?: boolean | LaunchApplication$adminNotesArgs<ExtArgs>
    _count?: boolean | LaunchApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LaunchApplicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | LaunchApplication$userArgs<ExtArgs>
  }

  export type $LaunchApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LaunchApplication"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      adminNotes: Prisma.$AdminNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      applicantName: string
      applicantEmail: string
      applicantRole: string | null
      companyName: string | null
      website: string | null
      type: $Enums.ApplicationType
      description: string
      raiseAmount: string | null
      timeline: string | null
      twitter: string | null
      discord: string | null
      telegram: string | null
      referralSource: string | null
      status: $Enums.ApplicationStatus
      reviewedBy: string | null
      reviewedAt: Date | null
      rejectionReason: string | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["launchApplication"]>
    composites: {}
  }

  type LaunchApplicationGetPayload<S extends boolean | null | undefined | LaunchApplicationDefaultArgs> = $Result.GetResult<Prisma.$LaunchApplicationPayload, S>

  type LaunchApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LaunchApplicationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LaunchApplicationCountAggregateInputType | true
    }

  export interface LaunchApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LaunchApplication'], meta: { name: 'LaunchApplication' } }
    /**
     * Find zero or one LaunchApplication that matches the filter.
     * @param {LaunchApplicationFindUniqueArgs} args - Arguments to find a LaunchApplication
     * @example
     * // Get one LaunchApplication
     * const launchApplication = await prisma.launchApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LaunchApplicationFindUniqueArgs>(args: SelectSubset<T, LaunchApplicationFindUniqueArgs<ExtArgs>>): Prisma__LaunchApplicationClient<$Result.GetResult<Prisma.$LaunchApplicationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LaunchApplication that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LaunchApplicationFindUniqueOrThrowArgs} args - Arguments to find a LaunchApplication
     * @example
     * // Get one LaunchApplication
     * const launchApplication = await prisma.launchApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LaunchApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, LaunchApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LaunchApplicationClient<$Result.GetResult<Prisma.$LaunchApplicationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LaunchApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunchApplicationFindFirstArgs} args - Arguments to find a LaunchApplication
     * @example
     * // Get one LaunchApplication
     * const launchApplication = await prisma.launchApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LaunchApplicationFindFirstArgs>(args?: SelectSubset<T, LaunchApplicationFindFirstArgs<ExtArgs>>): Prisma__LaunchApplicationClient<$Result.GetResult<Prisma.$LaunchApplicationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LaunchApplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunchApplicationFindFirstOrThrowArgs} args - Arguments to find a LaunchApplication
     * @example
     * // Get one LaunchApplication
     * const launchApplication = await prisma.launchApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LaunchApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, LaunchApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LaunchApplicationClient<$Result.GetResult<Prisma.$LaunchApplicationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LaunchApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunchApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LaunchApplications
     * const launchApplications = await prisma.launchApplication.findMany()
     * 
     * // Get first 10 LaunchApplications
     * const launchApplications = await prisma.launchApplication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const launchApplicationWithIdOnly = await prisma.launchApplication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LaunchApplicationFindManyArgs>(args?: SelectSubset<T, LaunchApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaunchApplicationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LaunchApplication.
     * @param {LaunchApplicationCreateArgs} args - Arguments to create a LaunchApplication.
     * @example
     * // Create one LaunchApplication
     * const LaunchApplication = await prisma.launchApplication.create({
     *   data: {
     *     // ... data to create a LaunchApplication
     *   }
     * })
     * 
     */
    create<T extends LaunchApplicationCreateArgs>(args: SelectSubset<T, LaunchApplicationCreateArgs<ExtArgs>>): Prisma__LaunchApplicationClient<$Result.GetResult<Prisma.$LaunchApplicationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LaunchApplications.
     * @param {LaunchApplicationCreateManyArgs} args - Arguments to create many LaunchApplications.
     * @example
     * // Create many LaunchApplications
     * const launchApplication = await prisma.launchApplication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LaunchApplicationCreateManyArgs>(args?: SelectSubset<T, LaunchApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LaunchApplications and returns the data saved in the database.
     * @param {LaunchApplicationCreateManyAndReturnArgs} args - Arguments to create many LaunchApplications.
     * @example
     * // Create many LaunchApplications
     * const launchApplication = await prisma.launchApplication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LaunchApplications and only return the `id`
     * const launchApplicationWithIdOnly = await prisma.launchApplication.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LaunchApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, LaunchApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaunchApplicationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LaunchApplication.
     * @param {LaunchApplicationDeleteArgs} args - Arguments to delete one LaunchApplication.
     * @example
     * // Delete one LaunchApplication
     * const LaunchApplication = await prisma.launchApplication.delete({
     *   where: {
     *     // ... filter to delete one LaunchApplication
     *   }
     * })
     * 
     */
    delete<T extends LaunchApplicationDeleteArgs>(args: SelectSubset<T, LaunchApplicationDeleteArgs<ExtArgs>>): Prisma__LaunchApplicationClient<$Result.GetResult<Prisma.$LaunchApplicationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LaunchApplication.
     * @param {LaunchApplicationUpdateArgs} args - Arguments to update one LaunchApplication.
     * @example
     * // Update one LaunchApplication
     * const launchApplication = await prisma.launchApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LaunchApplicationUpdateArgs>(args: SelectSubset<T, LaunchApplicationUpdateArgs<ExtArgs>>): Prisma__LaunchApplicationClient<$Result.GetResult<Prisma.$LaunchApplicationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LaunchApplications.
     * @param {LaunchApplicationDeleteManyArgs} args - Arguments to filter LaunchApplications to delete.
     * @example
     * // Delete a few LaunchApplications
     * const { count } = await prisma.launchApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LaunchApplicationDeleteManyArgs>(args?: SelectSubset<T, LaunchApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaunchApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunchApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LaunchApplications
     * const launchApplication = await prisma.launchApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LaunchApplicationUpdateManyArgs>(args: SelectSubset<T, LaunchApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LaunchApplication.
     * @param {LaunchApplicationUpsertArgs} args - Arguments to update or create a LaunchApplication.
     * @example
     * // Update or create a LaunchApplication
     * const launchApplication = await prisma.launchApplication.upsert({
     *   create: {
     *     // ... data to create a LaunchApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LaunchApplication we want to update
     *   }
     * })
     */
    upsert<T extends LaunchApplicationUpsertArgs>(args: SelectSubset<T, LaunchApplicationUpsertArgs<ExtArgs>>): Prisma__LaunchApplicationClient<$Result.GetResult<Prisma.$LaunchApplicationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LaunchApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunchApplicationCountArgs} args - Arguments to filter LaunchApplications to count.
     * @example
     * // Count the number of LaunchApplications
     * const count = await prisma.launchApplication.count({
     *   where: {
     *     // ... the filter for the LaunchApplications we want to count
     *   }
     * })
    **/
    count<T extends LaunchApplicationCountArgs>(
      args?: Subset<T, LaunchApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaunchApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LaunchApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunchApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaunchApplicationAggregateArgs>(args: Subset<T, LaunchApplicationAggregateArgs>): Prisma.PrismaPromise<GetLaunchApplicationAggregateType<T>>

    /**
     * Group by LaunchApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaunchApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaunchApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaunchApplicationGroupByArgs['orderBy'] }
        : { orderBy?: LaunchApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaunchApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaunchApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LaunchApplication model
   */
  readonly fields: LaunchApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LaunchApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LaunchApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends LaunchApplication$userArgs<ExtArgs> = {}>(args?: Subset<T, LaunchApplication$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    adminNotes<T extends LaunchApplication$adminNotesArgs<ExtArgs> = {}>(args?: Subset<T, LaunchApplication$adminNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminNotePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LaunchApplication model
   */ 
  interface LaunchApplicationFieldRefs {
    readonly id: FieldRef<"LaunchApplication", 'String'>
    readonly userId: FieldRef<"LaunchApplication", 'String'>
    readonly applicantName: FieldRef<"LaunchApplication", 'String'>
    readonly applicantEmail: FieldRef<"LaunchApplication", 'String'>
    readonly applicantRole: FieldRef<"LaunchApplication", 'String'>
    readonly companyName: FieldRef<"LaunchApplication", 'String'>
    readonly website: FieldRef<"LaunchApplication", 'String'>
    readonly type: FieldRef<"LaunchApplication", 'ApplicationType'>
    readonly description: FieldRef<"LaunchApplication", 'String'>
    readonly raiseAmount: FieldRef<"LaunchApplication", 'String'>
    readonly timeline: FieldRef<"LaunchApplication", 'String'>
    readonly twitter: FieldRef<"LaunchApplication", 'String'>
    readonly discord: FieldRef<"LaunchApplication", 'String'>
    readonly telegram: FieldRef<"LaunchApplication", 'String'>
    readonly referralSource: FieldRef<"LaunchApplication", 'String'>
    readonly status: FieldRef<"LaunchApplication", 'ApplicationStatus'>
    readonly reviewedBy: FieldRef<"LaunchApplication", 'String'>
    readonly reviewedAt: FieldRef<"LaunchApplication", 'DateTime'>
    readonly rejectionReason: FieldRef<"LaunchApplication", 'String'>
    readonly ipAddress: FieldRef<"LaunchApplication", 'String'>
    readonly userAgent: FieldRef<"LaunchApplication", 'String'>
    readonly createdAt: FieldRef<"LaunchApplication", 'DateTime'>
    readonly updatedAt: FieldRef<"LaunchApplication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LaunchApplication findUnique
   */
  export type LaunchApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaunchApplication
     */
    select?: LaunchApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaunchApplicationInclude<ExtArgs> | null
    /**
     * Filter, which LaunchApplication to fetch.
     */
    where: LaunchApplicationWhereUniqueInput
  }

  /**
   * LaunchApplication findUniqueOrThrow
   */
  export type LaunchApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaunchApplication
     */
    select?: LaunchApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaunchApplicationInclude<ExtArgs> | null
    /**
     * Filter, which LaunchApplication to fetch.
     */
    where: LaunchApplicationWhereUniqueInput
  }

  /**
   * LaunchApplication findFirst
   */
  export type LaunchApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaunchApplication
     */
    select?: LaunchApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaunchApplicationInclude<ExtArgs> | null
    /**
     * Filter, which LaunchApplication to fetch.
     */
    where?: LaunchApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaunchApplications to fetch.
     */
    orderBy?: LaunchApplicationOrderByWithRelationInput | LaunchApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaunchApplications.
     */
    cursor?: LaunchApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaunchApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaunchApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaunchApplications.
     */
    distinct?: LaunchApplicationScalarFieldEnum | LaunchApplicationScalarFieldEnum[]
  }

  /**
   * LaunchApplication findFirstOrThrow
   */
  export type LaunchApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaunchApplication
     */
    select?: LaunchApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaunchApplicationInclude<ExtArgs> | null
    /**
     * Filter, which LaunchApplication to fetch.
     */
    where?: LaunchApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaunchApplications to fetch.
     */
    orderBy?: LaunchApplicationOrderByWithRelationInput | LaunchApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaunchApplications.
     */
    cursor?: LaunchApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaunchApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaunchApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaunchApplications.
     */
    distinct?: LaunchApplicationScalarFieldEnum | LaunchApplicationScalarFieldEnum[]
  }

  /**
   * LaunchApplication findMany
   */
  export type LaunchApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaunchApplication
     */
    select?: LaunchApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaunchApplicationInclude<ExtArgs> | null
    /**
     * Filter, which LaunchApplications to fetch.
     */
    where?: LaunchApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaunchApplications to fetch.
     */
    orderBy?: LaunchApplicationOrderByWithRelationInput | LaunchApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LaunchApplications.
     */
    cursor?: LaunchApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaunchApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaunchApplications.
     */
    skip?: number
    distinct?: LaunchApplicationScalarFieldEnum | LaunchApplicationScalarFieldEnum[]
  }

  /**
   * LaunchApplication create
   */
  export type LaunchApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaunchApplication
     */
    select?: LaunchApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaunchApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a LaunchApplication.
     */
    data: XOR<LaunchApplicationCreateInput, LaunchApplicationUncheckedCreateInput>
  }

  /**
   * LaunchApplication createMany
   */
  export type LaunchApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LaunchApplications.
     */
    data: LaunchApplicationCreateManyInput | LaunchApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LaunchApplication createManyAndReturn
   */
  export type LaunchApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaunchApplication
     */
    select?: LaunchApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LaunchApplications.
     */
    data: LaunchApplicationCreateManyInput | LaunchApplicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaunchApplicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LaunchApplication update
   */
  export type LaunchApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaunchApplication
     */
    select?: LaunchApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaunchApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a LaunchApplication.
     */
    data: XOR<LaunchApplicationUpdateInput, LaunchApplicationUncheckedUpdateInput>
    /**
     * Choose, which LaunchApplication to update.
     */
    where: LaunchApplicationWhereUniqueInput
  }

  /**
   * LaunchApplication updateMany
   */
  export type LaunchApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LaunchApplications.
     */
    data: XOR<LaunchApplicationUpdateManyMutationInput, LaunchApplicationUncheckedUpdateManyInput>
    /**
     * Filter which LaunchApplications to update
     */
    where?: LaunchApplicationWhereInput
  }

  /**
   * LaunchApplication upsert
   */
  export type LaunchApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaunchApplication
     */
    select?: LaunchApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaunchApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the LaunchApplication to update in case it exists.
     */
    where: LaunchApplicationWhereUniqueInput
    /**
     * In case the LaunchApplication found by the `where` argument doesn't exist, create a new LaunchApplication with this data.
     */
    create: XOR<LaunchApplicationCreateInput, LaunchApplicationUncheckedCreateInput>
    /**
     * In case the LaunchApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaunchApplicationUpdateInput, LaunchApplicationUncheckedUpdateInput>
  }

  /**
   * LaunchApplication delete
   */
  export type LaunchApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaunchApplication
     */
    select?: LaunchApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaunchApplicationInclude<ExtArgs> | null
    /**
     * Filter which LaunchApplication to delete.
     */
    where: LaunchApplicationWhereUniqueInput
  }

  /**
   * LaunchApplication deleteMany
   */
  export type LaunchApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LaunchApplications to delete
     */
    where?: LaunchApplicationWhereInput
  }

  /**
   * LaunchApplication.user
   */
  export type LaunchApplication$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * LaunchApplication.adminNotes
   */
  export type LaunchApplication$adminNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNote
     */
    select?: AdminNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNoteInclude<ExtArgs> | null
    where?: AdminNoteWhereInput
    orderBy?: AdminNoteOrderByWithRelationInput | AdminNoteOrderByWithRelationInput[]
    cursor?: AdminNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminNoteScalarFieldEnum | AdminNoteScalarFieldEnum[]
  }

  /**
   * LaunchApplication without action
   */
  export type LaunchApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaunchApplication
     */
    select?: LaunchApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaunchApplicationInclude<ExtArgs> | null
  }


  /**
   * Model TrustScoreEvent
   */

  export type AggregateTrustScoreEvent = {
    _count: TrustScoreEventCountAggregateOutputType | null
    _avg: TrustScoreEventAvgAggregateOutputType | null
    _sum: TrustScoreEventSumAggregateOutputType | null
    _min: TrustScoreEventMinAggregateOutputType | null
    _max: TrustScoreEventMaxAggregateOutputType | null
  }

  export type TrustScoreEventAvgAggregateOutputType = {
    points: number | null
  }

  export type TrustScoreEventSumAggregateOutputType = {
    points: number | null
  }

  export type TrustScoreEventMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    businessId: string | null
    userId: string | null
    eventType: $Enums.TrustScoreEventType | null
    points: number | null
    reason: string | null
    triggeredBy: string | null
    createdAt: Date | null
  }

  export type TrustScoreEventMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    businessId: string | null
    userId: string | null
    eventType: $Enums.TrustScoreEventType | null
    points: number | null
    reason: string | null
    triggeredBy: string | null
    createdAt: Date | null
  }

  export type TrustScoreEventCountAggregateOutputType = {
    id: number
    projectId: number
    businessId: number
    userId: number
    eventType: number
    points: number
    reason: number
    metadata: number
    triggeredBy: number
    createdAt: number
    _all: number
  }


  export type TrustScoreEventAvgAggregateInputType = {
    points?: true
  }

  export type TrustScoreEventSumAggregateInputType = {
    points?: true
  }

  export type TrustScoreEventMinAggregateInputType = {
    id?: true
    projectId?: true
    businessId?: true
    userId?: true
    eventType?: true
    points?: true
    reason?: true
    triggeredBy?: true
    createdAt?: true
  }

  export type TrustScoreEventMaxAggregateInputType = {
    id?: true
    projectId?: true
    businessId?: true
    userId?: true
    eventType?: true
    points?: true
    reason?: true
    triggeredBy?: true
    createdAt?: true
  }

  export type TrustScoreEventCountAggregateInputType = {
    id?: true
    projectId?: true
    businessId?: true
    userId?: true
    eventType?: true
    points?: true
    reason?: true
    metadata?: true
    triggeredBy?: true
    createdAt?: true
    _all?: true
  }

  export type TrustScoreEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrustScoreEvent to aggregate.
     */
    where?: TrustScoreEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrustScoreEvents to fetch.
     */
    orderBy?: TrustScoreEventOrderByWithRelationInput | TrustScoreEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrustScoreEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrustScoreEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrustScoreEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrustScoreEvents
    **/
    _count?: true | TrustScoreEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrustScoreEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrustScoreEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrustScoreEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrustScoreEventMaxAggregateInputType
  }

  export type GetTrustScoreEventAggregateType<T extends TrustScoreEventAggregateArgs> = {
        [P in keyof T & keyof AggregateTrustScoreEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrustScoreEvent[P]>
      : GetScalarType<T[P], AggregateTrustScoreEvent[P]>
  }




  export type TrustScoreEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrustScoreEventWhereInput
    orderBy?: TrustScoreEventOrderByWithAggregationInput | TrustScoreEventOrderByWithAggregationInput[]
    by: TrustScoreEventScalarFieldEnum[] | TrustScoreEventScalarFieldEnum
    having?: TrustScoreEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrustScoreEventCountAggregateInputType | true
    _avg?: TrustScoreEventAvgAggregateInputType
    _sum?: TrustScoreEventSumAggregateInputType
    _min?: TrustScoreEventMinAggregateInputType
    _max?: TrustScoreEventMaxAggregateInputType
  }

  export type TrustScoreEventGroupByOutputType = {
    id: string
    projectId: string | null
    businessId: string | null
    userId: string | null
    eventType: $Enums.TrustScoreEventType
    points: number
    reason: string
    metadata: JsonValue | null
    triggeredBy: string | null
    createdAt: Date
    _count: TrustScoreEventCountAggregateOutputType | null
    _avg: TrustScoreEventAvgAggregateOutputType | null
    _sum: TrustScoreEventSumAggregateOutputType | null
    _min: TrustScoreEventMinAggregateOutputType | null
    _max: TrustScoreEventMaxAggregateOutputType | null
  }

  type GetTrustScoreEventGroupByPayload<T extends TrustScoreEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrustScoreEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrustScoreEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrustScoreEventGroupByOutputType[P]>
            : GetScalarType<T[P], TrustScoreEventGroupByOutputType[P]>
        }
      >
    >


  export type TrustScoreEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    businessId?: boolean
    userId?: boolean
    eventType?: boolean
    points?: boolean
    reason?: boolean
    metadata?: boolean
    triggeredBy?: boolean
    createdAt?: boolean
    project?: boolean | TrustScoreEvent$projectArgs<ExtArgs>
    business?: boolean | TrustScoreEvent$businessArgs<ExtArgs>
    user?: boolean | TrustScoreEvent$userArgs<ExtArgs>
  }, ExtArgs["result"]["trustScoreEvent"]>

  export type TrustScoreEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    businessId?: boolean
    userId?: boolean
    eventType?: boolean
    points?: boolean
    reason?: boolean
    metadata?: boolean
    triggeredBy?: boolean
    createdAt?: boolean
    project?: boolean | TrustScoreEvent$projectArgs<ExtArgs>
    business?: boolean | TrustScoreEvent$businessArgs<ExtArgs>
    user?: boolean | TrustScoreEvent$userArgs<ExtArgs>
  }, ExtArgs["result"]["trustScoreEvent"]>

  export type TrustScoreEventSelectScalar = {
    id?: boolean
    projectId?: boolean
    businessId?: boolean
    userId?: boolean
    eventType?: boolean
    points?: boolean
    reason?: boolean
    metadata?: boolean
    triggeredBy?: boolean
    createdAt?: boolean
  }

  export type TrustScoreEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | TrustScoreEvent$projectArgs<ExtArgs>
    business?: boolean | TrustScoreEvent$businessArgs<ExtArgs>
    user?: boolean | TrustScoreEvent$userArgs<ExtArgs>
  }
  export type TrustScoreEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | TrustScoreEvent$projectArgs<ExtArgs>
    business?: boolean | TrustScoreEvent$businessArgs<ExtArgs>
    user?: boolean | TrustScoreEvent$userArgs<ExtArgs>
  }

  export type $TrustScoreEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrustScoreEvent"
    objects: {
      project: Prisma.$CryptoProjectPayload<ExtArgs> | null
      business: Prisma.$BusinessPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string | null
      businessId: string | null
      userId: string | null
      eventType: $Enums.TrustScoreEventType
      points: number
      reason: string
      metadata: Prisma.JsonValue | null
      triggeredBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["trustScoreEvent"]>
    composites: {}
  }

  type TrustScoreEventGetPayload<S extends boolean | null | undefined | TrustScoreEventDefaultArgs> = $Result.GetResult<Prisma.$TrustScoreEventPayload, S>

  type TrustScoreEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TrustScoreEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TrustScoreEventCountAggregateInputType | true
    }

  export interface TrustScoreEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrustScoreEvent'], meta: { name: 'TrustScoreEvent' } }
    /**
     * Find zero or one TrustScoreEvent that matches the filter.
     * @param {TrustScoreEventFindUniqueArgs} args - Arguments to find a TrustScoreEvent
     * @example
     * // Get one TrustScoreEvent
     * const trustScoreEvent = await prisma.trustScoreEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrustScoreEventFindUniqueArgs>(args: SelectSubset<T, TrustScoreEventFindUniqueArgs<ExtArgs>>): Prisma__TrustScoreEventClient<$Result.GetResult<Prisma.$TrustScoreEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TrustScoreEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TrustScoreEventFindUniqueOrThrowArgs} args - Arguments to find a TrustScoreEvent
     * @example
     * // Get one TrustScoreEvent
     * const trustScoreEvent = await prisma.trustScoreEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrustScoreEventFindUniqueOrThrowArgs>(args: SelectSubset<T, TrustScoreEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrustScoreEventClient<$Result.GetResult<Prisma.$TrustScoreEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TrustScoreEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustScoreEventFindFirstArgs} args - Arguments to find a TrustScoreEvent
     * @example
     * // Get one TrustScoreEvent
     * const trustScoreEvent = await prisma.trustScoreEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrustScoreEventFindFirstArgs>(args?: SelectSubset<T, TrustScoreEventFindFirstArgs<ExtArgs>>): Prisma__TrustScoreEventClient<$Result.GetResult<Prisma.$TrustScoreEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TrustScoreEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustScoreEventFindFirstOrThrowArgs} args - Arguments to find a TrustScoreEvent
     * @example
     * // Get one TrustScoreEvent
     * const trustScoreEvent = await prisma.trustScoreEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrustScoreEventFindFirstOrThrowArgs>(args?: SelectSubset<T, TrustScoreEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrustScoreEventClient<$Result.GetResult<Prisma.$TrustScoreEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TrustScoreEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustScoreEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrustScoreEvents
     * const trustScoreEvents = await prisma.trustScoreEvent.findMany()
     * 
     * // Get first 10 TrustScoreEvents
     * const trustScoreEvents = await prisma.trustScoreEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trustScoreEventWithIdOnly = await prisma.trustScoreEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrustScoreEventFindManyArgs>(args?: SelectSubset<T, TrustScoreEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrustScoreEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TrustScoreEvent.
     * @param {TrustScoreEventCreateArgs} args - Arguments to create a TrustScoreEvent.
     * @example
     * // Create one TrustScoreEvent
     * const TrustScoreEvent = await prisma.trustScoreEvent.create({
     *   data: {
     *     // ... data to create a TrustScoreEvent
     *   }
     * })
     * 
     */
    create<T extends TrustScoreEventCreateArgs>(args: SelectSubset<T, TrustScoreEventCreateArgs<ExtArgs>>): Prisma__TrustScoreEventClient<$Result.GetResult<Prisma.$TrustScoreEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TrustScoreEvents.
     * @param {TrustScoreEventCreateManyArgs} args - Arguments to create many TrustScoreEvents.
     * @example
     * // Create many TrustScoreEvents
     * const trustScoreEvent = await prisma.trustScoreEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrustScoreEventCreateManyArgs>(args?: SelectSubset<T, TrustScoreEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrustScoreEvents and returns the data saved in the database.
     * @param {TrustScoreEventCreateManyAndReturnArgs} args - Arguments to create many TrustScoreEvents.
     * @example
     * // Create many TrustScoreEvents
     * const trustScoreEvent = await prisma.trustScoreEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrustScoreEvents and only return the `id`
     * const trustScoreEventWithIdOnly = await prisma.trustScoreEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrustScoreEventCreateManyAndReturnArgs>(args?: SelectSubset<T, TrustScoreEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrustScoreEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TrustScoreEvent.
     * @param {TrustScoreEventDeleteArgs} args - Arguments to delete one TrustScoreEvent.
     * @example
     * // Delete one TrustScoreEvent
     * const TrustScoreEvent = await prisma.trustScoreEvent.delete({
     *   where: {
     *     // ... filter to delete one TrustScoreEvent
     *   }
     * })
     * 
     */
    delete<T extends TrustScoreEventDeleteArgs>(args: SelectSubset<T, TrustScoreEventDeleteArgs<ExtArgs>>): Prisma__TrustScoreEventClient<$Result.GetResult<Prisma.$TrustScoreEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TrustScoreEvent.
     * @param {TrustScoreEventUpdateArgs} args - Arguments to update one TrustScoreEvent.
     * @example
     * // Update one TrustScoreEvent
     * const trustScoreEvent = await prisma.trustScoreEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrustScoreEventUpdateArgs>(args: SelectSubset<T, TrustScoreEventUpdateArgs<ExtArgs>>): Prisma__TrustScoreEventClient<$Result.GetResult<Prisma.$TrustScoreEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TrustScoreEvents.
     * @param {TrustScoreEventDeleteManyArgs} args - Arguments to filter TrustScoreEvents to delete.
     * @example
     * // Delete a few TrustScoreEvents
     * const { count } = await prisma.trustScoreEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrustScoreEventDeleteManyArgs>(args?: SelectSubset<T, TrustScoreEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrustScoreEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustScoreEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrustScoreEvents
     * const trustScoreEvent = await prisma.trustScoreEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrustScoreEventUpdateManyArgs>(args: SelectSubset<T, TrustScoreEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrustScoreEvent.
     * @param {TrustScoreEventUpsertArgs} args - Arguments to update or create a TrustScoreEvent.
     * @example
     * // Update or create a TrustScoreEvent
     * const trustScoreEvent = await prisma.trustScoreEvent.upsert({
     *   create: {
     *     // ... data to create a TrustScoreEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrustScoreEvent we want to update
     *   }
     * })
     */
    upsert<T extends TrustScoreEventUpsertArgs>(args: SelectSubset<T, TrustScoreEventUpsertArgs<ExtArgs>>): Prisma__TrustScoreEventClient<$Result.GetResult<Prisma.$TrustScoreEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TrustScoreEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustScoreEventCountArgs} args - Arguments to filter TrustScoreEvents to count.
     * @example
     * // Count the number of TrustScoreEvents
     * const count = await prisma.trustScoreEvent.count({
     *   where: {
     *     // ... the filter for the TrustScoreEvents we want to count
     *   }
     * })
    **/
    count<T extends TrustScoreEventCountArgs>(
      args?: Subset<T, TrustScoreEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrustScoreEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrustScoreEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustScoreEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrustScoreEventAggregateArgs>(args: Subset<T, TrustScoreEventAggregateArgs>): Prisma.PrismaPromise<GetTrustScoreEventAggregateType<T>>

    /**
     * Group by TrustScoreEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrustScoreEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrustScoreEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrustScoreEventGroupByArgs['orderBy'] }
        : { orderBy?: TrustScoreEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrustScoreEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrustScoreEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrustScoreEvent model
   */
  readonly fields: TrustScoreEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrustScoreEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrustScoreEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends TrustScoreEvent$projectArgs<ExtArgs> = {}>(args?: Subset<T, TrustScoreEvent$projectArgs<ExtArgs>>): Prisma__CryptoProjectClient<$Result.GetResult<Prisma.$CryptoProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    business<T extends TrustScoreEvent$businessArgs<ExtArgs> = {}>(args?: Subset<T, TrustScoreEvent$businessArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends TrustScoreEvent$userArgs<ExtArgs> = {}>(args?: Subset<T, TrustScoreEvent$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrustScoreEvent model
   */ 
  interface TrustScoreEventFieldRefs {
    readonly id: FieldRef<"TrustScoreEvent", 'String'>
    readonly projectId: FieldRef<"TrustScoreEvent", 'String'>
    readonly businessId: FieldRef<"TrustScoreEvent", 'String'>
    readonly userId: FieldRef<"TrustScoreEvent", 'String'>
    readonly eventType: FieldRef<"TrustScoreEvent", 'TrustScoreEventType'>
    readonly points: FieldRef<"TrustScoreEvent", 'Int'>
    readonly reason: FieldRef<"TrustScoreEvent", 'String'>
    readonly metadata: FieldRef<"TrustScoreEvent", 'Json'>
    readonly triggeredBy: FieldRef<"TrustScoreEvent", 'String'>
    readonly createdAt: FieldRef<"TrustScoreEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrustScoreEvent findUnique
   */
  export type TrustScoreEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScoreEvent
     */
    select?: TrustScoreEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreEventInclude<ExtArgs> | null
    /**
     * Filter, which TrustScoreEvent to fetch.
     */
    where: TrustScoreEventWhereUniqueInput
  }

  /**
   * TrustScoreEvent findUniqueOrThrow
   */
  export type TrustScoreEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScoreEvent
     */
    select?: TrustScoreEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreEventInclude<ExtArgs> | null
    /**
     * Filter, which TrustScoreEvent to fetch.
     */
    where: TrustScoreEventWhereUniqueInput
  }

  /**
   * TrustScoreEvent findFirst
   */
  export type TrustScoreEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScoreEvent
     */
    select?: TrustScoreEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreEventInclude<ExtArgs> | null
    /**
     * Filter, which TrustScoreEvent to fetch.
     */
    where?: TrustScoreEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrustScoreEvents to fetch.
     */
    orderBy?: TrustScoreEventOrderByWithRelationInput | TrustScoreEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrustScoreEvents.
     */
    cursor?: TrustScoreEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrustScoreEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrustScoreEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrustScoreEvents.
     */
    distinct?: TrustScoreEventScalarFieldEnum | TrustScoreEventScalarFieldEnum[]
  }

  /**
   * TrustScoreEvent findFirstOrThrow
   */
  export type TrustScoreEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScoreEvent
     */
    select?: TrustScoreEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreEventInclude<ExtArgs> | null
    /**
     * Filter, which TrustScoreEvent to fetch.
     */
    where?: TrustScoreEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrustScoreEvents to fetch.
     */
    orderBy?: TrustScoreEventOrderByWithRelationInput | TrustScoreEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrustScoreEvents.
     */
    cursor?: TrustScoreEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrustScoreEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrustScoreEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrustScoreEvents.
     */
    distinct?: TrustScoreEventScalarFieldEnum | TrustScoreEventScalarFieldEnum[]
  }

  /**
   * TrustScoreEvent findMany
   */
  export type TrustScoreEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScoreEvent
     */
    select?: TrustScoreEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreEventInclude<ExtArgs> | null
    /**
     * Filter, which TrustScoreEvents to fetch.
     */
    where?: TrustScoreEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrustScoreEvents to fetch.
     */
    orderBy?: TrustScoreEventOrderByWithRelationInput | TrustScoreEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrustScoreEvents.
     */
    cursor?: TrustScoreEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrustScoreEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrustScoreEvents.
     */
    skip?: number
    distinct?: TrustScoreEventScalarFieldEnum | TrustScoreEventScalarFieldEnum[]
  }

  /**
   * TrustScoreEvent create
   */
  export type TrustScoreEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScoreEvent
     */
    select?: TrustScoreEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreEventInclude<ExtArgs> | null
    /**
     * The data needed to create a TrustScoreEvent.
     */
    data: XOR<TrustScoreEventCreateInput, TrustScoreEventUncheckedCreateInput>
  }

  /**
   * TrustScoreEvent createMany
   */
  export type TrustScoreEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrustScoreEvents.
     */
    data: TrustScoreEventCreateManyInput | TrustScoreEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrustScoreEvent createManyAndReturn
   */
  export type TrustScoreEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScoreEvent
     */
    select?: TrustScoreEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TrustScoreEvents.
     */
    data: TrustScoreEventCreateManyInput | TrustScoreEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrustScoreEvent update
   */
  export type TrustScoreEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScoreEvent
     */
    select?: TrustScoreEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreEventInclude<ExtArgs> | null
    /**
     * The data needed to update a TrustScoreEvent.
     */
    data: XOR<TrustScoreEventUpdateInput, TrustScoreEventUncheckedUpdateInput>
    /**
     * Choose, which TrustScoreEvent to update.
     */
    where: TrustScoreEventWhereUniqueInput
  }

  /**
   * TrustScoreEvent updateMany
   */
  export type TrustScoreEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrustScoreEvents.
     */
    data: XOR<TrustScoreEventUpdateManyMutationInput, TrustScoreEventUncheckedUpdateManyInput>
    /**
     * Filter which TrustScoreEvents to update
     */
    where?: TrustScoreEventWhereInput
  }

  /**
   * TrustScoreEvent upsert
   */
  export type TrustScoreEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScoreEvent
     */
    select?: TrustScoreEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreEventInclude<ExtArgs> | null
    /**
     * The filter to search for the TrustScoreEvent to update in case it exists.
     */
    where: TrustScoreEventWhereUniqueInput
    /**
     * In case the TrustScoreEvent found by the `where` argument doesn't exist, create a new TrustScoreEvent with this data.
     */
    create: XOR<TrustScoreEventCreateInput, TrustScoreEventUncheckedCreateInput>
    /**
     * In case the TrustScoreEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrustScoreEventUpdateInput, TrustScoreEventUncheckedUpdateInput>
  }

  /**
   * TrustScoreEvent delete
   */
  export type TrustScoreEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScoreEvent
     */
    select?: TrustScoreEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreEventInclude<ExtArgs> | null
    /**
     * Filter which TrustScoreEvent to delete.
     */
    where: TrustScoreEventWhereUniqueInput
  }

  /**
   * TrustScoreEvent deleteMany
   */
  export type TrustScoreEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrustScoreEvents to delete
     */
    where?: TrustScoreEventWhereInput
  }

  /**
   * TrustScoreEvent.project
   */
  export type TrustScoreEvent$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoProject
     */
    select?: CryptoProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoProjectInclude<ExtArgs> | null
    where?: CryptoProjectWhereInput
  }

  /**
   * TrustScoreEvent.business
   */
  export type TrustScoreEvent$businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    where?: BusinessWhereInput
  }

  /**
   * TrustScoreEvent.user
   */
  export type TrustScoreEvent$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TrustScoreEvent without action
   */
  export type TrustScoreEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrustScoreEvent
     */
    select?: TrustScoreEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrustScoreEventInclude<ExtArgs> | null
  }


  /**
   * Model AdminNote
   */

  export type AggregateAdminNote = {
    _count: AdminNoteCountAggregateOutputType | null
    _min: AdminNoteMinAggregateOutputType | null
    _max: AdminNoteMaxAggregateOutputType | null
  }

  export type AdminNoteMinAggregateOutputType = {
    id: string | null
    authorId: string | null
    projectId: string | null
    businessId: string | null
    contactId: string | null
    applicationId: string | null
    note: string | null
    isInternal: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminNoteMaxAggregateOutputType = {
    id: string | null
    authorId: string | null
    projectId: string | null
    businessId: string | null
    contactId: string | null
    applicationId: string | null
    note: string | null
    isInternal: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminNoteCountAggregateOutputType = {
    id: number
    authorId: number
    projectId: number
    businessId: number
    contactId: number
    applicationId: number
    note: number
    isInternal: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminNoteMinAggregateInputType = {
    id?: true
    authorId?: true
    projectId?: true
    businessId?: true
    contactId?: true
    applicationId?: true
    note?: true
    isInternal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminNoteMaxAggregateInputType = {
    id?: true
    authorId?: true
    projectId?: true
    businessId?: true
    contactId?: true
    applicationId?: true
    note?: true
    isInternal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminNoteCountAggregateInputType = {
    id?: true
    authorId?: true
    projectId?: true
    businessId?: true
    contactId?: true
    applicationId?: true
    note?: true
    isInternal?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminNote to aggregate.
     */
    where?: AdminNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminNotes to fetch.
     */
    orderBy?: AdminNoteOrderByWithRelationInput | AdminNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminNotes
    **/
    _count?: true | AdminNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminNoteMaxAggregateInputType
  }

  export type GetAdminNoteAggregateType<T extends AdminNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminNote[P]>
      : GetScalarType<T[P], AggregateAdminNote[P]>
  }




  export type AdminNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminNoteWhereInput
    orderBy?: AdminNoteOrderByWithAggregationInput | AdminNoteOrderByWithAggregationInput[]
    by: AdminNoteScalarFieldEnum[] | AdminNoteScalarFieldEnum
    having?: AdminNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminNoteCountAggregateInputType | true
    _min?: AdminNoteMinAggregateInputType
    _max?: AdminNoteMaxAggregateInputType
  }

  export type AdminNoteGroupByOutputType = {
    id: string
    authorId: string
    projectId: string | null
    businessId: string | null
    contactId: string | null
    applicationId: string | null
    note: string
    isInternal: boolean
    createdAt: Date
    updatedAt: Date
    _count: AdminNoteCountAggregateOutputType | null
    _min: AdminNoteMinAggregateOutputType | null
    _max: AdminNoteMaxAggregateOutputType | null
  }

  type GetAdminNoteGroupByPayload<T extends AdminNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminNoteGroupByOutputType[P]>
            : GetScalarType<T[P], AdminNoteGroupByOutputType[P]>
        }
      >
    >


  export type AdminNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    projectId?: boolean
    businessId?: boolean
    contactId?: boolean
    applicationId?: boolean
    note?: boolean
    isInternal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | AdminNote$projectArgs<ExtArgs>
    business?: boolean | AdminNote$businessArgs<ExtArgs>
    contact?: boolean | AdminNote$contactArgs<ExtArgs>
    application?: boolean | AdminNote$applicationArgs<ExtArgs>
  }, ExtArgs["result"]["adminNote"]>

  export type AdminNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    projectId?: boolean
    businessId?: boolean
    contactId?: boolean
    applicationId?: boolean
    note?: boolean
    isInternal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | AdminNote$projectArgs<ExtArgs>
    business?: boolean | AdminNote$businessArgs<ExtArgs>
    contact?: boolean | AdminNote$contactArgs<ExtArgs>
    application?: boolean | AdminNote$applicationArgs<ExtArgs>
  }, ExtArgs["result"]["adminNote"]>

  export type AdminNoteSelectScalar = {
    id?: boolean
    authorId?: boolean
    projectId?: boolean
    businessId?: boolean
    contactId?: boolean
    applicationId?: boolean
    note?: boolean
    isInternal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | AdminNote$projectArgs<ExtArgs>
    business?: boolean | AdminNote$businessArgs<ExtArgs>
    contact?: boolean | AdminNote$contactArgs<ExtArgs>
    application?: boolean | AdminNote$applicationArgs<ExtArgs>
  }
  export type AdminNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | AdminNote$projectArgs<ExtArgs>
    business?: boolean | AdminNote$businessArgs<ExtArgs>
    contact?: boolean | AdminNote$contactArgs<ExtArgs>
    application?: boolean | AdminNote$applicationArgs<ExtArgs>
  }

  export type $AdminNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminNote"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      project: Prisma.$CryptoProjectPayload<ExtArgs> | null
      business: Prisma.$BusinessPayload<ExtArgs> | null
      contact: Prisma.$ContactMessagePayload<ExtArgs> | null
      application: Prisma.$LaunchApplicationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      authorId: string
      projectId: string | null
      businessId: string | null
      contactId: string | null
      applicationId: string | null
      note: string
      isInternal: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adminNote"]>
    composites: {}
  }

  type AdminNoteGetPayload<S extends boolean | null | undefined | AdminNoteDefaultArgs> = $Result.GetResult<Prisma.$AdminNotePayload, S>

  type AdminNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminNoteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminNoteCountAggregateInputType | true
    }

  export interface AdminNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminNote'], meta: { name: 'AdminNote' } }
    /**
     * Find zero or one AdminNote that matches the filter.
     * @param {AdminNoteFindUniqueArgs} args - Arguments to find a AdminNote
     * @example
     * // Get one AdminNote
     * const adminNote = await prisma.adminNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminNoteFindUniqueArgs>(args: SelectSubset<T, AdminNoteFindUniqueArgs<ExtArgs>>): Prisma__AdminNoteClient<$Result.GetResult<Prisma.$AdminNotePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdminNote that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminNoteFindUniqueOrThrowArgs} args - Arguments to find a AdminNote
     * @example
     * // Get one AdminNote
     * const adminNote = await prisma.adminNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminNoteClient<$Result.GetResult<Prisma.$AdminNotePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdminNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminNoteFindFirstArgs} args - Arguments to find a AdminNote
     * @example
     * // Get one AdminNote
     * const adminNote = await prisma.adminNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminNoteFindFirstArgs>(args?: SelectSubset<T, AdminNoteFindFirstArgs<ExtArgs>>): Prisma__AdminNoteClient<$Result.GetResult<Prisma.$AdminNotePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdminNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminNoteFindFirstOrThrowArgs} args - Arguments to find a AdminNote
     * @example
     * // Get one AdminNote
     * const adminNote = await prisma.adminNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminNoteClient<$Result.GetResult<Prisma.$AdminNotePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdminNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminNotes
     * const adminNotes = await prisma.adminNote.findMany()
     * 
     * // Get first 10 AdminNotes
     * const adminNotes = await prisma.adminNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminNoteWithIdOnly = await prisma.adminNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminNoteFindManyArgs>(args?: SelectSubset<T, AdminNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminNotePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdminNote.
     * @param {AdminNoteCreateArgs} args - Arguments to create a AdminNote.
     * @example
     * // Create one AdminNote
     * const AdminNote = await prisma.adminNote.create({
     *   data: {
     *     // ... data to create a AdminNote
     *   }
     * })
     * 
     */
    create<T extends AdminNoteCreateArgs>(args: SelectSubset<T, AdminNoteCreateArgs<ExtArgs>>): Prisma__AdminNoteClient<$Result.GetResult<Prisma.$AdminNotePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdminNotes.
     * @param {AdminNoteCreateManyArgs} args - Arguments to create many AdminNotes.
     * @example
     * // Create many AdminNotes
     * const adminNote = await prisma.adminNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminNoteCreateManyArgs>(args?: SelectSubset<T, AdminNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminNotes and returns the data saved in the database.
     * @param {AdminNoteCreateManyAndReturnArgs} args - Arguments to create many AdminNotes.
     * @example
     * // Create many AdminNotes
     * const adminNote = await prisma.adminNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminNotes and only return the `id`
     * const adminNoteWithIdOnly = await prisma.adminNote.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminNotePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdminNote.
     * @param {AdminNoteDeleteArgs} args - Arguments to delete one AdminNote.
     * @example
     * // Delete one AdminNote
     * const AdminNote = await prisma.adminNote.delete({
     *   where: {
     *     // ... filter to delete one AdminNote
     *   }
     * })
     * 
     */
    delete<T extends AdminNoteDeleteArgs>(args: SelectSubset<T, AdminNoteDeleteArgs<ExtArgs>>): Prisma__AdminNoteClient<$Result.GetResult<Prisma.$AdminNotePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdminNote.
     * @param {AdminNoteUpdateArgs} args - Arguments to update one AdminNote.
     * @example
     * // Update one AdminNote
     * const adminNote = await prisma.adminNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminNoteUpdateArgs>(args: SelectSubset<T, AdminNoteUpdateArgs<ExtArgs>>): Prisma__AdminNoteClient<$Result.GetResult<Prisma.$AdminNotePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdminNotes.
     * @param {AdminNoteDeleteManyArgs} args - Arguments to filter AdminNotes to delete.
     * @example
     * // Delete a few AdminNotes
     * const { count } = await prisma.adminNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminNoteDeleteManyArgs>(args?: SelectSubset<T, AdminNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminNotes
     * const adminNote = await prisma.adminNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminNoteUpdateManyArgs>(args: SelectSubset<T, AdminNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminNote.
     * @param {AdminNoteUpsertArgs} args - Arguments to update or create a AdminNote.
     * @example
     * // Update or create a AdminNote
     * const adminNote = await prisma.adminNote.upsert({
     *   create: {
     *     // ... data to create a AdminNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminNote we want to update
     *   }
     * })
     */
    upsert<T extends AdminNoteUpsertArgs>(args: SelectSubset<T, AdminNoteUpsertArgs<ExtArgs>>): Prisma__AdminNoteClient<$Result.GetResult<Prisma.$AdminNotePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdminNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminNoteCountArgs} args - Arguments to filter AdminNotes to count.
     * @example
     * // Count the number of AdminNotes
     * const count = await prisma.adminNote.count({
     *   where: {
     *     // ... the filter for the AdminNotes we want to count
     *   }
     * })
    **/
    count<T extends AdminNoteCountArgs>(
      args?: Subset<T, AdminNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminNoteAggregateArgs>(args: Subset<T, AdminNoteAggregateArgs>): Prisma.PrismaPromise<GetAdminNoteAggregateType<T>>

    /**
     * Group by AdminNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminNoteGroupByArgs['orderBy'] }
        : { orderBy?: AdminNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminNote model
   */
  readonly fields: AdminNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    project<T extends AdminNote$projectArgs<ExtArgs> = {}>(args?: Subset<T, AdminNote$projectArgs<ExtArgs>>): Prisma__CryptoProjectClient<$Result.GetResult<Prisma.$CryptoProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    business<T extends AdminNote$businessArgs<ExtArgs> = {}>(args?: Subset<T, AdminNote$businessArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    contact<T extends AdminNote$contactArgs<ExtArgs> = {}>(args?: Subset<T, AdminNote$contactArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    application<T extends AdminNote$applicationArgs<ExtArgs> = {}>(args?: Subset<T, AdminNote$applicationArgs<ExtArgs>>): Prisma__LaunchApplicationClient<$Result.GetResult<Prisma.$LaunchApplicationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminNote model
   */ 
  interface AdminNoteFieldRefs {
    readonly id: FieldRef<"AdminNote", 'String'>
    readonly authorId: FieldRef<"AdminNote", 'String'>
    readonly projectId: FieldRef<"AdminNote", 'String'>
    readonly businessId: FieldRef<"AdminNote", 'String'>
    readonly contactId: FieldRef<"AdminNote", 'String'>
    readonly applicationId: FieldRef<"AdminNote", 'String'>
    readonly note: FieldRef<"AdminNote", 'String'>
    readonly isInternal: FieldRef<"AdminNote", 'Boolean'>
    readonly createdAt: FieldRef<"AdminNote", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminNote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminNote findUnique
   */
  export type AdminNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNote
     */
    select?: AdminNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNoteInclude<ExtArgs> | null
    /**
     * Filter, which AdminNote to fetch.
     */
    where: AdminNoteWhereUniqueInput
  }

  /**
   * AdminNote findUniqueOrThrow
   */
  export type AdminNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNote
     */
    select?: AdminNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNoteInclude<ExtArgs> | null
    /**
     * Filter, which AdminNote to fetch.
     */
    where: AdminNoteWhereUniqueInput
  }

  /**
   * AdminNote findFirst
   */
  export type AdminNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNote
     */
    select?: AdminNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNoteInclude<ExtArgs> | null
    /**
     * Filter, which AdminNote to fetch.
     */
    where?: AdminNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminNotes to fetch.
     */
    orderBy?: AdminNoteOrderByWithRelationInput | AdminNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminNotes.
     */
    cursor?: AdminNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminNotes.
     */
    distinct?: AdminNoteScalarFieldEnum | AdminNoteScalarFieldEnum[]
  }

  /**
   * AdminNote findFirstOrThrow
   */
  export type AdminNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNote
     */
    select?: AdminNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNoteInclude<ExtArgs> | null
    /**
     * Filter, which AdminNote to fetch.
     */
    where?: AdminNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminNotes to fetch.
     */
    orderBy?: AdminNoteOrderByWithRelationInput | AdminNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminNotes.
     */
    cursor?: AdminNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminNotes.
     */
    distinct?: AdminNoteScalarFieldEnum | AdminNoteScalarFieldEnum[]
  }

  /**
   * AdminNote findMany
   */
  export type AdminNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNote
     */
    select?: AdminNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNoteInclude<ExtArgs> | null
    /**
     * Filter, which AdminNotes to fetch.
     */
    where?: AdminNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminNotes to fetch.
     */
    orderBy?: AdminNoteOrderByWithRelationInput | AdminNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminNotes.
     */
    cursor?: AdminNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminNotes.
     */
    skip?: number
    distinct?: AdminNoteScalarFieldEnum | AdminNoteScalarFieldEnum[]
  }

  /**
   * AdminNote create
   */
  export type AdminNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNote
     */
    select?: AdminNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminNote.
     */
    data: XOR<AdminNoteCreateInput, AdminNoteUncheckedCreateInput>
  }

  /**
   * AdminNote createMany
   */
  export type AdminNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminNotes.
     */
    data: AdminNoteCreateManyInput | AdminNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminNote createManyAndReturn
   */
  export type AdminNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNote
     */
    select?: AdminNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdminNotes.
     */
    data: AdminNoteCreateManyInput | AdminNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminNote update
   */
  export type AdminNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNote
     */
    select?: AdminNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminNote.
     */
    data: XOR<AdminNoteUpdateInput, AdminNoteUncheckedUpdateInput>
    /**
     * Choose, which AdminNote to update.
     */
    where: AdminNoteWhereUniqueInput
  }

  /**
   * AdminNote updateMany
   */
  export type AdminNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminNotes.
     */
    data: XOR<AdminNoteUpdateManyMutationInput, AdminNoteUncheckedUpdateManyInput>
    /**
     * Filter which AdminNotes to update
     */
    where?: AdminNoteWhereInput
  }

  /**
   * AdminNote upsert
   */
  export type AdminNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNote
     */
    select?: AdminNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminNote to update in case it exists.
     */
    where: AdminNoteWhereUniqueInput
    /**
     * In case the AdminNote found by the `where` argument doesn't exist, create a new AdminNote with this data.
     */
    create: XOR<AdminNoteCreateInput, AdminNoteUncheckedCreateInput>
    /**
     * In case the AdminNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminNoteUpdateInput, AdminNoteUncheckedUpdateInput>
  }

  /**
   * AdminNote delete
   */
  export type AdminNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNote
     */
    select?: AdminNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNoteInclude<ExtArgs> | null
    /**
     * Filter which AdminNote to delete.
     */
    where: AdminNoteWhereUniqueInput
  }

  /**
   * AdminNote deleteMany
   */
  export type AdminNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminNotes to delete
     */
    where?: AdminNoteWhereInput
  }

  /**
   * AdminNote.project
   */
  export type AdminNote$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CryptoProject
     */
    select?: CryptoProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CryptoProjectInclude<ExtArgs> | null
    where?: CryptoProjectWhereInput
  }

  /**
   * AdminNote.business
   */
  export type AdminNote$businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    where?: BusinessWhereInput
  }

  /**
   * AdminNote.contact
   */
  export type AdminNote$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactMessageInclude<ExtArgs> | null
    where?: ContactMessageWhereInput
  }

  /**
   * AdminNote.application
   */
  export type AdminNote$applicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaunchApplication
     */
    select?: LaunchApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaunchApplicationInclude<ExtArgs> | null
    where?: LaunchApplicationWhereInput
  }

  /**
   * AdminNote without action
   */
  export type AdminNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminNote
     */
    select?: AdminNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminNoteInclude<ExtArgs> | null
  }


  /**
   * Model SystemLog
   */

  export type AggregateSystemLog = {
    _count: SystemLogCountAggregateOutputType | null
    _avg: SystemLogAvgAggregateOutputType | null
    _sum: SystemLogSumAggregateOutputType | null
    _min: SystemLogMinAggregateOutputType | null
    _max: SystemLogMaxAggregateOutputType | null
  }

  export type SystemLogAvgAggregateOutputType = {
    statusCode: number | null
    responseTime: number | null
  }

  export type SystemLogSumAggregateOutputType = {
    statusCode: number | null
    responseTime: number | null
  }

  export type SystemLogMinAggregateOutputType = {
    id: string | null
    level: $Enums.LogLevel | null
    category: $Enums.LogCategory | null
    action: string | null
    message: string | null
    userId: string | null
    ipAddress: string | null
    userAgent: string | null
    requestId: string | null
    endpoint: string | null
    method: string | null
    statusCode: number | null
    responseTime: number | null
    createdAt: Date | null
  }

  export type SystemLogMaxAggregateOutputType = {
    id: string | null
    level: $Enums.LogLevel | null
    category: $Enums.LogCategory | null
    action: string | null
    message: string | null
    userId: string | null
    ipAddress: string | null
    userAgent: string | null
    requestId: string | null
    endpoint: string | null
    method: string | null
    statusCode: number | null
    responseTime: number | null
    createdAt: Date | null
  }

  export type SystemLogCountAggregateOutputType = {
    id: number
    level: number
    category: number
    action: number
    message: number
    metadata: number
    userId: number
    ipAddress: number
    userAgent: number
    requestId: number
    endpoint: number
    method: number
    statusCode: number
    responseTime: number
    createdAt: number
    _all: number
  }


  export type SystemLogAvgAggregateInputType = {
    statusCode?: true
    responseTime?: true
  }

  export type SystemLogSumAggregateInputType = {
    statusCode?: true
    responseTime?: true
  }

  export type SystemLogMinAggregateInputType = {
    id?: true
    level?: true
    category?: true
    action?: true
    message?: true
    userId?: true
    ipAddress?: true
    userAgent?: true
    requestId?: true
    endpoint?: true
    method?: true
    statusCode?: true
    responseTime?: true
    createdAt?: true
  }

  export type SystemLogMaxAggregateInputType = {
    id?: true
    level?: true
    category?: true
    action?: true
    message?: true
    userId?: true
    ipAddress?: true
    userAgent?: true
    requestId?: true
    endpoint?: true
    method?: true
    statusCode?: true
    responseTime?: true
    createdAt?: true
  }

  export type SystemLogCountAggregateInputType = {
    id?: true
    level?: true
    category?: true
    action?: true
    message?: true
    metadata?: true
    userId?: true
    ipAddress?: true
    userAgent?: true
    requestId?: true
    endpoint?: true
    method?: true
    statusCode?: true
    responseTime?: true
    createdAt?: true
    _all?: true
  }

  export type SystemLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemLog to aggregate.
     */
    where?: SystemLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLogs to fetch.
     */
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemLogs
    **/
    _count?: true | SystemLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemLogMaxAggregateInputType
  }

  export type GetSystemLogAggregateType<T extends SystemLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemLog[P]>
      : GetScalarType<T[P], AggregateSystemLog[P]>
  }




  export type SystemLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemLogWhereInput
    orderBy?: SystemLogOrderByWithAggregationInput | SystemLogOrderByWithAggregationInput[]
    by: SystemLogScalarFieldEnum[] | SystemLogScalarFieldEnum
    having?: SystemLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemLogCountAggregateInputType | true
    _avg?: SystemLogAvgAggregateInputType
    _sum?: SystemLogSumAggregateInputType
    _min?: SystemLogMinAggregateInputType
    _max?: SystemLogMaxAggregateInputType
  }

  export type SystemLogGroupByOutputType = {
    id: string
    level: $Enums.LogLevel
    category: $Enums.LogCategory
    action: string
    message: string
    metadata: JsonValue | null
    userId: string | null
    ipAddress: string | null
    userAgent: string | null
    requestId: string | null
    endpoint: string | null
    method: string | null
    statusCode: number | null
    responseTime: number | null
    createdAt: Date
    _count: SystemLogCountAggregateOutputType | null
    _avg: SystemLogAvgAggregateOutputType | null
    _sum: SystemLogSumAggregateOutputType | null
    _min: SystemLogMinAggregateOutputType | null
    _max: SystemLogMaxAggregateOutputType | null
  }

  type GetSystemLogGroupByPayload<T extends SystemLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemLogGroupByOutputType[P]>
            : GetScalarType<T[P], SystemLogGroupByOutputType[P]>
        }
      >
    >


  export type SystemLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    category?: boolean
    action?: boolean
    message?: boolean
    metadata?: boolean
    userId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    requestId?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    responseTime?: boolean
    createdAt?: boolean
    user?: boolean | SystemLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["systemLog"]>

  export type SystemLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    category?: boolean
    action?: boolean
    message?: boolean
    metadata?: boolean
    userId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    requestId?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    responseTime?: boolean
    createdAt?: boolean
    user?: boolean | SystemLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["systemLog"]>

  export type SystemLogSelectScalar = {
    id?: boolean
    level?: boolean
    category?: boolean
    action?: boolean
    message?: boolean
    metadata?: boolean
    userId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    requestId?: boolean
    endpoint?: boolean
    method?: boolean
    statusCode?: boolean
    responseTime?: boolean
    createdAt?: boolean
  }

  export type SystemLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SystemLog$userArgs<ExtArgs>
  }
  export type SystemLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SystemLog$userArgs<ExtArgs>
  }

  export type $SystemLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      level: $Enums.LogLevel
      category: $Enums.LogCategory
      action: string
      message: string
      metadata: Prisma.JsonValue | null
      userId: string | null
      ipAddress: string | null
      userAgent: string | null
      requestId: string | null
      endpoint: string | null
      method: string | null
      statusCode: number | null
      responseTime: number | null
      createdAt: Date
    }, ExtArgs["result"]["systemLog"]>
    composites: {}
  }

  type SystemLogGetPayload<S extends boolean | null | undefined | SystemLogDefaultArgs> = $Result.GetResult<Prisma.$SystemLogPayload, S>

  type SystemLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemLogCountAggregateInputType | true
    }

  export interface SystemLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemLog'], meta: { name: 'SystemLog' } }
    /**
     * Find zero or one SystemLog that matches the filter.
     * @param {SystemLogFindUniqueArgs} args - Arguments to find a SystemLog
     * @example
     * // Get one SystemLog
     * const systemLog = await prisma.systemLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemLogFindUniqueArgs>(args: SelectSubset<T, SystemLogFindUniqueArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemLogFindUniqueOrThrowArgs} args - Arguments to find a SystemLog
     * @example
     * // Get one SystemLog
     * const systemLog = await prisma.systemLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemLogFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogFindFirstArgs} args - Arguments to find a SystemLog
     * @example
     * // Get one SystemLog
     * const systemLog = await prisma.systemLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemLogFindFirstArgs>(args?: SelectSubset<T, SystemLogFindFirstArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogFindFirstOrThrowArgs} args - Arguments to find a SystemLog
     * @example
     * // Get one SystemLog
     * const systemLog = await prisma.systemLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemLogFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemLogs
     * const systemLogs = await prisma.systemLog.findMany()
     * 
     * // Get first 10 SystemLogs
     * const systemLogs = await prisma.systemLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemLogWithIdOnly = await prisma.systemLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemLogFindManyArgs>(args?: SelectSubset<T, SystemLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemLog.
     * @param {SystemLogCreateArgs} args - Arguments to create a SystemLog.
     * @example
     * // Create one SystemLog
     * const SystemLog = await prisma.systemLog.create({
     *   data: {
     *     // ... data to create a SystemLog
     *   }
     * })
     * 
     */
    create<T extends SystemLogCreateArgs>(args: SelectSubset<T, SystemLogCreateArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemLogs.
     * @param {SystemLogCreateManyArgs} args - Arguments to create many SystemLogs.
     * @example
     * // Create many SystemLogs
     * const systemLog = await prisma.systemLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemLogCreateManyArgs>(args?: SelectSubset<T, SystemLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemLogs and returns the data saved in the database.
     * @param {SystemLogCreateManyAndReturnArgs} args - Arguments to create many SystemLogs.
     * @example
     * // Create many SystemLogs
     * const systemLog = await prisma.systemLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemLogs and only return the `id`
     * const systemLogWithIdOnly = await prisma.systemLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemLogCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SystemLog.
     * @param {SystemLogDeleteArgs} args - Arguments to delete one SystemLog.
     * @example
     * // Delete one SystemLog
     * const SystemLog = await prisma.systemLog.delete({
     *   where: {
     *     // ... filter to delete one SystemLog
     *   }
     * })
     * 
     */
    delete<T extends SystemLogDeleteArgs>(args: SelectSubset<T, SystemLogDeleteArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemLog.
     * @param {SystemLogUpdateArgs} args - Arguments to update one SystemLog.
     * @example
     * // Update one SystemLog
     * const systemLog = await prisma.systemLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemLogUpdateArgs>(args: SelectSubset<T, SystemLogUpdateArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemLogs.
     * @param {SystemLogDeleteManyArgs} args - Arguments to filter SystemLogs to delete.
     * @example
     * // Delete a few SystemLogs
     * const { count } = await prisma.systemLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemLogDeleteManyArgs>(args?: SelectSubset<T, SystemLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemLogs
     * const systemLog = await prisma.systemLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemLogUpdateManyArgs>(args: SelectSubset<T, SystemLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemLog.
     * @param {SystemLogUpsertArgs} args - Arguments to update or create a SystemLog.
     * @example
     * // Update or create a SystemLog
     * const systemLog = await prisma.systemLog.upsert({
     *   create: {
     *     // ... data to create a SystemLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemLog we want to update
     *   }
     * })
     */
    upsert<T extends SystemLogUpsertArgs>(args: SelectSubset<T, SystemLogUpsertArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogCountArgs} args - Arguments to filter SystemLogs to count.
     * @example
     * // Count the number of SystemLogs
     * const count = await prisma.systemLog.count({
     *   where: {
     *     // ... the filter for the SystemLogs we want to count
     *   }
     * })
    **/
    count<T extends SystemLogCountArgs>(
      args?: Subset<T, SystemLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemLogAggregateArgs>(args: Subset<T, SystemLogAggregateArgs>): Prisma.PrismaPromise<GetSystemLogAggregateType<T>>

    /**
     * Group by SystemLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemLogGroupByArgs['orderBy'] }
        : { orderBy?: SystemLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemLog model
   */
  readonly fields: SystemLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends SystemLog$userArgs<ExtArgs> = {}>(args?: Subset<T, SystemLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemLog model
   */ 
  interface SystemLogFieldRefs {
    readonly id: FieldRef<"SystemLog", 'String'>
    readonly level: FieldRef<"SystemLog", 'LogLevel'>
    readonly category: FieldRef<"SystemLog", 'LogCategory'>
    readonly action: FieldRef<"SystemLog", 'String'>
    readonly message: FieldRef<"SystemLog", 'String'>
    readonly metadata: FieldRef<"SystemLog", 'Json'>
    readonly userId: FieldRef<"SystemLog", 'String'>
    readonly ipAddress: FieldRef<"SystemLog", 'String'>
    readonly userAgent: FieldRef<"SystemLog", 'String'>
    readonly requestId: FieldRef<"SystemLog", 'String'>
    readonly endpoint: FieldRef<"SystemLog", 'String'>
    readonly method: FieldRef<"SystemLog", 'String'>
    readonly statusCode: FieldRef<"SystemLog", 'Int'>
    readonly responseTime: FieldRef<"SystemLog", 'Int'>
    readonly createdAt: FieldRef<"SystemLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemLog findUnique
   */
  export type SystemLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * Filter, which SystemLog to fetch.
     */
    where: SystemLogWhereUniqueInput
  }

  /**
   * SystemLog findUniqueOrThrow
   */
  export type SystemLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * Filter, which SystemLog to fetch.
     */
    where: SystemLogWhereUniqueInput
  }

  /**
   * SystemLog findFirst
   */
  export type SystemLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * Filter, which SystemLog to fetch.
     */
    where?: SystemLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLogs to fetch.
     */
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemLogs.
     */
    cursor?: SystemLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemLogs.
     */
    distinct?: SystemLogScalarFieldEnum | SystemLogScalarFieldEnum[]
  }

  /**
   * SystemLog findFirstOrThrow
   */
  export type SystemLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * Filter, which SystemLog to fetch.
     */
    where?: SystemLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLogs to fetch.
     */
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemLogs.
     */
    cursor?: SystemLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemLogs.
     */
    distinct?: SystemLogScalarFieldEnum | SystemLogScalarFieldEnum[]
  }

  /**
   * SystemLog findMany
   */
  export type SystemLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * Filter, which SystemLogs to fetch.
     */
    where?: SystemLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLogs to fetch.
     */
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemLogs.
     */
    cursor?: SystemLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLogs.
     */
    skip?: number
    distinct?: SystemLogScalarFieldEnum | SystemLogScalarFieldEnum[]
  }

  /**
   * SystemLog create
   */
  export type SystemLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * The data needed to create a SystemLog.
     */
    data: XOR<SystemLogCreateInput, SystemLogUncheckedCreateInput>
  }

  /**
   * SystemLog createMany
   */
  export type SystemLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemLogs.
     */
    data: SystemLogCreateManyInput | SystemLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemLog createManyAndReturn
   */
  export type SystemLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SystemLogs.
     */
    data: SystemLogCreateManyInput | SystemLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SystemLog update
   */
  export type SystemLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * The data needed to update a SystemLog.
     */
    data: XOR<SystemLogUpdateInput, SystemLogUncheckedUpdateInput>
    /**
     * Choose, which SystemLog to update.
     */
    where: SystemLogWhereUniqueInput
  }

  /**
   * SystemLog updateMany
   */
  export type SystemLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemLogs.
     */
    data: XOR<SystemLogUpdateManyMutationInput, SystemLogUncheckedUpdateManyInput>
    /**
     * Filter which SystemLogs to update
     */
    where?: SystemLogWhereInput
  }

  /**
   * SystemLog upsert
   */
  export type SystemLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * The filter to search for the SystemLog to update in case it exists.
     */
    where: SystemLogWhereUniqueInput
    /**
     * In case the SystemLog found by the `where` argument doesn't exist, create a new SystemLog with this data.
     */
    create: XOR<SystemLogCreateInput, SystemLogUncheckedCreateInput>
    /**
     * In case the SystemLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemLogUpdateInput, SystemLogUncheckedUpdateInput>
  }

  /**
   * SystemLog delete
   */
  export type SystemLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * Filter which SystemLog to delete.
     */
    where: SystemLogWhereUniqueInput
  }

  /**
   * SystemLog deleteMany
   */
  export type SystemLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemLogs to delete
     */
    where?: SystemLogWhereInput
  }

  /**
   * SystemLog.user
   */
  export type SystemLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SystemLog without action
   */
  export type SystemLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
  }


  /**
   * Model DexPair
   */

  export type AggregateDexPair = {
    _count: DexPairCountAggregateOutputType | null
    _avg: DexPairAvgAggregateOutputType | null
    _sum: DexPairSumAggregateOutputType | null
    _min: DexPairMinAggregateOutputType | null
    _max: DexPairMaxAggregateOutputType | null
  }

  export type DexPairAvgAggregateOutputType = {
    fee: number | null
    maxSlippage: number | null
  }

  export type DexPairSumAggregateOutputType = {
    fee: number | null
    maxSlippage: number | null
  }

  export type DexPairMinAggregateOutputType = {
    id: string | null
    tokenA: string | null
    tokenB: string | null
    poolAddress: string | null
    reserveA: string | null
    reserveB: string | null
    fee: number | null
    isActive: boolean | null
    isRegulated: boolean | null
    warmupEndsAt: Date | null
    maxSlippage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DexPairMaxAggregateOutputType = {
    id: string | null
    tokenA: string | null
    tokenB: string | null
    poolAddress: string | null
    reserveA: string | null
    reserveB: string | null
    fee: number | null
    isActive: boolean | null
    isRegulated: boolean | null
    warmupEndsAt: Date | null
    maxSlippage: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DexPairCountAggregateOutputType = {
    id: number
    tokenA: number
    tokenB: number
    poolAddress: number
    reserveA: number
    reserveB: number
    fee: number
    isActive: number
    isRegulated: number
    warmupEndsAt: number
    maxSlippage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DexPairAvgAggregateInputType = {
    fee?: true
    maxSlippage?: true
  }

  export type DexPairSumAggregateInputType = {
    fee?: true
    maxSlippage?: true
  }

  export type DexPairMinAggregateInputType = {
    id?: true
    tokenA?: true
    tokenB?: true
    poolAddress?: true
    reserveA?: true
    reserveB?: true
    fee?: true
    isActive?: true
    isRegulated?: true
    warmupEndsAt?: true
    maxSlippage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DexPairMaxAggregateInputType = {
    id?: true
    tokenA?: true
    tokenB?: true
    poolAddress?: true
    reserveA?: true
    reserveB?: true
    fee?: true
    isActive?: true
    isRegulated?: true
    warmupEndsAt?: true
    maxSlippage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DexPairCountAggregateInputType = {
    id?: true
    tokenA?: true
    tokenB?: true
    poolAddress?: true
    reserveA?: true
    reserveB?: true
    fee?: true
    isActive?: true
    isRegulated?: true
    warmupEndsAt?: true
    maxSlippage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DexPairAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DexPair to aggregate.
     */
    where?: DexPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DexPairs to fetch.
     */
    orderBy?: DexPairOrderByWithRelationInput | DexPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DexPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DexPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DexPairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DexPairs
    **/
    _count?: true | DexPairCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DexPairAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DexPairSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DexPairMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DexPairMaxAggregateInputType
  }

  export type GetDexPairAggregateType<T extends DexPairAggregateArgs> = {
        [P in keyof T & keyof AggregateDexPair]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDexPair[P]>
      : GetScalarType<T[P], AggregateDexPair[P]>
  }




  export type DexPairGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DexPairWhereInput
    orderBy?: DexPairOrderByWithAggregationInput | DexPairOrderByWithAggregationInput[]
    by: DexPairScalarFieldEnum[] | DexPairScalarFieldEnum
    having?: DexPairScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DexPairCountAggregateInputType | true
    _avg?: DexPairAvgAggregateInputType
    _sum?: DexPairSumAggregateInputType
    _min?: DexPairMinAggregateInputType
    _max?: DexPairMaxAggregateInputType
  }

  export type DexPairGroupByOutputType = {
    id: string
    tokenA: string
    tokenB: string
    poolAddress: string | null
    reserveA: string | null
    reserveB: string | null
    fee: number
    isActive: boolean
    isRegulated: boolean
    warmupEndsAt: Date | null
    maxSlippage: number
    createdAt: Date
    updatedAt: Date
    _count: DexPairCountAggregateOutputType | null
    _avg: DexPairAvgAggregateOutputType | null
    _sum: DexPairSumAggregateOutputType | null
    _min: DexPairMinAggregateOutputType | null
    _max: DexPairMaxAggregateOutputType | null
  }

  type GetDexPairGroupByPayload<T extends DexPairGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DexPairGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DexPairGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DexPairGroupByOutputType[P]>
            : GetScalarType<T[P], DexPairGroupByOutputType[P]>
        }
      >
    >


  export type DexPairSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tokenA?: boolean
    tokenB?: boolean
    poolAddress?: boolean
    reserveA?: boolean
    reserveB?: boolean
    fee?: boolean
    isActive?: boolean
    isRegulated?: boolean
    warmupEndsAt?: boolean
    maxSlippage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dexPair"]>

  export type DexPairSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tokenA?: boolean
    tokenB?: boolean
    poolAddress?: boolean
    reserveA?: boolean
    reserveB?: boolean
    fee?: boolean
    isActive?: boolean
    isRegulated?: boolean
    warmupEndsAt?: boolean
    maxSlippage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dexPair"]>

  export type DexPairSelectScalar = {
    id?: boolean
    tokenA?: boolean
    tokenB?: boolean
    poolAddress?: boolean
    reserveA?: boolean
    reserveB?: boolean
    fee?: boolean
    isActive?: boolean
    isRegulated?: boolean
    warmupEndsAt?: boolean
    maxSlippage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $DexPairPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DexPair"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tokenA: string
      tokenB: string
      poolAddress: string | null
      reserveA: string | null
      reserveB: string | null
      fee: number
      isActive: boolean
      isRegulated: boolean
      warmupEndsAt: Date | null
      maxSlippage: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dexPair"]>
    composites: {}
  }

  type DexPairGetPayload<S extends boolean | null | undefined | DexPairDefaultArgs> = $Result.GetResult<Prisma.$DexPairPayload, S>

  type DexPairCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DexPairFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DexPairCountAggregateInputType | true
    }

  export interface DexPairDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DexPair'], meta: { name: 'DexPair' } }
    /**
     * Find zero or one DexPair that matches the filter.
     * @param {DexPairFindUniqueArgs} args - Arguments to find a DexPair
     * @example
     * // Get one DexPair
     * const dexPair = await prisma.dexPair.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DexPairFindUniqueArgs>(args: SelectSubset<T, DexPairFindUniqueArgs<ExtArgs>>): Prisma__DexPairClient<$Result.GetResult<Prisma.$DexPairPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DexPair that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DexPairFindUniqueOrThrowArgs} args - Arguments to find a DexPair
     * @example
     * // Get one DexPair
     * const dexPair = await prisma.dexPair.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DexPairFindUniqueOrThrowArgs>(args: SelectSubset<T, DexPairFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DexPairClient<$Result.GetResult<Prisma.$DexPairPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DexPair that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DexPairFindFirstArgs} args - Arguments to find a DexPair
     * @example
     * // Get one DexPair
     * const dexPair = await prisma.dexPair.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DexPairFindFirstArgs>(args?: SelectSubset<T, DexPairFindFirstArgs<ExtArgs>>): Prisma__DexPairClient<$Result.GetResult<Prisma.$DexPairPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DexPair that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DexPairFindFirstOrThrowArgs} args - Arguments to find a DexPair
     * @example
     * // Get one DexPair
     * const dexPair = await prisma.dexPair.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DexPairFindFirstOrThrowArgs>(args?: SelectSubset<T, DexPairFindFirstOrThrowArgs<ExtArgs>>): Prisma__DexPairClient<$Result.GetResult<Prisma.$DexPairPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DexPairs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DexPairFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DexPairs
     * const dexPairs = await prisma.dexPair.findMany()
     * 
     * // Get first 10 DexPairs
     * const dexPairs = await prisma.dexPair.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dexPairWithIdOnly = await prisma.dexPair.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DexPairFindManyArgs>(args?: SelectSubset<T, DexPairFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DexPairPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DexPair.
     * @param {DexPairCreateArgs} args - Arguments to create a DexPair.
     * @example
     * // Create one DexPair
     * const DexPair = await prisma.dexPair.create({
     *   data: {
     *     // ... data to create a DexPair
     *   }
     * })
     * 
     */
    create<T extends DexPairCreateArgs>(args: SelectSubset<T, DexPairCreateArgs<ExtArgs>>): Prisma__DexPairClient<$Result.GetResult<Prisma.$DexPairPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DexPairs.
     * @param {DexPairCreateManyArgs} args - Arguments to create many DexPairs.
     * @example
     * // Create many DexPairs
     * const dexPair = await prisma.dexPair.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DexPairCreateManyArgs>(args?: SelectSubset<T, DexPairCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DexPairs and returns the data saved in the database.
     * @param {DexPairCreateManyAndReturnArgs} args - Arguments to create many DexPairs.
     * @example
     * // Create many DexPairs
     * const dexPair = await prisma.dexPair.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DexPairs and only return the `id`
     * const dexPairWithIdOnly = await prisma.dexPair.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DexPairCreateManyAndReturnArgs>(args?: SelectSubset<T, DexPairCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DexPairPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DexPair.
     * @param {DexPairDeleteArgs} args - Arguments to delete one DexPair.
     * @example
     * // Delete one DexPair
     * const DexPair = await prisma.dexPair.delete({
     *   where: {
     *     // ... filter to delete one DexPair
     *   }
     * })
     * 
     */
    delete<T extends DexPairDeleteArgs>(args: SelectSubset<T, DexPairDeleteArgs<ExtArgs>>): Prisma__DexPairClient<$Result.GetResult<Prisma.$DexPairPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DexPair.
     * @param {DexPairUpdateArgs} args - Arguments to update one DexPair.
     * @example
     * // Update one DexPair
     * const dexPair = await prisma.dexPair.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DexPairUpdateArgs>(args: SelectSubset<T, DexPairUpdateArgs<ExtArgs>>): Prisma__DexPairClient<$Result.GetResult<Prisma.$DexPairPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DexPairs.
     * @param {DexPairDeleteManyArgs} args - Arguments to filter DexPairs to delete.
     * @example
     * // Delete a few DexPairs
     * const { count } = await prisma.dexPair.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DexPairDeleteManyArgs>(args?: SelectSubset<T, DexPairDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DexPairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DexPairUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DexPairs
     * const dexPair = await prisma.dexPair.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DexPairUpdateManyArgs>(args: SelectSubset<T, DexPairUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DexPair.
     * @param {DexPairUpsertArgs} args - Arguments to update or create a DexPair.
     * @example
     * // Update or create a DexPair
     * const dexPair = await prisma.dexPair.upsert({
     *   create: {
     *     // ... data to create a DexPair
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DexPair we want to update
     *   }
     * })
     */
    upsert<T extends DexPairUpsertArgs>(args: SelectSubset<T, DexPairUpsertArgs<ExtArgs>>): Prisma__DexPairClient<$Result.GetResult<Prisma.$DexPairPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DexPairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DexPairCountArgs} args - Arguments to filter DexPairs to count.
     * @example
     * // Count the number of DexPairs
     * const count = await prisma.dexPair.count({
     *   where: {
     *     // ... the filter for the DexPairs we want to count
     *   }
     * })
    **/
    count<T extends DexPairCountArgs>(
      args?: Subset<T, DexPairCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DexPairCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DexPair.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DexPairAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DexPairAggregateArgs>(args: Subset<T, DexPairAggregateArgs>): Prisma.PrismaPromise<GetDexPairAggregateType<T>>

    /**
     * Group by DexPair.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DexPairGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DexPairGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DexPairGroupByArgs['orderBy'] }
        : { orderBy?: DexPairGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DexPairGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDexPairGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DexPair model
   */
  readonly fields: DexPairFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DexPair.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DexPairClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DexPair model
   */ 
  interface DexPairFieldRefs {
    readonly id: FieldRef<"DexPair", 'String'>
    readonly tokenA: FieldRef<"DexPair", 'String'>
    readonly tokenB: FieldRef<"DexPair", 'String'>
    readonly poolAddress: FieldRef<"DexPair", 'String'>
    readonly reserveA: FieldRef<"DexPair", 'String'>
    readonly reserveB: FieldRef<"DexPair", 'String'>
    readonly fee: FieldRef<"DexPair", 'Float'>
    readonly isActive: FieldRef<"DexPair", 'Boolean'>
    readonly isRegulated: FieldRef<"DexPair", 'Boolean'>
    readonly warmupEndsAt: FieldRef<"DexPair", 'DateTime'>
    readonly maxSlippage: FieldRef<"DexPair", 'Float'>
    readonly createdAt: FieldRef<"DexPair", 'DateTime'>
    readonly updatedAt: FieldRef<"DexPair", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DexPair findUnique
   */
  export type DexPairFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DexPair
     */
    select?: DexPairSelect<ExtArgs> | null
    /**
     * Filter, which DexPair to fetch.
     */
    where: DexPairWhereUniqueInput
  }

  /**
   * DexPair findUniqueOrThrow
   */
  export type DexPairFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DexPair
     */
    select?: DexPairSelect<ExtArgs> | null
    /**
     * Filter, which DexPair to fetch.
     */
    where: DexPairWhereUniqueInput
  }

  /**
   * DexPair findFirst
   */
  export type DexPairFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DexPair
     */
    select?: DexPairSelect<ExtArgs> | null
    /**
     * Filter, which DexPair to fetch.
     */
    where?: DexPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DexPairs to fetch.
     */
    orderBy?: DexPairOrderByWithRelationInput | DexPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DexPairs.
     */
    cursor?: DexPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DexPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DexPairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DexPairs.
     */
    distinct?: DexPairScalarFieldEnum | DexPairScalarFieldEnum[]
  }

  /**
   * DexPair findFirstOrThrow
   */
  export type DexPairFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DexPair
     */
    select?: DexPairSelect<ExtArgs> | null
    /**
     * Filter, which DexPair to fetch.
     */
    where?: DexPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DexPairs to fetch.
     */
    orderBy?: DexPairOrderByWithRelationInput | DexPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DexPairs.
     */
    cursor?: DexPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DexPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DexPairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DexPairs.
     */
    distinct?: DexPairScalarFieldEnum | DexPairScalarFieldEnum[]
  }

  /**
   * DexPair findMany
   */
  export type DexPairFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DexPair
     */
    select?: DexPairSelect<ExtArgs> | null
    /**
     * Filter, which DexPairs to fetch.
     */
    where?: DexPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DexPairs to fetch.
     */
    orderBy?: DexPairOrderByWithRelationInput | DexPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DexPairs.
     */
    cursor?: DexPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DexPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DexPairs.
     */
    skip?: number
    distinct?: DexPairScalarFieldEnum | DexPairScalarFieldEnum[]
  }

  /**
   * DexPair create
   */
  export type DexPairCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DexPair
     */
    select?: DexPairSelect<ExtArgs> | null
    /**
     * The data needed to create a DexPair.
     */
    data: XOR<DexPairCreateInput, DexPairUncheckedCreateInput>
  }

  /**
   * DexPair createMany
   */
  export type DexPairCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DexPairs.
     */
    data: DexPairCreateManyInput | DexPairCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DexPair createManyAndReturn
   */
  export type DexPairCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DexPair
     */
    select?: DexPairSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DexPairs.
     */
    data: DexPairCreateManyInput | DexPairCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DexPair update
   */
  export type DexPairUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DexPair
     */
    select?: DexPairSelect<ExtArgs> | null
    /**
     * The data needed to update a DexPair.
     */
    data: XOR<DexPairUpdateInput, DexPairUncheckedUpdateInput>
    /**
     * Choose, which DexPair to update.
     */
    where: DexPairWhereUniqueInput
  }

  /**
   * DexPair updateMany
   */
  export type DexPairUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DexPairs.
     */
    data: XOR<DexPairUpdateManyMutationInput, DexPairUncheckedUpdateManyInput>
    /**
     * Filter which DexPairs to update
     */
    where?: DexPairWhereInput
  }

  /**
   * DexPair upsert
   */
  export type DexPairUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DexPair
     */
    select?: DexPairSelect<ExtArgs> | null
    /**
     * The filter to search for the DexPair to update in case it exists.
     */
    where: DexPairWhereUniqueInput
    /**
     * In case the DexPair found by the `where` argument doesn't exist, create a new DexPair with this data.
     */
    create: XOR<DexPairCreateInput, DexPairUncheckedCreateInput>
    /**
     * In case the DexPair was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DexPairUpdateInput, DexPairUncheckedUpdateInput>
  }

  /**
   * DexPair delete
   */
  export type DexPairDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DexPair
     */
    select?: DexPairSelect<ExtArgs> | null
    /**
     * Filter which DexPair to delete.
     */
    where: DexPairWhereUniqueInput
  }

  /**
   * DexPair deleteMany
   */
  export type DexPairDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DexPairs to delete
     */
    where?: DexPairWhereInput
  }

  /**
   * DexPair without action
   */
  export type DexPairDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DexPair
     */
    select?: DexPairSelect<ExtArgs> | null
  }


  /**
   * Model RateLimitRecord
   */

  export type AggregateRateLimitRecord = {
    _count: RateLimitRecordCountAggregateOutputType | null
    _avg: RateLimitRecordAvgAggregateOutputType | null
    _sum: RateLimitRecordSumAggregateOutputType | null
    _min: RateLimitRecordMinAggregateOutputType | null
    _max: RateLimitRecordMaxAggregateOutputType | null
  }

  export type RateLimitRecordAvgAggregateOutputType = {
    requestCount: number | null
  }

  export type RateLimitRecordSumAggregateOutputType = {
    requestCount: number | null
  }

  export type RateLimitRecordMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    endpoint: string | null
    windowStart: Date | null
    requestCount: number | null
    createdAt: Date | null
  }

  export type RateLimitRecordMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    endpoint: string | null
    windowStart: Date | null
    requestCount: number | null
    createdAt: Date | null
  }

  export type RateLimitRecordCountAggregateOutputType = {
    id: number
    identifier: number
    endpoint: number
    windowStart: number
    requestCount: number
    createdAt: number
    _all: number
  }


  export type RateLimitRecordAvgAggregateInputType = {
    requestCount?: true
  }

  export type RateLimitRecordSumAggregateInputType = {
    requestCount?: true
  }

  export type RateLimitRecordMinAggregateInputType = {
    id?: true
    identifier?: true
    endpoint?: true
    windowStart?: true
    requestCount?: true
    createdAt?: true
  }

  export type RateLimitRecordMaxAggregateInputType = {
    id?: true
    identifier?: true
    endpoint?: true
    windowStart?: true
    requestCount?: true
    createdAt?: true
  }

  export type RateLimitRecordCountAggregateInputType = {
    id?: true
    identifier?: true
    endpoint?: true
    windowStart?: true
    requestCount?: true
    createdAt?: true
    _all?: true
  }

  export type RateLimitRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RateLimitRecord to aggregate.
     */
    where?: RateLimitRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RateLimitRecords to fetch.
     */
    orderBy?: RateLimitRecordOrderByWithRelationInput | RateLimitRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RateLimitRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RateLimitRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RateLimitRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RateLimitRecords
    **/
    _count?: true | RateLimitRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RateLimitRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RateLimitRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RateLimitRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RateLimitRecordMaxAggregateInputType
  }

  export type GetRateLimitRecordAggregateType<T extends RateLimitRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateRateLimitRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRateLimitRecord[P]>
      : GetScalarType<T[P], AggregateRateLimitRecord[P]>
  }




  export type RateLimitRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RateLimitRecordWhereInput
    orderBy?: RateLimitRecordOrderByWithAggregationInput | RateLimitRecordOrderByWithAggregationInput[]
    by: RateLimitRecordScalarFieldEnum[] | RateLimitRecordScalarFieldEnum
    having?: RateLimitRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RateLimitRecordCountAggregateInputType | true
    _avg?: RateLimitRecordAvgAggregateInputType
    _sum?: RateLimitRecordSumAggregateInputType
    _min?: RateLimitRecordMinAggregateInputType
    _max?: RateLimitRecordMaxAggregateInputType
  }

  export type RateLimitRecordGroupByOutputType = {
    id: string
    identifier: string
    endpoint: string
    windowStart: Date
    requestCount: number
    createdAt: Date
    _count: RateLimitRecordCountAggregateOutputType | null
    _avg: RateLimitRecordAvgAggregateOutputType | null
    _sum: RateLimitRecordSumAggregateOutputType | null
    _min: RateLimitRecordMinAggregateOutputType | null
    _max: RateLimitRecordMaxAggregateOutputType | null
  }

  type GetRateLimitRecordGroupByPayload<T extends RateLimitRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RateLimitRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RateLimitRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RateLimitRecordGroupByOutputType[P]>
            : GetScalarType<T[P], RateLimitRecordGroupByOutputType[P]>
        }
      >
    >


  export type RateLimitRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    endpoint?: boolean
    windowStart?: boolean
    requestCount?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["rateLimitRecord"]>

  export type RateLimitRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    endpoint?: boolean
    windowStart?: boolean
    requestCount?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["rateLimitRecord"]>

  export type RateLimitRecordSelectScalar = {
    id?: boolean
    identifier?: boolean
    endpoint?: boolean
    windowStart?: boolean
    requestCount?: boolean
    createdAt?: boolean
  }


  export type $RateLimitRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RateLimitRecord"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      endpoint: string
      windowStart: Date
      requestCount: number
      createdAt: Date
    }, ExtArgs["result"]["rateLimitRecord"]>
    composites: {}
  }

  type RateLimitRecordGetPayload<S extends boolean | null | undefined | RateLimitRecordDefaultArgs> = $Result.GetResult<Prisma.$RateLimitRecordPayload, S>

  type RateLimitRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RateLimitRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RateLimitRecordCountAggregateInputType | true
    }

  export interface RateLimitRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RateLimitRecord'], meta: { name: 'RateLimitRecord' } }
    /**
     * Find zero or one RateLimitRecord that matches the filter.
     * @param {RateLimitRecordFindUniqueArgs} args - Arguments to find a RateLimitRecord
     * @example
     * // Get one RateLimitRecord
     * const rateLimitRecord = await prisma.rateLimitRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RateLimitRecordFindUniqueArgs>(args: SelectSubset<T, RateLimitRecordFindUniqueArgs<ExtArgs>>): Prisma__RateLimitRecordClient<$Result.GetResult<Prisma.$RateLimitRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RateLimitRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RateLimitRecordFindUniqueOrThrowArgs} args - Arguments to find a RateLimitRecord
     * @example
     * // Get one RateLimitRecord
     * const rateLimitRecord = await prisma.rateLimitRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RateLimitRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, RateLimitRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RateLimitRecordClient<$Result.GetResult<Prisma.$RateLimitRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RateLimitRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitRecordFindFirstArgs} args - Arguments to find a RateLimitRecord
     * @example
     * // Get one RateLimitRecord
     * const rateLimitRecord = await prisma.rateLimitRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RateLimitRecordFindFirstArgs>(args?: SelectSubset<T, RateLimitRecordFindFirstArgs<ExtArgs>>): Prisma__RateLimitRecordClient<$Result.GetResult<Prisma.$RateLimitRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RateLimitRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitRecordFindFirstOrThrowArgs} args - Arguments to find a RateLimitRecord
     * @example
     * // Get one RateLimitRecord
     * const rateLimitRecord = await prisma.rateLimitRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RateLimitRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, RateLimitRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__RateLimitRecordClient<$Result.GetResult<Prisma.$RateLimitRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RateLimitRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RateLimitRecords
     * const rateLimitRecords = await prisma.rateLimitRecord.findMany()
     * 
     * // Get first 10 RateLimitRecords
     * const rateLimitRecords = await prisma.rateLimitRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rateLimitRecordWithIdOnly = await prisma.rateLimitRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RateLimitRecordFindManyArgs>(args?: SelectSubset<T, RateLimitRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RateLimitRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RateLimitRecord.
     * @param {RateLimitRecordCreateArgs} args - Arguments to create a RateLimitRecord.
     * @example
     * // Create one RateLimitRecord
     * const RateLimitRecord = await prisma.rateLimitRecord.create({
     *   data: {
     *     // ... data to create a RateLimitRecord
     *   }
     * })
     * 
     */
    create<T extends RateLimitRecordCreateArgs>(args: SelectSubset<T, RateLimitRecordCreateArgs<ExtArgs>>): Prisma__RateLimitRecordClient<$Result.GetResult<Prisma.$RateLimitRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RateLimitRecords.
     * @param {RateLimitRecordCreateManyArgs} args - Arguments to create many RateLimitRecords.
     * @example
     * // Create many RateLimitRecords
     * const rateLimitRecord = await prisma.rateLimitRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RateLimitRecordCreateManyArgs>(args?: SelectSubset<T, RateLimitRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RateLimitRecords and returns the data saved in the database.
     * @param {RateLimitRecordCreateManyAndReturnArgs} args - Arguments to create many RateLimitRecords.
     * @example
     * // Create many RateLimitRecords
     * const rateLimitRecord = await prisma.rateLimitRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RateLimitRecords and only return the `id`
     * const rateLimitRecordWithIdOnly = await prisma.rateLimitRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RateLimitRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, RateLimitRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RateLimitRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RateLimitRecord.
     * @param {RateLimitRecordDeleteArgs} args - Arguments to delete one RateLimitRecord.
     * @example
     * // Delete one RateLimitRecord
     * const RateLimitRecord = await prisma.rateLimitRecord.delete({
     *   where: {
     *     // ... filter to delete one RateLimitRecord
     *   }
     * })
     * 
     */
    delete<T extends RateLimitRecordDeleteArgs>(args: SelectSubset<T, RateLimitRecordDeleteArgs<ExtArgs>>): Prisma__RateLimitRecordClient<$Result.GetResult<Prisma.$RateLimitRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RateLimitRecord.
     * @param {RateLimitRecordUpdateArgs} args - Arguments to update one RateLimitRecord.
     * @example
     * // Update one RateLimitRecord
     * const rateLimitRecord = await prisma.rateLimitRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RateLimitRecordUpdateArgs>(args: SelectSubset<T, RateLimitRecordUpdateArgs<ExtArgs>>): Prisma__RateLimitRecordClient<$Result.GetResult<Prisma.$RateLimitRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RateLimitRecords.
     * @param {RateLimitRecordDeleteManyArgs} args - Arguments to filter RateLimitRecords to delete.
     * @example
     * // Delete a few RateLimitRecords
     * const { count } = await prisma.rateLimitRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RateLimitRecordDeleteManyArgs>(args?: SelectSubset<T, RateLimitRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RateLimitRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RateLimitRecords
     * const rateLimitRecord = await prisma.rateLimitRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RateLimitRecordUpdateManyArgs>(args: SelectSubset<T, RateLimitRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RateLimitRecord.
     * @param {RateLimitRecordUpsertArgs} args - Arguments to update or create a RateLimitRecord.
     * @example
     * // Update or create a RateLimitRecord
     * const rateLimitRecord = await prisma.rateLimitRecord.upsert({
     *   create: {
     *     // ... data to create a RateLimitRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RateLimitRecord we want to update
     *   }
     * })
     */
    upsert<T extends RateLimitRecordUpsertArgs>(args: SelectSubset<T, RateLimitRecordUpsertArgs<ExtArgs>>): Prisma__RateLimitRecordClient<$Result.GetResult<Prisma.$RateLimitRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RateLimitRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitRecordCountArgs} args - Arguments to filter RateLimitRecords to count.
     * @example
     * // Count the number of RateLimitRecords
     * const count = await prisma.rateLimitRecord.count({
     *   where: {
     *     // ... the filter for the RateLimitRecords we want to count
     *   }
     * })
    **/
    count<T extends RateLimitRecordCountArgs>(
      args?: Subset<T, RateLimitRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RateLimitRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RateLimitRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RateLimitRecordAggregateArgs>(args: Subset<T, RateLimitRecordAggregateArgs>): Prisma.PrismaPromise<GetRateLimitRecordAggregateType<T>>

    /**
     * Group by RateLimitRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RateLimitRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RateLimitRecordGroupByArgs['orderBy'] }
        : { orderBy?: RateLimitRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RateLimitRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRateLimitRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RateLimitRecord model
   */
  readonly fields: RateLimitRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RateLimitRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RateLimitRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RateLimitRecord model
   */ 
  interface RateLimitRecordFieldRefs {
    readonly id: FieldRef<"RateLimitRecord", 'String'>
    readonly identifier: FieldRef<"RateLimitRecord", 'String'>
    readonly endpoint: FieldRef<"RateLimitRecord", 'String'>
    readonly windowStart: FieldRef<"RateLimitRecord", 'DateTime'>
    readonly requestCount: FieldRef<"RateLimitRecord", 'Int'>
    readonly createdAt: FieldRef<"RateLimitRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RateLimitRecord findUnique
   */
  export type RateLimitRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimitRecord
     */
    select?: RateLimitRecordSelect<ExtArgs> | null
    /**
     * Filter, which RateLimitRecord to fetch.
     */
    where: RateLimitRecordWhereUniqueInput
  }

  /**
   * RateLimitRecord findUniqueOrThrow
   */
  export type RateLimitRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimitRecord
     */
    select?: RateLimitRecordSelect<ExtArgs> | null
    /**
     * Filter, which RateLimitRecord to fetch.
     */
    where: RateLimitRecordWhereUniqueInput
  }

  /**
   * RateLimitRecord findFirst
   */
  export type RateLimitRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimitRecord
     */
    select?: RateLimitRecordSelect<ExtArgs> | null
    /**
     * Filter, which RateLimitRecord to fetch.
     */
    where?: RateLimitRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RateLimitRecords to fetch.
     */
    orderBy?: RateLimitRecordOrderByWithRelationInput | RateLimitRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RateLimitRecords.
     */
    cursor?: RateLimitRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RateLimitRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RateLimitRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RateLimitRecords.
     */
    distinct?: RateLimitRecordScalarFieldEnum | RateLimitRecordScalarFieldEnum[]
  }

  /**
   * RateLimitRecord findFirstOrThrow
   */
  export type RateLimitRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimitRecord
     */
    select?: RateLimitRecordSelect<ExtArgs> | null
    /**
     * Filter, which RateLimitRecord to fetch.
     */
    where?: RateLimitRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RateLimitRecords to fetch.
     */
    orderBy?: RateLimitRecordOrderByWithRelationInput | RateLimitRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RateLimitRecords.
     */
    cursor?: RateLimitRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RateLimitRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RateLimitRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RateLimitRecords.
     */
    distinct?: RateLimitRecordScalarFieldEnum | RateLimitRecordScalarFieldEnum[]
  }

  /**
   * RateLimitRecord findMany
   */
  export type RateLimitRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimitRecord
     */
    select?: RateLimitRecordSelect<ExtArgs> | null
    /**
     * Filter, which RateLimitRecords to fetch.
     */
    where?: RateLimitRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RateLimitRecords to fetch.
     */
    orderBy?: RateLimitRecordOrderByWithRelationInput | RateLimitRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RateLimitRecords.
     */
    cursor?: RateLimitRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RateLimitRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RateLimitRecords.
     */
    skip?: number
    distinct?: RateLimitRecordScalarFieldEnum | RateLimitRecordScalarFieldEnum[]
  }

  /**
   * RateLimitRecord create
   */
  export type RateLimitRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimitRecord
     */
    select?: RateLimitRecordSelect<ExtArgs> | null
    /**
     * The data needed to create a RateLimitRecord.
     */
    data: XOR<RateLimitRecordCreateInput, RateLimitRecordUncheckedCreateInput>
  }

  /**
   * RateLimitRecord createMany
   */
  export type RateLimitRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RateLimitRecords.
     */
    data: RateLimitRecordCreateManyInput | RateLimitRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RateLimitRecord createManyAndReturn
   */
  export type RateLimitRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimitRecord
     */
    select?: RateLimitRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RateLimitRecords.
     */
    data: RateLimitRecordCreateManyInput | RateLimitRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RateLimitRecord update
   */
  export type RateLimitRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimitRecord
     */
    select?: RateLimitRecordSelect<ExtArgs> | null
    /**
     * The data needed to update a RateLimitRecord.
     */
    data: XOR<RateLimitRecordUpdateInput, RateLimitRecordUncheckedUpdateInput>
    /**
     * Choose, which RateLimitRecord to update.
     */
    where: RateLimitRecordWhereUniqueInput
  }

  /**
   * RateLimitRecord updateMany
   */
  export type RateLimitRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RateLimitRecords.
     */
    data: XOR<RateLimitRecordUpdateManyMutationInput, RateLimitRecordUncheckedUpdateManyInput>
    /**
     * Filter which RateLimitRecords to update
     */
    where?: RateLimitRecordWhereInput
  }

  /**
   * RateLimitRecord upsert
   */
  export type RateLimitRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimitRecord
     */
    select?: RateLimitRecordSelect<ExtArgs> | null
    /**
     * The filter to search for the RateLimitRecord to update in case it exists.
     */
    where: RateLimitRecordWhereUniqueInput
    /**
     * In case the RateLimitRecord found by the `where` argument doesn't exist, create a new RateLimitRecord with this data.
     */
    create: XOR<RateLimitRecordCreateInput, RateLimitRecordUncheckedCreateInput>
    /**
     * In case the RateLimitRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RateLimitRecordUpdateInput, RateLimitRecordUncheckedUpdateInput>
  }

  /**
   * RateLimitRecord delete
   */
  export type RateLimitRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimitRecord
     */
    select?: RateLimitRecordSelect<ExtArgs> | null
    /**
     * Filter which RateLimitRecord to delete.
     */
    where: RateLimitRecordWhereUniqueInput
  }

  /**
   * RateLimitRecord deleteMany
   */
  export type RateLimitRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RateLimitRecords to delete
     */
    where?: RateLimitRecordWhereInput
  }

  /**
   * RateLimitRecord without action
   */
  export type RateLimitRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimitRecord
     */
    select?: RateLimitRecordSelect<ExtArgs> | null
  }


  /**
   * Model SecurityEvent
   */

  export type AggregateSecurityEvent = {
    _count: SecurityEventCountAggregateOutputType | null
    _min: SecurityEventMinAggregateOutputType | null
    _max: SecurityEventMaxAggregateOutputType | null
  }

  export type SecurityEventMinAggregateOutputType = {
    id: string | null
    eventType: string | null
    severity: string | null
    identifier: string | null
    description: string | null
    actionTaken: string | null
    createdAt: Date | null
  }

  export type SecurityEventMaxAggregateOutputType = {
    id: string | null
    eventType: string | null
    severity: string | null
    identifier: string | null
    description: string | null
    actionTaken: string | null
    createdAt: Date | null
  }

  export type SecurityEventCountAggregateOutputType = {
    id: number
    eventType: number
    severity: number
    identifier: number
    description: number
    metadata: number
    actionTaken: number
    createdAt: number
    _all: number
  }


  export type SecurityEventMinAggregateInputType = {
    id?: true
    eventType?: true
    severity?: true
    identifier?: true
    description?: true
    actionTaken?: true
    createdAt?: true
  }

  export type SecurityEventMaxAggregateInputType = {
    id?: true
    eventType?: true
    severity?: true
    identifier?: true
    description?: true
    actionTaken?: true
    createdAt?: true
  }

  export type SecurityEventCountAggregateInputType = {
    id?: true
    eventType?: true
    severity?: true
    identifier?: true
    description?: true
    metadata?: true
    actionTaken?: true
    createdAt?: true
    _all?: true
  }

  export type SecurityEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityEvent to aggregate.
     */
    where?: SecurityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityEvents to fetch.
     */
    orderBy?: SecurityEventOrderByWithRelationInput | SecurityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SecurityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SecurityEvents
    **/
    _count?: true | SecurityEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecurityEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecurityEventMaxAggregateInputType
  }

  export type GetSecurityEventAggregateType<T extends SecurityEventAggregateArgs> = {
        [P in keyof T & keyof AggregateSecurityEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecurityEvent[P]>
      : GetScalarType<T[P], AggregateSecurityEvent[P]>
  }




  export type SecurityEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityEventWhereInput
    orderBy?: SecurityEventOrderByWithAggregationInput | SecurityEventOrderByWithAggregationInput[]
    by: SecurityEventScalarFieldEnum[] | SecurityEventScalarFieldEnum
    having?: SecurityEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecurityEventCountAggregateInputType | true
    _min?: SecurityEventMinAggregateInputType
    _max?: SecurityEventMaxAggregateInputType
  }

  export type SecurityEventGroupByOutputType = {
    id: string
    eventType: string
    severity: string
    identifier: string | null
    description: string
    metadata: JsonValue | null
    actionTaken: string | null
    createdAt: Date
    _count: SecurityEventCountAggregateOutputType | null
    _min: SecurityEventMinAggregateOutputType | null
    _max: SecurityEventMaxAggregateOutputType | null
  }

  type GetSecurityEventGroupByPayload<T extends SecurityEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SecurityEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecurityEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecurityEventGroupByOutputType[P]>
            : GetScalarType<T[P], SecurityEventGroupByOutputType[P]>
        }
      >
    >


  export type SecurityEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    severity?: boolean
    identifier?: boolean
    description?: boolean
    metadata?: boolean
    actionTaken?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["securityEvent"]>

  export type SecurityEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    severity?: boolean
    identifier?: boolean
    description?: boolean
    metadata?: boolean
    actionTaken?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["securityEvent"]>

  export type SecurityEventSelectScalar = {
    id?: boolean
    eventType?: boolean
    severity?: boolean
    identifier?: boolean
    description?: boolean
    metadata?: boolean
    actionTaken?: boolean
    createdAt?: boolean
  }


  export type $SecurityEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SecurityEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventType: string
      severity: string
      identifier: string | null
      description: string
      metadata: Prisma.JsonValue | null
      actionTaken: string | null
      createdAt: Date
    }, ExtArgs["result"]["securityEvent"]>
    composites: {}
  }

  type SecurityEventGetPayload<S extends boolean | null | undefined | SecurityEventDefaultArgs> = $Result.GetResult<Prisma.$SecurityEventPayload, S>

  type SecurityEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SecurityEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SecurityEventCountAggregateInputType | true
    }

  export interface SecurityEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SecurityEvent'], meta: { name: 'SecurityEvent' } }
    /**
     * Find zero or one SecurityEvent that matches the filter.
     * @param {SecurityEventFindUniqueArgs} args - Arguments to find a SecurityEvent
     * @example
     * // Get one SecurityEvent
     * const securityEvent = await prisma.securityEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SecurityEventFindUniqueArgs>(args: SelectSubset<T, SecurityEventFindUniqueArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SecurityEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SecurityEventFindUniqueOrThrowArgs} args - Arguments to find a SecurityEvent
     * @example
     * // Get one SecurityEvent
     * const securityEvent = await prisma.securityEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SecurityEventFindUniqueOrThrowArgs>(args: SelectSubset<T, SecurityEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SecurityEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventFindFirstArgs} args - Arguments to find a SecurityEvent
     * @example
     * // Get one SecurityEvent
     * const securityEvent = await prisma.securityEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SecurityEventFindFirstArgs>(args?: SelectSubset<T, SecurityEventFindFirstArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SecurityEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventFindFirstOrThrowArgs} args - Arguments to find a SecurityEvent
     * @example
     * // Get one SecurityEvent
     * const securityEvent = await prisma.securityEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SecurityEventFindFirstOrThrowArgs>(args?: SelectSubset<T, SecurityEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SecurityEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecurityEvents
     * const securityEvents = await prisma.securityEvent.findMany()
     * 
     * // Get first 10 SecurityEvents
     * const securityEvents = await prisma.securityEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const securityEventWithIdOnly = await prisma.securityEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SecurityEventFindManyArgs>(args?: SelectSubset<T, SecurityEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SecurityEvent.
     * @param {SecurityEventCreateArgs} args - Arguments to create a SecurityEvent.
     * @example
     * // Create one SecurityEvent
     * const SecurityEvent = await prisma.securityEvent.create({
     *   data: {
     *     // ... data to create a SecurityEvent
     *   }
     * })
     * 
     */
    create<T extends SecurityEventCreateArgs>(args: SelectSubset<T, SecurityEventCreateArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SecurityEvents.
     * @param {SecurityEventCreateManyArgs} args - Arguments to create many SecurityEvents.
     * @example
     * // Create many SecurityEvents
     * const securityEvent = await prisma.securityEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SecurityEventCreateManyArgs>(args?: SelectSubset<T, SecurityEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SecurityEvents and returns the data saved in the database.
     * @param {SecurityEventCreateManyAndReturnArgs} args - Arguments to create many SecurityEvents.
     * @example
     * // Create many SecurityEvents
     * const securityEvent = await prisma.securityEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SecurityEvents and only return the `id`
     * const securityEventWithIdOnly = await prisma.securityEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SecurityEventCreateManyAndReturnArgs>(args?: SelectSubset<T, SecurityEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SecurityEvent.
     * @param {SecurityEventDeleteArgs} args - Arguments to delete one SecurityEvent.
     * @example
     * // Delete one SecurityEvent
     * const SecurityEvent = await prisma.securityEvent.delete({
     *   where: {
     *     // ... filter to delete one SecurityEvent
     *   }
     * })
     * 
     */
    delete<T extends SecurityEventDeleteArgs>(args: SelectSubset<T, SecurityEventDeleteArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SecurityEvent.
     * @param {SecurityEventUpdateArgs} args - Arguments to update one SecurityEvent.
     * @example
     * // Update one SecurityEvent
     * const securityEvent = await prisma.securityEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SecurityEventUpdateArgs>(args: SelectSubset<T, SecurityEventUpdateArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SecurityEvents.
     * @param {SecurityEventDeleteManyArgs} args - Arguments to filter SecurityEvents to delete.
     * @example
     * // Delete a few SecurityEvents
     * const { count } = await prisma.securityEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SecurityEventDeleteManyArgs>(args?: SelectSubset<T, SecurityEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecurityEvents
     * const securityEvent = await prisma.securityEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SecurityEventUpdateManyArgs>(args: SelectSubset<T, SecurityEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SecurityEvent.
     * @param {SecurityEventUpsertArgs} args - Arguments to update or create a SecurityEvent.
     * @example
     * // Update or create a SecurityEvent
     * const securityEvent = await prisma.securityEvent.upsert({
     *   create: {
     *     // ... data to create a SecurityEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecurityEvent we want to update
     *   }
     * })
     */
    upsert<T extends SecurityEventUpsertArgs>(args: SelectSubset<T, SecurityEventUpsertArgs<ExtArgs>>): Prisma__SecurityEventClient<$Result.GetResult<Prisma.$SecurityEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SecurityEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventCountArgs} args - Arguments to filter SecurityEvents to count.
     * @example
     * // Count the number of SecurityEvents
     * const count = await prisma.securityEvent.count({
     *   where: {
     *     // ... the filter for the SecurityEvents we want to count
     *   }
     * })
    **/
    count<T extends SecurityEventCountArgs>(
      args?: Subset<T, SecurityEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecurityEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecurityEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecurityEventAggregateArgs>(args: Subset<T, SecurityEventAggregateArgs>): Prisma.PrismaPromise<GetSecurityEventAggregateType<T>>

    /**
     * Group by SecurityEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecurityEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecurityEventGroupByArgs['orderBy'] }
        : { orderBy?: SecurityEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecurityEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecurityEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SecurityEvent model
   */
  readonly fields: SecurityEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SecurityEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SecurityEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SecurityEvent model
   */ 
  interface SecurityEventFieldRefs {
    readonly id: FieldRef<"SecurityEvent", 'String'>
    readonly eventType: FieldRef<"SecurityEvent", 'String'>
    readonly severity: FieldRef<"SecurityEvent", 'String'>
    readonly identifier: FieldRef<"SecurityEvent", 'String'>
    readonly description: FieldRef<"SecurityEvent", 'String'>
    readonly metadata: FieldRef<"SecurityEvent", 'Json'>
    readonly actionTaken: FieldRef<"SecurityEvent", 'String'>
    readonly createdAt: FieldRef<"SecurityEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SecurityEvent findUnique
   */
  export type SecurityEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Filter, which SecurityEvent to fetch.
     */
    where: SecurityEventWhereUniqueInput
  }

  /**
   * SecurityEvent findUniqueOrThrow
   */
  export type SecurityEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Filter, which SecurityEvent to fetch.
     */
    where: SecurityEventWhereUniqueInput
  }

  /**
   * SecurityEvent findFirst
   */
  export type SecurityEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Filter, which SecurityEvent to fetch.
     */
    where?: SecurityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityEvents to fetch.
     */
    orderBy?: SecurityEventOrderByWithRelationInput | SecurityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityEvents.
     */
    cursor?: SecurityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityEvents.
     */
    distinct?: SecurityEventScalarFieldEnum | SecurityEventScalarFieldEnum[]
  }

  /**
   * SecurityEvent findFirstOrThrow
   */
  export type SecurityEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Filter, which SecurityEvent to fetch.
     */
    where?: SecurityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityEvents to fetch.
     */
    orderBy?: SecurityEventOrderByWithRelationInput | SecurityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecurityEvents.
     */
    cursor?: SecurityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecurityEvents.
     */
    distinct?: SecurityEventScalarFieldEnum | SecurityEventScalarFieldEnum[]
  }

  /**
   * SecurityEvent findMany
   */
  export type SecurityEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Filter, which SecurityEvents to fetch.
     */
    where?: SecurityEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecurityEvents to fetch.
     */
    orderBy?: SecurityEventOrderByWithRelationInput | SecurityEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SecurityEvents.
     */
    cursor?: SecurityEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecurityEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecurityEvents.
     */
    skip?: number
    distinct?: SecurityEventScalarFieldEnum | SecurityEventScalarFieldEnum[]
  }

  /**
   * SecurityEvent create
   */
  export type SecurityEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * The data needed to create a SecurityEvent.
     */
    data: XOR<SecurityEventCreateInput, SecurityEventUncheckedCreateInput>
  }

  /**
   * SecurityEvent createMany
   */
  export type SecurityEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SecurityEvents.
     */
    data: SecurityEventCreateManyInput | SecurityEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SecurityEvent createManyAndReturn
   */
  export type SecurityEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SecurityEvents.
     */
    data: SecurityEventCreateManyInput | SecurityEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SecurityEvent update
   */
  export type SecurityEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * The data needed to update a SecurityEvent.
     */
    data: XOR<SecurityEventUpdateInput, SecurityEventUncheckedUpdateInput>
    /**
     * Choose, which SecurityEvent to update.
     */
    where: SecurityEventWhereUniqueInput
  }

  /**
   * SecurityEvent updateMany
   */
  export type SecurityEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SecurityEvents.
     */
    data: XOR<SecurityEventUpdateManyMutationInput, SecurityEventUncheckedUpdateManyInput>
    /**
     * Filter which SecurityEvents to update
     */
    where?: SecurityEventWhereInput
  }

  /**
   * SecurityEvent upsert
   */
  export type SecurityEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * The filter to search for the SecurityEvent to update in case it exists.
     */
    where: SecurityEventWhereUniqueInput
    /**
     * In case the SecurityEvent found by the `where` argument doesn't exist, create a new SecurityEvent with this data.
     */
    create: XOR<SecurityEventCreateInput, SecurityEventUncheckedCreateInput>
    /**
     * In case the SecurityEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SecurityEventUpdateInput, SecurityEventUncheckedUpdateInput>
  }

  /**
   * SecurityEvent delete
   */
  export type SecurityEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
    /**
     * Filter which SecurityEvent to delete.
     */
    where: SecurityEventWhereUniqueInput
  }

  /**
   * SecurityEvent deleteMany
   */
  export type SecurityEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityEvents to delete
     */
    where?: SecurityEventWhereInput
  }

  /**
   * SecurityEvent without action
   */
  export type SecurityEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityEvent
     */
    select?: SecurityEventSelect<ExtArgs> | null
  }


  /**
   * Model BlockedEntity
   */

  export type AggregateBlockedEntity = {
    _count: BlockedEntityCountAggregateOutputType | null
    _min: BlockedEntityMinAggregateOutputType | null
    _max: BlockedEntityMaxAggregateOutputType | null
  }

  export type BlockedEntityMinAggregateOutputType = {
    id: string | null
    type: string | null
    value: string | null
    reason: string | null
    blockedBy: string | null
    expiresAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlockedEntityMaxAggregateOutputType = {
    id: string | null
    type: string | null
    value: string | null
    reason: string | null
    blockedBy: string | null
    expiresAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlockedEntityCountAggregateOutputType = {
    id: number
    type: number
    value: number
    reason: number
    blockedBy: number
    expiresAt: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlockedEntityMinAggregateInputType = {
    id?: true
    type?: true
    value?: true
    reason?: true
    blockedBy?: true
    expiresAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlockedEntityMaxAggregateInputType = {
    id?: true
    type?: true
    value?: true
    reason?: true
    blockedBy?: true
    expiresAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlockedEntityCountAggregateInputType = {
    id?: true
    type?: true
    value?: true
    reason?: true
    blockedBy?: true
    expiresAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlockedEntityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockedEntity to aggregate.
     */
    where?: BlockedEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedEntities to fetch.
     */
    orderBy?: BlockedEntityOrderByWithRelationInput | BlockedEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockedEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedEntities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlockedEntities
    **/
    _count?: true | BlockedEntityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockedEntityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockedEntityMaxAggregateInputType
  }

  export type GetBlockedEntityAggregateType<T extends BlockedEntityAggregateArgs> = {
        [P in keyof T & keyof AggregateBlockedEntity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlockedEntity[P]>
      : GetScalarType<T[P], AggregateBlockedEntity[P]>
  }




  export type BlockedEntityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockedEntityWhereInput
    orderBy?: BlockedEntityOrderByWithAggregationInput | BlockedEntityOrderByWithAggregationInput[]
    by: BlockedEntityScalarFieldEnum[] | BlockedEntityScalarFieldEnum
    having?: BlockedEntityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockedEntityCountAggregateInputType | true
    _min?: BlockedEntityMinAggregateInputType
    _max?: BlockedEntityMaxAggregateInputType
  }

  export type BlockedEntityGroupByOutputType = {
    id: string
    type: string
    value: string
    reason: string
    blockedBy: string | null
    expiresAt: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: BlockedEntityCountAggregateOutputType | null
    _min: BlockedEntityMinAggregateOutputType | null
    _max: BlockedEntityMaxAggregateOutputType | null
  }

  type GetBlockedEntityGroupByPayload<T extends BlockedEntityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockedEntityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockedEntityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockedEntityGroupByOutputType[P]>
            : GetScalarType<T[P], BlockedEntityGroupByOutputType[P]>
        }
      >
    >


  export type BlockedEntitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    value?: boolean
    reason?: boolean
    blockedBy?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["blockedEntity"]>

  export type BlockedEntitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    value?: boolean
    reason?: boolean
    blockedBy?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["blockedEntity"]>

  export type BlockedEntitySelectScalar = {
    id?: boolean
    type?: boolean
    value?: boolean
    reason?: boolean
    blockedBy?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $BlockedEntityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlockedEntity"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      value: string
      reason: string
      blockedBy: string | null
      expiresAt: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["blockedEntity"]>
    composites: {}
  }

  type BlockedEntityGetPayload<S extends boolean | null | undefined | BlockedEntityDefaultArgs> = $Result.GetResult<Prisma.$BlockedEntityPayload, S>

  type BlockedEntityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BlockedEntityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlockedEntityCountAggregateInputType | true
    }

  export interface BlockedEntityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlockedEntity'], meta: { name: 'BlockedEntity' } }
    /**
     * Find zero or one BlockedEntity that matches the filter.
     * @param {BlockedEntityFindUniqueArgs} args - Arguments to find a BlockedEntity
     * @example
     * // Get one BlockedEntity
     * const blockedEntity = await prisma.blockedEntity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlockedEntityFindUniqueArgs>(args: SelectSubset<T, BlockedEntityFindUniqueArgs<ExtArgs>>): Prisma__BlockedEntityClient<$Result.GetResult<Prisma.$BlockedEntityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BlockedEntity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BlockedEntityFindUniqueOrThrowArgs} args - Arguments to find a BlockedEntity
     * @example
     * // Get one BlockedEntity
     * const blockedEntity = await prisma.blockedEntity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlockedEntityFindUniqueOrThrowArgs>(args: SelectSubset<T, BlockedEntityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlockedEntityClient<$Result.GetResult<Prisma.$BlockedEntityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BlockedEntity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedEntityFindFirstArgs} args - Arguments to find a BlockedEntity
     * @example
     * // Get one BlockedEntity
     * const blockedEntity = await prisma.blockedEntity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlockedEntityFindFirstArgs>(args?: SelectSubset<T, BlockedEntityFindFirstArgs<ExtArgs>>): Prisma__BlockedEntityClient<$Result.GetResult<Prisma.$BlockedEntityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BlockedEntity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedEntityFindFirstOrThrowArgs} args - Arguments to find a BlockedEntity
     * @example
     * // Get one BlockedEntity
     * const blockedEntity = await prisma.blockedEntity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlockedEntityFindFirstOrThrowArgs>(args?: SelectSubset<T, BlockedEntityFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlockedEntityClient<$Result.GetResult<Prisma.$BlockedEntityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BlockedEntities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedEntityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlockedEntities
     * const blockedEntities = await prisma.blockedEntity.findMany()
     * 
     * // Get first 10 BlockedEntities
     * const blockedEntities = await prisma.blockedEntity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockedEntityWithIdOnly = await prisma.blockedEntity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlockedEntityFindManyArgs>(args?: SelectSubset<T, BlockedEntityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedEntityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BlockedEntity.
     * @param {BlockedEntityCreateArgs} args - Arguments to create a BlockedEntity.
     * @example
     * // Create one BlockedEntity
     * const BlockedEntity = await prisma.blockedEntity.create({
     *   data: {
     *     // ... data to create a BlockedEntity
     *   }
     * })
     * 
     */
    create<T extends BlockedEntityCreateArgs>(args: SelectSubset<T, BlockedEntityCreateArgs<ExtArgs>>): Prisma__BlockedEntityClient<$Result.GetResult<Prisma.$BlockedEntityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BlockedEntities.
     * @param {BlockedEntityCreateManyArgs} args - Arguments to create many BlockedEntities.
     * @example
     * // Create many BlockedEntities
     * const blockedEntity = await prisma.blockedEntity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlockedEntityCreateManyArgs>(args?: SelectSubset<T, BlockedEntityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlockedEntities and returns the data saved in the database.
     * @param {BlockedEntityCreateManyAndReturnArgs} args - Arguments to create many BlockedEntities.
     * @example
     * // Create many BlockedEntities
     * const blockedEntity = await prisma.blockedEntity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlockedEntities and only return the `id`
     * const blockedEntityWithIdOnly = await prisma.blockedEntity.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlockedEntityCreateManyAndReturnArgs>(args?: SelectSubset<T, BlockedEntityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedEntityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BlockedEntity.
     * @param {BlockedEntityDeleteArgs} args - Arguments to delete one BlockedEntity.
     * @example
     * // Delete one BlockedEntity
     * const BlockedEntity = await prisma.blockedEntity.delete({
     *   where: {
     *     // ... filter to delete one BlockedEntity
     *   }
     * })
     * 
     */
    delete<T extends BlockedEntityDeleteArgs>(args: SelectSubset<T, BlockedEntityDeleteArgs<ExtArgs>>): Prisma__BlockedEntityClient<$Result.GetResult<Prisma.$BlockedEntityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BlockedEntity.
     * @param {BlockedEntityUpdateArgs} args - Arguments to update one BlockedEntity.
     * @example
     * // Update one BlockedEntity
     * const blockedEntity = await prisma.blockedEntity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlockedEntityUpdateArgs>(args: SelectSubset<T, BlockedEntityUpdateArgs<ExtArgs>>): Prisma__BlockedEntityClient<$Result.GetResult<Prisma.$BlockedEntityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BlockedEntities.
     * @param {BlockedEntityDeleteManyArgs} args - Arguments to filter BlockedEntities to delete.
     * @example
     * // Delete a few BlockedEntities
     * const { count } = await prisma.blockedEntity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlockedEntityDeleteManyArgs>(args?: SelectSubset<T, BlockedEntityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlockedEntities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedEntityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlockedEntities
     * const blockedEntity = await prisma.blockedEntity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlockedEntityUpdateManyArgs>(args: SelectSubset<T, BlockedEntityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BlockedEntity.
     * @param {BlockedEntityUpsertArgs} args - Arguments to update or create a BlockedEntity.
     * @example
     * // Update or create a BlockedEntity
     * const blockedEntity = await prisma.blockedEntity.upsert({
     *   create: {
     *     // ... data to create a BlockedEntity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlockedEntity we want to update
     *   }
     * })
     */
    upsert<T extends BlockedEntityUpsertArgs>(args: SelectSubset<T, BlockedEntityUpsertArgs<ExtArgs>>): Prisma__BlockedEntityClient<$Result.GetResult<Prisma.$BlockedEntityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BlockedEntities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedEntityCountArgs} args - Arguments to filter BlockedEntities to count.
     * @example
     * // Count the number of BlockedEntities
     * const count = await prisma.blockedEntity.count({
     *   where: {
     *     // ... the filter for the BlockedEntities we want to count
     *   }
     * })
    **/
    count<T extends BlockedEntityCountArgs>(
      args?: Subset<T, BlockedEntityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockedEntityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlockedEntity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedEntityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockedEntityAggregateArgs>(args: Subset<T, BlockedEntityAggregateArgs>): Prisma.PrismaPromise<GetBlockedEntityAggregateType<T>>

    /**
     * Group by BlockedEntity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedEntityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockedEntityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockedEntityGroupByArgs['orderBy'] }
        : { orderBy?: BlockedEntityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockedEntityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockedEntityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlockedEntity model
   */
  readonly fields: BlockedEntityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlockedEntity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlockedEntityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlockedEntity model
   */ 
  interface BlockedEntityFieldRefs {
    readonly id: FieldRef<"BlockedEntity", 'String'>
    readonly type: FieldRef<"BlockedEntity", 'String'>
    readonly value: FieldRef<"BlockedEntity", 'String'>
    readonly reason: FieldRef<"BlockedEntity", 'String'>
    readonly blockedBy: FieldRef<"BlockedEntity", 'String'>
    readonly expiresAt: FieldRef<"BlockedEntity", 'DateTime'>
    readonly isActive: FieldRef<"BlockedEntity", 'Boolean'>
    readonly createdAt: FieldRef<"BlockedEntity", 'DateTime'>
    readonly updatedAt: FieldRef<"BlockedEntity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlockedEntity findUnique
   */
  export type BlockedEntityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedEntity
     */
    select?: BlockedEntitySelect<ExtArgs> | null
    /**
     * Filter, which BlockedEntity to fetch.
     */
    where: BlockedEntityWhereUniqueInput
  }

  /**
   * BlockedEntity findUniqueOrThrow
   */
  export type BlockedEntityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedEntity
     */
    select?: BlockedEntitySelect<ExtArgs> | null
    /**
     * Filter, which BlockedEntity to fetch.
     */
    where: BlockedEntityWhereUniqueInput
  }

  /**
   * BlockedEntity findFirst
   */
  export type BlockedEntityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedEntity
     */
    select?: BlockedEntitySelect<ExtArgs> | null
    /**
     * Filter, which BlockedEntity to fetch.
     */
    where?: BlockedEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedEntities to fetch.
     */
    orderBy?: BlockedEntityOrderByWithRelationInput | BlockedEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockedEntities.
     */
    cursor?: BlockedEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedEntities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockedEntities.
     */
    distinct?: BlockedEntityScalarFieldEnum | BlockedEntityScalarFieldEnum[]
  }

  /**
   * BlockedEntity findFirstOrThrow
   */
  export type BlockedEntityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedEntity
     */
    select?: BlockedEntitySelect<ExtArgs> | null
    /**
     * Filter, which BlockedEntity to fetch.
     */
    where?: BlockedEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedEntities to fetch.
     */
    orderBy?: BlockedEntityOrderByWithRelationInput | BlockedEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockedEntities.
     */
    cursor?: BlockedEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedEntities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockedEntities.
     */
    distinct?: BlockedEntityScalarFieldEnum | BlockedEntityScalarFieldEnum[]
  }

  /**
   * BlockedEntity findMany
   */
  export type BlockedEntityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedEntity
     */
    select?: BlockedEntitySelect<ExtArgs> | null
    /**
     * Filter, which BlockedEntities to fetch.
     */
    where?: BlockedEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedEntities to fetch.
     */
    orderBy?: BlockedEntityOrderByWithRelationInput | BlockedEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlockedEntities.
     */
    cursor?: BlockedEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedEntities.
     */
    skip?: number
    distinct?: BlockedEntityScalarFieldEnum | BlockedEntityScalarFieldEnum[]
  }

  /**
   * BlockedEntity create
   */
  export type BlockedEntityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedEntity
     */
    select?: BlockedEntitySelect<ExtArgs> | null
    /**
     * The data needed to create a BlockedEntity.
     */
    data: XOR<BlockedEntityCreateInput, BlockedEntityUncheckedCreateInput>
  }

  /**
   * BlockedEntity createMany
   */
  export type BlockedEntityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlockedEntities.
     */
    data: BlockedEntityCreateManyInput | BlockedEntityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlockedEntity createManyAndReturn
   */
  export type BlockedEntityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedEntity
     */
    select?: BlockedEntitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BlockedEntities.
     */
    data: BlockedEntityCreateManyInput | BlockedEntityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlockedEntity update
   */
  export type BlockedEntityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedEntity
     */
    select?: BlockedEntitySelect<ExtArgs> | null
    /**
     * The data needed to update a BlockedEntity.
     */
    data: XOR<BlockedEntityUpdateInput, BlockedEntityUncheckedUpdateInput>
    /**
     * Choose, which BlockedEntity to update.
     */
    where: BlockedEntityWhereUniqueInput
  }

  /**
   * BlockedEntity updateMany
   */
  export type BlockedEntityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlockedEntities.
     */
    data: XOR<BlockedEntityUpdateManyMutationInput, BlockedEntityUncheckedUpdateManyInput>
    /**
     * Filter which BlockedEntities to update
     */
    where?: BlockedEntityWhereInput
  }

  /**
   * BlockedEntity upsert
   */
  export type BlockedEntityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedEntity
     */
    select?: BlockedEntitySelect<ExtArgs> | null
    /**
     * The filter to search for the BlockedEntity to update in case it exists.
     */
    where: BlockedEntityWhereUniqueInput
    /**
     * In case the BlockedEntity found by the `where` argument doesn't exist, create a new BlockedEntity with this data.
     */
    create: XOR<BlockedEntityCreateInput, BlockedEntityUncheckedCreateInput>
    /**
     * In case the BlockedEntity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockedEntityUpdateInput, BlockedEntityUncheckedUpdateInput>
  }

  /**
   * BlockedEntity delete
   */
  export type BlockedEntityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedEntity
     */
    select?: BlockedEntitySelect<ExtArgs> | null
    /**
     * Filter which BlockedEntity to delete.
     */
    where: BlockedEntityWhereUniqueInput
  }

  /**
   * BlockedEntity deleteMany
   */
  export type BlockedEntityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockedEntities to delete
     */
    where?: BlockedEntityWhereInput
  }

  /**
   * BlockedEntity without action
   */
  export type BlockedEntityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedEntity
     */
    select?: BlockedEntitySelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    walletAddress: 'walletAddress',
    role: 'role',
    isActive: 'isActive',
    isEmailVerified: 'isEmailVerified',
    emailVerifiedAt: 'emailVerifiedAt',
    lastLoginAt: 'lastLoginAt',
    lastLoginIp: 'lastLoginIp',
    failedLoginCount: 'failedLoginCount',
    lockedUntil: 'lockedUntil',
    twoFactorEnabled: 'twoFactorEnabled',
    twoFactorSecret: 'twoFactorSecret',
    displayName: 'displayName',
    avatarUrl: 'avatarUrl',
    bio: 'bio',
    apiCallCount: 'apiCallCount',
    apiCallResetAt: 'apiCallResetAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    refreshToken: 'refreshToken',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    expiresAt: 'expiresAt',
    isRevoked: 'isRevoked',
    revokedAt: 'revokedAt',
    revokedReason: 'revokedReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const CryptoProjectScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    symbol: 'symbol',
    description: 'description',
    category: 'category',
    website: 'website',
    whitepaper: 'whitepaper',
    twitter: 'twitter',
    discord: 'discord',
    telegram: 'telegram',
    github: 'github',
    tokenType: 'tokenType',
    totalSupply: 'totalSupply',
    decimals: 'decimals',
    teamAllocationPercent: 'teamAllocationPercent',
    teamVestingMonths: 'teamVestingMonths',
    teamCliffMonths: 'teamCliffMonths',
    vestingType: 'vestingType',
    initialLiquidity: 'initialLiquidity',
    liquidityLockMonths: 'liquidityLockMonths',
    liquidityLockTxHash: 'liquidityLockTxHash',
    auditProvider: 'auditProvider',
    auditReportUrl: 'auditReportUrl',
    auditDate: 'auditDate',
    contractAddress: 'contractAddress',
    contractVerified: 'contractVerified',
    status: 'status',
    submittedAt: 'submittedAt',
    reviewedAt: 'reviewedAt',
    reviewedBy: 'reviewedBy',
    rejectionReason: 'rejectionReason',
    trustScore: 'trustScore',
    trustScoreUpdatedAt: 'trustScoreUpdatedAt',
    launchDate: 'launchDate',
    softCap: 'softCap',
    hardCap: 'hardCap',
    minContribution: 'minContribution',
    maxContribution: 'maxContribution',
    isVerified: 'isVerified',
    isFeatured: 'isFeatured',
    isPaused: 'isPaused',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CryptoProjectScalarFieldEnum = (typeof CryptoProjectScalarFieldEnum)[keyof typeof CryptoProjectScalarFieldEnum]


  export const ProjectDocumentScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    type: 'type',
    fileUrl: 'fileUrl',
    fileHash: 'fileHash',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    isPublic: 'isPublic',
    uploadedAt: 'uploadedAt'
  };

  export type ProjectDocumentScalarFieldEnum = (typeof ProjectDocumentScalarFieldEnum)[keyof typeof ProjectDocumentScalarFieldEnum]


  export const BusinessScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    legalName: 'legalName',
    dba: 'dba',
    entityType: 'entityType',
    jurisdiction: 'jurisdiction',
    ein: 'ein',
    registrationNumber: 'registrationNumber',
    incorporationDate: 'incorporationDate',
    address: 'address',
    city: 'city',
    state: 'state',
    postalCode: 'postalCode',
    country: 'country',
    businessEmail: 'businessEmail',
    businessPhone: 'businessPhone',
    website: 'website',
    description: 'description',
    industry: 'industry',
    employeeCount: 'employeeCount',
    annualRevenue: 'annualRevenue',
    linkedin: 'linkedin',
    twitter: 'twitter',
    kybLevel: 'kybLevel',
    kybProvider: 'kybProvider',
    kybVerifiedAt: 'kybVerifiedAt',
    kybExpiresAt: 'kybExpiresAt',
    kybRejectionReason: 'kybRejectionReason',
    tokenType: 'tokenType',
    raiseAmount: 'raiseAmount',
    equityPercent: 'equityPercent',
    revenueSharePercent: 'revenueSharePercent',
    minInvestment: 'minInvestment',
    maxInvestment: 'maxInvestment',
    status: 'status',
    submittedAt: 'submittedAt',
    reviewedAt: 'reviewedAt',
    reviewedBy: 'reviewedBy',
    rejectionReason: 'rejectionReason',
    trustScore: 'trustScore',
    trustScoreUpdatedAt: 'trustScoreUpdatedAt',
    isVerified: 'isVerified',
    isFeatured: 'isFeatured',
    isPaused: 'isPaused',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BusinessScalarFieldEnum = (typeof BusinessScalarFieldEnum)[keyof typeof BusinessScalarFieldEnum]


  export const BusinessFounderScalarFieldEnum: {
    id: 'id',
    businessId: 'businessId',
    name: 'name',
    role: 'role',
    email: 'email',
    ownershipPercent: 'ownershipPercent',
    walletAddress: 'walletAddress',
    linkedinUrl: 'linkedinUrl',
    kycVerified: 'kycVerified',
    kycVerifiedAt: 'kycVerifiedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BusinessFounderScalarFieldEnum = (typeof BusinessFounderScalarFieldEnum)[keyof typeof BusinessFounderScalarFieldEnum]


  export const BusinessDocumentScalarFieldEnum: {
    id: 'id',
    businessId: 'businessId',
    name: 'name',
    type: 'type',
    fileUrl: 'fileUrl',
    fileHash: 'fileHash',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    isPublic: 'isPublic',
    isVerified: 'isVerified',
    verifiedBy: 'verifiedBy',
    verifiedAt: 'verifiedAt',
    uploadedAt: 'uploadedAt'
  };

  export type BusinessDocumentScalarFieldEnum = (typeof BusinessDocumentScalarFieldEnum)[keyof typeof BusinessDocumentScalarFieldEnum]


  export const RevenueReportScalarFieldEnum: {
    id: 'id',
    businessId: 'businessId',
    period: 'period',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    grossRevenue: 'grossRevenue',
    eligibleRevenue: 'eligibleRevenue',
    distributionAmount: 'distributionAmount',
    documentUrl: 'documentUrl',
    documentHash: 'documentHash',
    isVerified: 'isVerified',
    verifiedBy: 'verifiedBy',
    verifiedAt: 'verifiedAt',
    submittedAt: 'submittedAt'
  };

  export type RevenueReportScalarFieldEnum = (typeof RevenueReportScalarFieldEnum)[keyof typeof RevenueReportScalarFieldEnum]


  export const PrivateIdentityVerificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    status: 'status',
    level: 'level',
    provider: 'provider',
    providerSessionId: 'providerSessionId',
    providerStatus: 'providerStatus',
    verifiedAt: 'verifiedAt',
    expiresAt: 'expiresAt',
    rejectionReason: 'rejectionReason',
    retryCount: 'retryCount',
    lastAttemptAt: 'lastAttemptAt',
    isAccredited: 'isAccredited',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PrivateIdentityVerificationScalarFieldEnum = (typeof PrivateIdentityVerificationScalarFieldEnum)[keyof typeof PrivateIdentityVerificationScalarFieldEnum]


  export const ContactMessageScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    email: 'email',
    subject: 'subject',
    message: 'message',
    category: 'category',
    status: 'status',
    assignedTo: 'assignedTo',
    responseText: 'responseText',
    respondedAt: 'respondedAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactMessageScalarFieldEnum = (typeof ContactMessageScalarFieldEnum)[keyof typeof ContactMessageScalarFieldEnum]


  export const LaunchApplicationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    applicantName: 'applicantName',
    applicantEmail: 'applicantEmail',
    applicantRole: 'applicantRole',
    companyName: 'companyName',
    website: 'website',
    type: 'type',
    description: 'description',
    raiseAmount: 'raiseAmount',
    timeline: 'timeline',
    twitter: 'twitter',
    discord: 'discord',
    telegram: 'telegram',
    referralSource: 'referralSource',
    status: 'status',
    reviewedBy: 'reviewedBy',
    reviewedAt: 'reviewedAt',
    rejectionReason: 'rejectionReason',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LaunchApplicationScalarFieldEnum = (typeof LaunchApplicationScalarFieldEnum)[keyof typeof LaunchApplicationScalarFieldEnum]


  export const TrustScoreEventScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    businessId: 'businessId',
    userId: 'userId',
    eventType: 'eventType',
    points: 'points',
    reason: 'reason',
    metadata: 'metadata',
    triggeredBy: 'triggeredBy',
    createdAt: 'createdAt'
  };

  export type TrustScoreEventScalarFieldEnum = (typeof TrustScoreEventScalarFieldEnum)[keyof typeof TrustScoreEventScalarFieldEnum]


  export const AdminNoteScalarFieldEnum: {
    id: 'id',
    authorId: 'authorId',
    projectId: 'projectId',
    businessId: 'businessId',
    contactId: 'contactId',
    applicationId: 'applicationId',
    note: 'note',
    isInternal: 'isInternal',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminNoteScalarFieldEnum = (typeof AdminNoteScalarFieldEnum)[keyof typeof AdminNoteScalarFieldEnum]


  export const SystemLogScalarFieldEnum: {
    id: 'id',
    level: 'level',
    category: 'category',
    action: 'action',
    message: 'message',
    metadata: 'metadata',
    userId: 'userId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    requestId: 'requestId',
    endpoint: 'endpoint',
    method: 'method',
    statusCode: 'statusCode',
    responseTime: 'responseTime',
    createdAt: 'createdAt'
  };

  export type SystemLogScalarFieldEnum = (typeof SystemLogScalarFieldEnum)[keyof typeof SystemLogScalarFieldEnum]


  export const DexPairScalarFieldEnum: {
    id: 'id',
    tokenA: 'tokenA',
    tokenB: 'tokenB',
    poolAddress: 'poolAddress',
    reserveA: 'reserveA',
    reserveB: 'reserveB',
    fee: 'fee',
    isActive: 'isActive',
    isRegulated: 'isRegulated',
    warmupEndsAt: 'warmupEndsAt',
    maxSlippage: 'maxSlippage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DexPairScalarFieldEnum = (typeof DexPairScalarFieldEnum)[keyof typeof DexPairScalarFieldEnum]


  export const RateLimitRecordScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    endpoint: 'endpoint',
    windowStart: 'windowStart',
    requestCount: 'requestCount',
    createdAt: 'createdAt'
  };

  export type RateLimitRecordScalarFieldEnum = (typeof RateLimitRecordScalarFieldEnum)[keyof typeof RateLimitRecordScalarFieldEnum]


  export const SecurityEventScalarFieldEnum: {
    id: 'id',
    eventType: 'eventType',
    severity: 'severity',
    identifier: 'identifier',
    description: 'description',
    metadata: 'metadata',
    actionTaken: 'actionTaken',
    createdAt: 'createdAt'
  };

  export type SecurityEventScalarFieldEnum = (typeof SecurityEventScalarFieldEnum)[keyof typeof SecurityEventScalarFieldEnum]


  export const BlockedEntityScalarFieldEnum: {
    id: 'id',
    type: 'type',
    value: 'value',
    reason: 'reason',
    blockedBy: 'blockedBy',
    expiresAt: 'expiresAt',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlockedEntityScalarFieldEnum = (typeof BlockedEntityScalarFieldEnum)[keyof typeof BlockedEntityScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'TokenType'
   */
  export type EnumTokenTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TokenType'>
    


  /**
   * Reference to a field of type 'TokenType[]'
   */
  export type ListEnumTokenTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TokenType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'VestingType'
   */
  export type EnumVestingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VestingType'>
    


  /**
   * Reference to a field of type 'VestingType[]'
   */
  export type ListEnumVestingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VestingType[]'>
    


  /**
   * Reference to a field of type 'ProjectStatus'
   */
  export type EnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus'>
    


  /**
   * Reference to a field of type 'ProjectStatus[]'
   */
  export type ListEnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus[]'>
    


  /**
   * Reference to a field of type 'KYBLevel'
   */
  export type EnumKYBLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KYBLevel'>
    


  /**
   * Reference to a field of type 'KYBLevel[]'
   */
  export type ListEnumKYBLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KYBLevel[]'>
    


  /**
   * Reference to a field of type 'BusinessStatus'
   */
  export type EnumBusinessStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BusinessStatus'>
    


  /**
   * Reference to a field of type 'BusinessStatus[]'
   */
  export type ListEnumBusinessStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BusinessStatus[]'>
    


  /**
   * Reference to a field of type 'IdentityStatus'
   */
  export type EnumIdentityStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IdentityStatus'>
    


  /**
   * Reference to a field of type 'IdentityStatus[]'
   */
  export type ListEnumIdentityStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IdentityStatus[]'>
    


  /**
   * Reference to a field of type 'MessageStatus'
   */
  export type EnumMessageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageStatus'>
    


  /**
   * Reference to a field of type 'MessageStatus[]'
   */
  export type ListEnumMessageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageStatus[]'>
    


  /**
   * Reference to a field of type 'ApplicationType'
   */
  export type EnumApplicationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationType'>
    


  /**
   * Reference to a field of type 'ApplicationType[]'
   */
  export type ListEnumApplicationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationType[]'>
    


  /**
   * Reference to a field of type 'ApplicationStatus'
   */
  export type EnumApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationStatus'>
    


  /**
   * Reference to a field of type 'ApplicationStatus[]'
   */
  export type ListEnumApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationStatus[]'>
    


  /**
   * Reference to a field of type 'TrustScoreEventType'
   */
  export type EnumTrustScoreEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrustScoreEventType'>
    


  /**
   * Reference to a field of type 'TrustScoreEventType[]'
   */
  export type ListEnumTrustScoreEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrustScoreEventType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'LogLevel'
   */
  export type EnumLogLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LogLevel'>
    


  /**
   * Reference to a field of type 'LogLevel[]'
   */
  export type ListEnumLogLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LogLevel[]'>
    


  /**
   * Reference to a field of type 'LogCategory'
   */
  export type EnumLogCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LogCategory'>
    


  /**
   * Reference to a field of type 'LogCategory[]'
   */
  export type ListEnumLogCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LogCategory[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    walletAddress?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    isEmailVerified?: BoolFilter<"User"> | boolean
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginIp?: StringNullableFilter<"User"> | string | null
    failedLoginCount?: IntFilter<"User"> | number
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    displayName?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    apiCallCount?: IntFilter<"User"> | number
    apiCallResetAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    cryptoProjects?: CryptoProjectListRelationFilter
    businesses?: BusinessListRelationFilter
    identityVerification?: XOR<PrivateIdentityVerificationNullableRelationFilter, PrivateIdentityVerificationWhereInput> | null
    sessions?: SessionListRelationFilter
    systemLogs?: SystemLogListRelationFilter
    trustScoreEvents?: TrustScoreEventListRelationFilter
    contactMessages?: ContactMessageListRelationFilter
    applications?: LaunchApplicationListRelationFilter
    adminNotes?: AdminNoteListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    walletAddress?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    isEmailVerified?: SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    lastLoginIp?: SortOrderInput | SortOrder
    failedLoginCount?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    displayName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    apiCallCount?: SortOrder
    apiCallResetAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cryptoProjects?: CryptoProjectOrderByRelationAggregateInput
    businesses?: BusinessOrderByRelationAggregateInput
    identityVerification?: PrivateIdentityVerificationOrderByWithRelationInput
    sessions?: SessionOrderByRelationAggregateInput
    systemLogs?: SystemLogOrderByRelationAggregateInput
    trustScoreEvents?: TrustScoreEventOrderByRelationAggregateInput
    contactMessages?: ContactMessageOrderByRelationAggregateInput
    applications?: LaunchApplicationOrderByRelationAggregateInput
    adminNotes?: AdminNoteOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    walletAddress?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    isEmailVerified?: BoolFilter<"User"> | boolean
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginIp?: StringNullableFilter<"User"> | string | null
    failedLoginCount?: IntFilter<"User"> | number
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    displayName?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    apiCallCount?: IntFilter<"User"> | number
    apiCallResetAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    cryptoProjects?: CryptoProjectListRelationFilter
    businesses?: BusinessListRelationFilter
    identityVerification?: XOR<PrivateIdentityVerificationNullableRelationFilter, PrivateIdentityVerificationWhereInput> | null
    sessions?: SessionListRelationFilter
    systemLogs?: SystemLogListRelationFilter
    trustScoreEvents?: TrustScoreEventListRelationFilter
    contactMessages?: ContactMessageListRelationFilter
    applications?: LaunchApplicationListRelationFilter
    adminNotes?: AdminNoteListRelationFilter
  }, "id" | "email" | "walletAddress">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    walletAddress?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    isEmailVerified?: SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    lastLoginIp?: SortOrderInput | SortOrder
    failedLoginCount?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    displayName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    apiCallCount?: SortOrder
    apiCallResetAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    walletAddress?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    isEmailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    emailVerifiedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastLoginIp?: StringNullableWithAggregatesFilter<"User"> | string | null
    failedLoginCount?: IntWithAggregatesFilter<"User"> | number
    lockedUntil?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    twoFactorEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    twoFactorSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    displayName?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    apiCallCount?: IntWithAggregatesFilter<"User"> | number
    apiCallResetAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    refreshToken?: StringNullableFilter<"Session"> | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    isRevoked?: BoolFilter<"Session"> | boolean
    revokedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    revokedReason?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    revokedReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    refreshToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    isRevoked?: BoolFilter<"Session"> | boolean
    revokedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    revokedReason?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token" | "refreshToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    revokedReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    token?: StringWithAggregatesFilter<"Session"> | string
    refreshToken?: StringNullableWithAggregatesFilter<"Session"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    isRevoked?: BoolWithAggregatesFilter<"Session"> | boolean
    revokedAt?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
    revokedReason?: StringNullableWithAggregatesFilter<"Session"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type CryptoProjectWhereInput = {
    AND?: CryptoProjectWhereInput | CryptoProjectWhereInput[]
    OR?: CryptoProjectWhereInput[]
    NOT?: CryptoProjectWhereInput | CryptoProjectWhereInput[]
    id?: StringFilter<"CryptoProject"> | string
    userId?: StringFilter<"CryptoProject"> | string
    name?: StringFilter<"CryptoProject"> | string
    symbol?: StringNullableFilter<"CryptoProject"> | string | null
    description?: StringNullableFilter<"CryptoProject"> | string | null
    category?: StringNullableFilter<"CryptoProject"> | string | null
    website?: StringNullableFilter<"CryptoProject"> | string | null
    whitepaper?: StringNullableFilter<"CryptoProject"> | string | null
    twitter?: StringNullableFilter<"CryptoProject"> | string | null
    discord?: StringNullableFilter<"CryptoProject"> | string | null
    telegram?: StringNullableFilter<"CryptoProject"> | string | null
    github?: StringNullableFilter<"CryptoProject"> | string | null
    tokenType?: EnumTokenTypeFilter<"CryptoProject"> | $Enums.TokenType
    totalSupply?: StringNullableFilter<"CryptoProject"> | string | null
    decimals?: IntFilter<"CryptoProject"> | number
    teamAllocationPercent?: FloatNullableFilter<"CryptoProject"> | number | null
    teamVestingMonths?: IntNullableFilter<"CryptoProject"> | number | null
    teamCliffMonths?: IntNullableFilter<"CryptoProject"> | number | null
    vestingType?: EnumVestingTypeNullableFilter<"CryptoProject"> | $Enums.VestingType | null
    initialLiquidity?: StringNullableFilter<"CryptoProject"> | string | null
    liquidityLockMonths?: IntNullableFilter<"CryptoProject"> | number | null
    liquidityLockTxHash?: StringNullableFilter<"CryptoProject"> | string | null
    auditProvider?: StringNullableFilter<"CryptoProject"> | string | null
    auditReportUrl?: StringNullableFilter<"CryptoProject"> | string | null
    auditDate?: DateTimeNullableFilter<"CryptoProject"> | Date | string | null
    contractAddress?: StringNullableFilter<"CryptoProject"> | string | null
    contractVerified?: BoolFilter<"CryptoProject"> | boolean
    status?: EnumProjectStatusFilter<"CryptoProject"> | $Enums.ProjectStatus
    submittedAt?: DateTimeNullableFilter<"CryptoProject"> | Date | string | null
    reviewedAt?: DateTimeNullableFilter<"CryptoProject"> | Date | string | null
    reviewedBy?: StringNullableFilter<"CryptoProject"> | string | null
    rejectionReason?: StringNullableFilter<"CryptoProject"> | string | null
    trustScore?: IntFilter<"CryptoProject"> | number
    trustScoreUpdatedAt?: DateTimeNullableFilter<"CryptoProject"> | Date | string | null
    launchDate?: DateTimeNullableFilter<"CryptoProject"> | Date | string | null
    softCap?: StringNullableFilter<"CryptoProject"> | string | null
    hardCap?: StringNullableFilter<"CryptoProject"> | string | null
    minContribution?: StringNullableFilter<"CryptoProject"> | string | null
    maxContribution?: StringNullableFilter<"CryptoProject"> | string | null
    isVerified?: BoolFilter<"CryptoProject"> | boolean
    isFeatured?: BoolFilter<"CryptoProject"> | boolean
    isPaused?: BoolFilter<"CryptoProject"> | boolean
    createdAt?: DateTimeFilter<"CryptoProject"> | Date | string
    updatedAt?: DateTimeFilter<"CryptoProject"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    trustScoreEvents?: TrustScoreEventListRelationFilter
    adminNotes?: AdminNoteListRelationFilter
    documents?: ProjectDocumentListRelationFilter
  }

  export type CryptoProjectOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    symbol?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    whitepaper?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    discord?: SortOrderInput | SortOrder
    telegram?: SortOrderInput | SortOrder
    github?: SortOrderInput | SortOrder
    tokenType?: SortOrder
    totalSupply?: SortOrderInput | SortOrder
    decimals?: SortOrder
    teamAllocationPercent?: SortOrderInput | SortOrder
    teamVestingMonths?: SortOrderInput | SortOrder
    teamCliffMonths?: SortOrderInput | SortOrder
    vestingType?: SortOrderInput | SortOrder
    initialLiquidity?: SortOrderInput | SortOrder
    liquidityLockMonths?: SortOrderInput | SortOrder
    liquidityLockTxHash?: SortOrderInput | SortOrder
    auditProvider?: SortOrderInput | SortOrder
    auditReportUrl?: SortOrderInput | SortOrder
    auditDate?: SortOrderInput | SortOrder
    contractAddress?: SortOrderInput | SortOrder
    contractVerified?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    trustScore?: SortOrder
    trustScoreUpdatedAt?: SortOrderInput | SortOrder
    launchDate?: SortOrderInput | SortOrder
    softCap?: SortOrderInput | SortOrder
    hardCap?: SortOrderInput | SortOrder
    minContribution?: SortOrderInput | SortOrder
    maxContribution?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    isFeatured?: SortOrder
    isPaused?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    trustScoreEvents?: TrustScoreEventOrderByRelationAggregateInput
    adminNotes?: AdminNoteOrderByRelationAggregateInput
    documents?: ProjectDocumentOrderByRelationAggregateInput
  }

  export type CryptoProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CryptoProjectWhereInput | CryptoProjectWhereInput[]
    OR?: CryptoProjectWhereInput[]
    NOT?: CryptoProjectWhereInput | CryptoProjectWhereInput[]
    userId?: StringFilter<"CryptoProject"> | string
    name?: StringFilter<"CryptoProject"> | string
    symbol?: StringNullableFilter<"CryptoProject"> | string | null
    description?: StringNullableFilter<"CryptoProject"> | string | null
    category?: StringNullableFilter<"CryptoProject"> | string | null
    website?: StringNullableFilter<"CryptoProject"> | string | null
    whitepaper?: StringNullableFilter<"CryptoProject"> | string | null
    twitter?: StringNullableFilter<"CryptoProject"> | string | null
    discord?: StringNullableFilter<"CryptoProject"> | string | null
    telegram?: StringNullableFilter<"CryptoProject"> | string | null
    github?: StringNullableFilter<"CryptoProject"> | string | null
    tokenType?: EnumTokenTypeFilter<"CryptoProject"> | $Enums.TokenType
    totalSupply?: StringNullableFilter<"CryptoProject"> | string | null
    decimals?: IntFilter<"CryptoProject"> | number
    teamAllocationPercent?: FloatNullableFilter<"CryptoProject"> | number | null
    teamVestingMonths?: IntNullableFilter<"CryptoProject"> | number | null
    teamCliffMonths?: IntNullableFilter<"CryptoProject"> | number | null
    vestingType?: EnumVestingTypeNullableFilter<"CryptoProject"> | $Enums.VestingType | null
    initialLiquidity?: StringNullableFilter<"CryptoProject"> | string | null
    liquidityLockMonths?: IntNullableFilter<"CryptoProject"> | number | null
    liquidityLockTxHash?: StringNullableFilter<"CryptoProject"> | string | null
    auditProvider?: StringNullableFilter<"CryptoProject"> | string | null
    auditReportUrl?: StringNullableFilter<"CryptoProject"> | string | null
    auditDate?: DateTimeNullableFilter<"CryptoProject"> | Date | string | null
    contractAddress?: StringNullableFilter<"CryptoProject"> | string | null
    contractVerified?: BoolFilter<"CryptoProject"> | boolean
    status?: EnumProjectStatusFilter<"CryptoProject"> | $Enums.ProjectStatus
    submittedAt?: DateTimeNullableFilter<"CryptoProject"> | Date | string | null
    reviewedAt?: DateTimeNullableFilter<"CryptoProject"> | Date | string | null
    reviewedBy?: StringNullableFilter<"CryptoProject"> | string | null
    rejectionReason?: StringNullableFilter<"CryptoProject"> | string | null
    trustScore?: IntFilter<"CryptoProject"> | number
    trustScoreUpdatedAt?: DateTimeNullableFilter<"CryptoProject"> | Date | string | null
    launchDate?: DateTimeNullableFilter<"CryptoProject"> | Date | string | null
    softCap?: StringNullableFilter<"CryptoProject"> | string | null
    hardCap?: StringNullableFilter<"CryptoProject"> | string | null
    minContribution?: StringNullableFilter<"CryptoProject"> | string | null
    maxContribution?: StringNullableFilter<"CryptoProject"> | string | null
    isVerified?: BoolFilter<"CryptoProject"> | boolean
    isFeatured?: BoolFilter<"CryptoProject"> | boolean
    isPaused?: BoolFilter<"CryptoProject"> | boolean
    createdAt?: DateTimeFilter<"CryptoProject"> | Date | string
    updatedAt?: DateTimeFilter<"CryptoProject"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    trustScoreEvents?: TrustScoreEventListRelationFilter
    adminNotes?: AdminNoteListRelationFilter
    documents?: ProjectDocumentListRelationFilter
  }, "id">

  export type CryptoProjectOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    symbol?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    whitepaper?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    discord?: SortOrderInput | SortOrder
    telegram?: SortOrderInput | SortOrder
    github?: SortOrderInput | SortOrder
    tokenType?: SortOrder
    totalSupply?: SortOrderInput | SortOrder
    decimals?: SortOrder
    teamAllocationPercent?: SortOrderInput | SortOrder
    teamVestingMonths?: SortOrderInput | SortOrder
    teamCliffMonths?: SortOrderInput | SortOrder
    vestingType?: SortOrderInput | SortOrder
    initialLiquidity?: SortOrderInput | SortOrder
    liquidityLockMonths?: SortOrderInput | SortOrder
    liquidityLockTxHash?: SortOrderInput | SortOrder
    auditProvider?: SortOrderInput | SortOrder
    auditReportUrl?: SortOrderInput | SortOrder
    auditDate?: SortOrderInput | SortOrder
    contractAddress?: SortOrderInput | SortOrder
    contractVerified?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    trustScore?: SortOrder
    trustScoreUpdatedAt?: SortOrderInput | SortOrder
    launchDate?: SortOrderInput | SortOrder
    softCap?: SortOrderInput | SortOrder
    hardCap?: SortOrderInput | SortOrder
    minContribution?: SortOrderInput | SortOrder
    maxContribution?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    isFeatured?: SortOrder
    isPaused?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CryptoProjectCountOrderByAggregateInput
    _avg?: CryptoProjectAvgOrderByAggregateInput
    _max?: CryptoProjectMaxOrderByAggregateInput
    _min?: CryptoProjectMinOrderByAggregateInput
    _sum?: CryptoProjectSumOrderByAggregateInput
  }

  export type CryptoProjectScalarWhereWithAggregatesInput = {
    AND?: CryptoProjectScalarWhereWithAggregatesInput | CryptoProjectScalarWhereWithAggregatesInput[]
    OR?: CryptoProjectScalarWhereWithAggregatesInput[]
    NOT?: CryptoProjectScalarWhereWithAggregatesInput | CryptoProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CryptoProject"> | string
    userId?: StringWithAggregatesFilter<"CryptoProject"> | string
    name?: StringWithAggregatesFilter<"CryptoProject"> | string
    symbol?: StringNullableWithAggregatesFilter<"CryptoProject"> | string | null
    description?: StringNullableWithAggregatesFilter<"CryptoProject"> | string | null
    category?: StringNullableWithAggregatesFilter<"CryptoProject"> | string | null
    website?: StringNullableWithAggregatesFilter<"CryptoProject"> | string | null
    whitepaper?: StringNullableWithAggregatesFilter<"CryptoProject"> | string | null
    twitter?: StringNullableWithAggregatesFilter<"CryptoProject"> | string | null
    discord?: StringNullableWithAggregatesFilter<"CryptoProject"> | string | null
    telegram?: StringNullableWithAggregatesFilter<"CryptoProject"> | string | null
    github?: StringNullableWithAggregatesFilter<"CryptoProject"> | string | null
    tokenType?: EnumTokenTypeWithAggregatesFilter<"CryptoProject"> | $Enums.TokenType
    totalSupply?: StringNullableWithAggregatesFilter<"CryptoProject"> | string | null
    decimals?: IntWithAggregatesFilter<"CryptoProject"> | number
    teamAllocationPercent?: FloatNullableWithAggregatesFilter<"CryptoProject"> | number | null
    teamVestingMonths?: IntNullableWithAggregatesFilter<"CryptoProject"> | number | null
    teamCliffMonths?: IntNullableWithAggregatesFilter<"CryptoProject"> | number | null
    vestingType?: EnumVestingTypeNullableWithAggregatesFilter<"CryptoProject"> | $Enums.VestingType | null
    initialLiquidity?: StringNullableWithAggregatesFilter<"CryptoProject"> | string | null
    liquidityLockMonths?: IntNullableWithAggregatesFilter<"CryptoProject"> | number | null
    liquidityLockTxHash?: StringNullableWithAggregatesFilter<"CryptoProject"> | string | null
    auditProvider?: StringNullableWithAggregatesFilter<"CryptoProject"> | string | null
    auditReportUrl?: StringNullableWithAggregatesFilter<"CryptoProject"> | string | null
    auditDate?: DateTimeNullableWithAggregatesFilter<"CryptoProject"> | Date | string | null
    contractAddress?: StringNullableWithAggregatesFilter<"CryptoProject"> | string | null
    contractVerified?: BoolWithAggregatesFilter<"CryptoProject"> | boolean
    status?: EnumProjectStatusWithAggregatesFilter<"CryptoProject"> | $Enums.ProjectStatus
    submittedAt?: DateTimeNullableWithAggregatesFilter<"CryptoProject"> | Date | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"CryptoProject"> | Date | string | null
    reviewedBy?: StringNullableWithAggregatesFilter<"CryptoProject"> | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"CryptoProject"> | string | null
    trustScore?: IntWithAggregatesFilter<"CryptoProject"> | number
    trustScoreUpdatedAt?: DateTimeNullableWithAggregatesFilter<"CryptoProject"> | Date | string | null
    launchDate?: DateTimeNullableWithAggregatesFilter<"CryptoProject"> | Date | string | null
    softCap?: StringNullableWithAggregatesFilter<"CryptoProject"> | string | null
    hardCap?: StringNullableWithAggregatesFilter<"CryptoProject"> | string | null
    minContribution?: StringNullableWithAggregatesFilter<"CryptoProject"> | string | null
    maxContribution?: StringNullableWithAggregatesFilter<"CryptoProject"> | string | null
    isVerified?: BoolWithAggregatesFilter<"CryptoProject"> | boolean
    isFeatured?: BoolWithAggregatesFilter<"CryptoProject"> | boolean
    isPaused?: BoolWithAggregatesFilter<"CryptoProject"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CryptoProject"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CryptoProject"> | Date | string
  }

  export type ProjectDocumentWhereInput = {
    AND?: ProjectDocumentWhereInput | ProjectDocumentWhereInput[]
    OR?: ProjectDocumentWhereInput[]
    NOT?: ProjectDocumentWhereInput | ProjectDocumentWhereInput[]
    id?: StringFilter<"ProjectDocument"> | string
    projectId?: StringFilter<"ProjectDocument"> | string
    name?: StringFilter<"ProjectDocument"> | string
    type?: StringFilter<"ProjectDocument"> | string
    fileUrl?: StringFilter<"ProjectDocument"> | string
    fileHash?: StringNullableFilter<"ProjectDocument"> | string | null
    fileSize?: IntNullableFilter<"ProjectDocument"> | number | null
    mimeType?: StringNullableFilter<"ProjectDocument"> | string | null
    isPublic?: BoolFilter<"ProjectDocument"> | boolean
    uploadedAt?: DateTimeFilter<"ProjectDocument"> | Date | string
    project?: XOR<CryptoProjectRelationFilter, CryptoProjectWhereInput>
  }

  export type ProjectDocumentOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrder
    fileHash?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    uploadedAt?: SortOrder
    project?: CryptoProjectOrderByWithRelationInput
  }

  export type ProjectDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectDocumentWhereInput | ProjectDocumentWhereInput[]
    OR?: ProjectDocumentWhereInput[]
    NOT?: ProjectDocumentWhereInput | ProjectDocumentWhereInput[]
    projectId?: StringFilter<"ProjectDocument"> | string
    name?: StringFilter<"ProjectDocument"> | string
    type?: StringFilter<"ProjectDocument"> | string
    fileUrl?: StringFilter<"ProjectDocument"> | string
    fileHash?: StringNullableFilter<"ProjectDocument"> | string | null
    fileSize?: IntNullableFilter<"ProjectDocument"> | number | null
    mimeType?: StringNullableFilter<"ProjectDocument"> | string | null
    isPublic?: BoolFilter<"ProjectDocument"> | boolean
    uploadedAt?: DateTimeFilter<"ProjectDocument"> | Date | string
    project?: XOR<CryptoProjectRelationFilter, CryptoProjectWhereInput>
  }, "id">

  export type ProjectDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrder
    fileHash?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    uploadedAt?: SortOrder
    _count?: ProjectDocumentCountOrderByAggregateInput
    _avg?: ProjectDocumentAvgOrderByAggregateInput
    _max?: ProjectDocumentMaxOrderByAggregateInput
    _min?: ProjectDocumentMinOrderByAggregateInput
    _sum?: ProjectDocumentSumOrderByAggregateInput
  }

  export type ProjectDocumentScalarWhereWithAggregatesInput = {
    AND?: ProjectDocumentScalarWhereWithAggregatesInput | ProjectDocumentScalarWhereWithAggregatesInput[]
    OR?: ProjectDocumentScalarWhereWithAggregatesInput[]
    NOT?: ProjectDocumentScalarWhereWithAggregatesInput | ProjectDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectDocument"> | string
    projectId?: StringWithAggregatesFilter<"ProjectDocument"> | string
    name?: StringWithAggregatesFilter<"ProjectDocument"> | string
    type?: StringWithAggregatesFilter<"ProjectDocument"> | string
    fileUrl?: StringWithAggregatesFilter<"ProjectDocument"> | string
    fileHash?: StringNullableWithAggregatesFilter<"ProjectDocument"> | string | null
    fileSize?: IntNullableWithAggregatesFilter<"ProjectDocument"> | number | null
    mimeType?: StringNullableWithAggregatesFilter<"ProjectDocument"> | string | null
    isPublic?: BoolWithAggregatesFilter<"ProjectDocument"> | boolean
    uploadedAt?: DateTimeWithAggregatesFilter<"ProjectDocument"> | Date | string
  }

  export type BusinessWhereInput = {
    AND?: BusinessWhereInput | BusinessWhereInput[]
    OR?: BusinessWhereInput[]
    NOT?: BusinessWhereInput | BusinessWhereInput[]
    id?: StringFilter<"Business"> | string
    userId?: StringFilter<"Business"> | string
    legalName?: StringFilter<"Business"> | string
    dba?: StringNullableFilter<"Business"> | string | null
    entityType?: StringNullableFilter<"Business"> | string | null
    jurisdiction?: StringNullableFilter<"Business"> | string | null
    ein?: StringNullableFilter<"Business"> | string | null
    registrationNumber?: StringNullableFilter<"Business"> | string | null
    incorporationDate?: DateTimeNullableFilter<"Business"> | Date | string | null
    address?: StringNullableFilter<"Business"> | string | null
    city?: StringNullableFilter<"Business"> | string | null
    state?: StringNullableFilter<"Business"> | string | null
    postalCode?: StringNullableFilter<"Business"> | string | null
    country?: StringNullableFilter<"Business"> | string | null
    businessEmail?: StringNullableFilter<"Business"> | string | null
    businessPhone?: StringNullableFilter<"Business"> | string | null
    website?: StringNullableFilter<"Business"> | string | null
    description?: StringNullableFilter<"Business"> | string | null
    industry?: StringNullableFilter<"Business"> | string | null
    employeeCount?: IntNullableFilter<"Business"> | number | null
    annualRevenue?: StringNullableFilter<"Business"> | string | null
    linkedin?: StringNullableFilter<"Business"> | string | null
    twitter?: StringNullableFilter<"Business"> | string | null
    kybLevel?: EnumKYBLevelFilter<"Business"> | $Enums.KYBLevel
    kybProvider?: StringNullableFilter<"Business"> | string | null
    kybVerifiedAt?: DateTimeNullableFilter<"Business"> | Date | string | null
    kybExpiresAt?: DateTimeNullableFilter<"Business"> | Date | string | null
    kybRejectionReason?: StringNullableFilter<"Business"> | string | null
    tokenType?: EnumTokenTypeNullableFilter<"Business"> | $Enums.TokenType | null
    raiseAmount?: StringNullableFilter<"Business"> | string | null
    equityPercent?: FloatNullableFilter<"Business"> | number | null
    revenueSharePercent?: FloatNullableFilter<"Business"> | number | null
    minInvestment?: StringNullableFilter<"Business"> | string | null
    maxInvestment?: StringNullableFilter<"Business"> | string | null
    status?: EnumBusinessStatusFilter<"Business"> | $Enums.BusinessStatus
    submittedAt?: DateTimeNullableFilter<"Business"> | Date | string | null
    reviewedAt?: DateTimeNullableFilter<"Business"> | Date | string | null
    reviewedBy?: StringNullableFilter<"Business"> | string | null
    rejectionReason?: StringNullableFilter<"Business"> | string | null
    trustScore?: IntFilter<"Business"> | number
    trustScoreUpdatedAt?: DateTimeNullableFilter<"Business"> | Date | string | null
    isVerified?: BoolFilter<"Business"> | boolean
    isFeatured?: BoolFilter<"Business"> | boolean
    isPaused?: BoolFilter<"Business"> | boolean
    createdAt?: DateTimeFilter<"Business"> | Date | string
    updatedAt?: DateTimeFilter<"Business"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    founders?: BusinessFounderListRelationFilter
    documents?: BusinessDocumentListRelationFilter
    trustScoreEvents?: TrustScoreEventListRelationFilter
    adminNotes?: AdminNoteListRelationFilter
    revenueReports?: RevenueReportListRelationFilter
  }

  export type BusinessOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    legalName?: SortOrder
    dba?: SortOrderInput | SortOrder
    entityType?: SortOrderInput | SortOrder
    jurisdiction?: SortOrderInput | SortOrder
    ein?: SortOrderInput | SortOrder
    registrationNumber?: SortOrderInput | SortOrder
    incorporationDate?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    businessEmail?: SortOrderInput | SortOrder
    businessPhone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    employeeCount?: SortOrderInput | SortOrder
    annualRevenue?: SortOrderInput | SortOrder
    linkedin?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    kybLevel?: SortOrder
    kybProvider?: SortOrderInput | SortOrder
    kybVerifiedAt?: SortOrderInput | SortOrder
    kybExpiresAt?: SortOrderInput | SortOrder
    kybRejectionReason?: SortOrderInput | SortOrder
    tokenType?: SortOrderInput | SortOrder
    raiseAmount?: SortOrderInput | SortOrder
    equityPercent?: SortOrderInput | SortOrder
    revenueSharePercent?: SortOrderInput | SortOrder
    minInvestment?: SortOrderInput | SortOrder
    maxInvestment?: SortOrderInput | SortOrder
    status?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    trustScore?: SortOrder
    trustScoreUpdatedAt?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    isFeatured?: SortOrder
    isPaused?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    founders?: BusinessFounderOrderByRelationAggregateInput
    documents?: BusinessDocumentOrderByRelationAggregateInput
    trustScoreEvents?: TrustScoreEventOrderByRelationAggregateInput
    adminNotes?: AdminNoteOrderByRelationAggregateInput
    revenueReports?: RevenueReportOrderByRelationAggregateInput
  }

  export type BusinessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BusinessWhereInput | BusinessWhereInput[]
    OR?: BusinessWhereInput[]
    NOT?: BusinessWhereInput | BusinessWhereInput[]
    userId?: StringFilter<"Business"> | string
    legalName?: StringFilter<"Business"> | string
    dba?: StringNullableFilter<"Business"> | string | null
    entityType?: StringNullableFilter<"Business"> | string | null
    jurisdiction?: StringNullableFilter<"Business"> | string | null
    ein?: StringNullableFilter<"Business"> | string | null
    registrationNumber?: StringNullableFilter<"Business"> | string | null
    incorporationDate?: DateTimeNullableFilter<"Business"> | Date | string | null
    address?: StringNullableFilter<"Business"> | string | null
    city?: StringNullableFilter<"Business"> | string | null
    state?: StringNullableFilter<"Business"> | string | null
    postalCode?: StringNullableFilter<"Business"> | string | null
    country?: StringNullableFilter<"Business"> | string | null
    businessEmail?: StringNullableFilter<"Business"> | string | null
    businessPhone?: StringNullableFilter<"Business"> | string | null
    website?: StringNullableFilter<"Business"> | string | null
    description?: StringNullableFilter<"Business"> | string | null
    industry?: StringNullableFilter<"Business"> | string | null
    employeeCount?: IntNullableFilter<"Business"> | number | null
    annualRevenue?: StringNullableFilter<"Business"> | string | null
    linkedin?: StringNullableFilter<"Business"> | string | null
    twitter?: StringNullableFilter<"Business"> | string | null
    kybLevel?: EnumKYBLevelFilter<"Business"> | $Enums.KYBLevel
    kybProvider?: StringNullableFilter<"Business"> | string | null
    kybVerifiedAt?: DateTimeNullableFilter<"Business"> | Date | string | null
    kybExpiresAt?: DateTimeNullableFilter<"Business"> | Date | string | null
    kybRejectionReason?: StringNullableFilter<"Business"> | string | null
    tokenType?: EnumTokenTypeNullableFilter<"Business"> | $Enums.TokenType | null
    raiseAmount?: StringNullableFilter<"Business"> | string | null
    equityPercent?: FloatNullableFilter<"Business"> | number | null
    revenueSharePercent?: FloatNullableFilter<"Business"> | number | null
    minInvestment?: StringNullableFilter<"Business"> | string | null
    maxInvestment?: StringNullableFilter<"Business"> | string | null
    status?: EnumBusinessStatusFilter<"Business"> | $Enums.BusinessStatus
    submittedAt?: DateTimeNullableFilter<"Business"> | Date | string | null
    reviewedAt?: DateTimeNullableFilter<"Business"> | Date | string | null
    reviewedBy?: StringNullableFilter<"Business"> | string | null
    rejectionReason?: StringNullableFilter<"Business"> | string | null
    trustScore?: IntFilter<"Business"> | number
    trustScoreUpdatedAt?: DateTimeNullableFilter<"Business"> | Date | string | null
    isVerified?: BoolFilter<"Business"> | boolean
    isFeatured?: BoolFilter<"Business"> | boolean
    isPaused?: BoolFilter<"Business"> | boolean
    createdAt?: DateTimeFilter<"Business"> | Date | string
    updatedAt?: DateTimeFilter<"Business"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    founders?: BusinessFounderListRelationFilter
    documents?: BusinessDocumentListRelationFilter
    trustScoreEvents?: TrustScoreEventListRelationFilter
    adminNotes?: AdminNoteListRelationFilter
    revenueReports?: RevenueReportListRelationFilter
  }, "id">

  export type BusinessOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    legalName?: SortOrder
    dba?: SortOrderInput | SortOrder
    entityType?: SortOrderInput | SortOrder
    jurisdiction?: SortOrderInput | SortOrder
    ein?: SortOrderInput | SortOrder
    registrationNumber?: SortOrderInput | SortOrder
    incorporationDate?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    businessEmail?: SortOrderInput | SortOrder
    businessPhone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    employeeCount?: SortOrderInput | SortOrder
    annualRevenue?: SortOrderInput | SortOrder
    linkedin?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    kybLevel?: SortOrder
    kybProvider?: SortOrderInput | SortOrder
    kybVerifiedAt?: SortOrderInput | SortOrder
    kybExpiresAt?: SortOrderInput | SortOrder
    kybRejectionReason?: SortOrderInput | SortOrder
    tokenType?: SortOrderInput | SortOrder
    raiseAmount?: SortOrderInput | SortOrder
    equityPercent?: SortOrderInput | SortOrder
    revenueSharePercent?: SortOrderInput | SortOrder
    minInvestment?: SortOrderInput | SortOrder
    maxInvestment?: SortOrderInput | SortOrder
    status?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    trustScore?: SortOrder
    trustScoreUpdatedAt?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    isFeatured?: SortOrder
    isPaused?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BusinessCountOrderByAggregateInput
    _avg?: BusinessAvgOrderByAggregateInput
    _max?: BusinessMaxOrderByAggregateInput
    _min?: BusinessMinOrderByAggregateInput
    _sum?: BusinessSumOrderByAggregateInput
  }

  export type BusinessScalarWhereWithAggregatesInput = {
    AND?: BusinessScalarWhereWithAggregatesInput | BusinessScalarWhereWithAggregatesInput[]
    OR?: BusinessScalarWhereWithAggregatesInput[]
    NOT?: BusinessScalarWhereWithAggregatesInput | BusinessScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Business"> | string
    userId?: StringWithAggregatesFilter<"Business"> | string
    legalName?: StringWithAggregatesFilter<"Business"> | string
    dba?: StringNullableWithAggregatesFilter<"Business"> | string | null
    entityType?: StringNullableWithAggregatesFilter<"Business"> | string | null
    jurisdiction?: StringNullableWithAggregatesFilter<"Business"> | string | null
    ein?: StringNullableWithAggregatesFilter<"Business"> | string | null
    registrationNumber?: StringNullableWithAggregatesFilter<"Business"> | string | null
    incorporationDate?: DateTimeNullableWithAggregatesFilter<"Business"> | Date | string | null
    address?: StringNullableWithAggregatesFilter<"Business"> | string | null
    city?: StringNullableWithAggregatesFilter<"Business"> | string | null
    state?: StringNullableWithAggregatesFilter<"Business"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"Business"> | string | null
    country?: StringNullableWithAggregatesFilter<"Business"> | string | null
    businessEmail?: StringNullableWithAggregatesFilter<"Business"> | string | null
    businessPhone?: StringNullableWithAggregatesFilter<"Business"> | string | null
    website?: StringNullableWithAggregatesFilter<"Business"> | string | null
    description?: StringNullableWithAggregatesFilter<"Business"> | string | null
    industry?: StringNullableWithAggregatesFilter<"Business"> | string | null
    employeeCount?: IntNullableWithAggregatesFilter<"Business"> | number | null
    annualRevenue?: StringNullableWithAggregatesFilter<"Business"> | string | null
    linkedin?: StringNullableWithAggregatesFilter<"Business"> | string | null
    twitter?: StringNullableWithAggregatesFilter<"Business"> | string | null
    kybLevel?: EnumKYBLevelWithAggregatesFilter<"Business"> | $Enums.KYBLevel
    kybProvider?: StringNullableWithAggregatesFilter<"Business"> | string | null
    kybVerifiedAt?: DateTimeNullableWithAggregatesFilter<"Business"> | Date | string | null
    kybExpiresAt?: DateTimeNullableWithAggregatesFilter<"Business"> | Date | string | null
    kybRejectionReason?: StringNullableWithAggregatesFilter<"Business"> | string | null
    tokenType?: EnumTokenTypeNullableWithAggregatesFilter<"Business"> | $Enums.TokenType | null
    raiseAmount?: StringNullableWithAggregatesFilter<"Business"> | string | null
    equityPercent?: FloatNullableWithAggregatesFilter<"Business"> | number | null
    revenueSharePercent?: FloatNullableWithAggregatesFilter<"Business"> | number | null
    minInvestment?: StringNullableWithAggregatesFilter<"Business"> | string | null
    maxInvestment?: StringNullableWithAggregatesFilter<"Business"> | string | null
    status?: EnumBusinessStatusWithAggregatesFilter<"Business"> | $Enums.BusinessStatus
    submittedAt?: DateTimeNullableWithAggregatesFilter<"Business"> | Date | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"Business"> | Date | string | null
    reviewedBy?: StringNullableWithAggregatesFilter<"Business"> | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"Business"> | string | null
    trustScore?: IntWithAggregatesFilter<"Business"> | number
    trustScoreUpdatedAt?: DateTimeNullableWithAggregatesFilter<"Business"> | Date | string | null
    isVerified?: BoolWithAggregatesFilter<"Business"> | boolean
    isFeatured?: BoolWithAggregatesFilter<"Business"> | boolean
    isPaused?: BoolWithAggregatesFilter<"Business"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Business"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Business"> | Date | string
  }

  export type BusinessFounderWhereInput = {
    AND?: BusinessFounderWhereInput | BusinessFounderWhereInput[]
    OR?: BusinessFounderWhereInput[]
    NOT?: BusinessFounderWhereInput | BusinessFounderWhereInput[]
    id?: StringFilter<"BusinessFounder"> | string
    businessId?: StringFilter<"BusinessFounder"> | string
    name?: StringFilter<"BusinessFounder"> | string
    role?: StringFilter<"BusinessFounder"> | string
    email?: StringNullableFilter<"BusinessFounder"> | string | null
    ownershipPercent?: FloatNullableFilter<"BusinessFounder"> | number | null
    walletAddress?: StringNullableFilter<"BusinessFounder"> | string | null
    linkedinUrl?: StringNullableFilter<"BusinessFounder"> | string | null
    kycVerified?: BoolFilter<"BusinessFounder"> | boolean
    kycVerifiedAt?: DateTimeNullableFilter<"BusinessFounder"> | Date | string | null
    createdAt?: DateTimeFilter<"BusinessFounder"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessFounder"> | Date | string
    business?: XOR<BusinessRelationFilter, BusinessWhereInput>
  }

  export type BusinessFounderOrderByWithRelationInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrderInput | SortOrder
    ownershipPercent?: SortOrderInput | SortOrder
    walletAddress?: SortOrderInput | SortOrder
    linkedinUrl?: SortOrderInput | SortOrder
    kycVerified?: SortOrder
    kycVerifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    business?: BusinessOrderByWithRelationInput
  }

  export type BusinessFounderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BusinessFounderWhereInput | BusinessFounderWhereInput[]
    OR?: BusinessFounderWhereInput[]
    NOT?: BusinessFounderWhereInput | BusinessFounderWhereInput[]
    businessId?: StringFilter<"BusinessFounder"> | string
    name?: StringFilter<"BusinessFounder"> | string
    role?: StringFilter<"BusinessFounder"> | string
    email?: StringNullableFilter<"BusinessFounder"> | string | null
    ownershipPercent?: FloatNullableFilter<"BusinessFounder"> | number | null
    walletAddress?: StringNullableFilter<"BusinessFounder"> | string | null
    linkedinUrl?: StringNullableFilter<"BusinessFounder"> | string | null
    kycVerified?: BoolFilter<"BusinessFounder"> | boolean
    kycVerifiedAt?: DateTimeNullableFilter<"BusinessFounder"> | Date | string | null
    createdAt?: DateTimeFilter<"BusinessFounder"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessFounder"> | Date | string
    business?: XOR<BusinessRelationFilter, BusinessWhereInput>
  }, "id">

  export type BusinessFounderOrderByWithAggregationInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrderInput | SortOrder
    ownershipPercent?: SortOrderInput | SortOrder
    walletAddress?: SortOrderInput | SortOrder
    linkedinUrl?: SortOrderInput | SortOrder
    kycVerified?: SortOrder
    kycVerifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BusinessFounderCountOrderByAggregateInput
    _avg?: BusinessFounderAvgOrderByAggregateInput
    _max?: BusinessFounderMaxOrderByAggregateInput
    _min?: BusinessFounderMinOrderByAggregateInput
    _sum?: BusinessFounderSumOrderByAggregateInput
  }

  export type BusinessFounderScalarWhereWithAggregatesInput = {
    AND?: BusinessFounderScalarWhereWithAggregatesInput | BusinessFounderScalarWhereWithAggregatesInput[]
    OR?: BusinessFounderScalarWhereWithAggregatesInput[]
    NOT?: BusinessFounderScalarWhereWithAggregatesInput | BusinessFounderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BusinessFounder"> | string
    businessId?: StringWithAggregatesFilter<"BusinessFounder"> | string
    name?: StringWithAggregatesFilter<"BusinessFounder"> | string
    role?: StringWithAggregatesFilter<"BusinessFounder"> | string
    email?: StringNullableWithAggregatesFilter<"BusinessFounder"> | string | null
    ownershipPercent?: FloatNullableWithAggregatesFilter<"BusinessFounder"> | number | null
    walletAddress?: StringNullableWithAggregatesFilter<"BusinessFounder"> | string | null
    linkedinUrl?: StringNullableWithAggregatesFilter<"BusinessFounder"> | string | null
    kycVerified?: BoolWithAggregatesFilter<"BusinessFounder"> | boolean
    kycVerifiedAt?: DateTimeNullableWithAggregatesFilter<"BusinessFounder"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BusinessFounder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BusinessFounder"> | Date | string
  }

  export type BusinessDocumentWhereInput = {
    AND?: BusinessDocumentWhereInput | BusinessDocumentWhereInput[]
    OR?: BusinessDocumentWhereInput[]
    NOT?: BusinessDocumentWhereInput | BusinessDocumentWhereInput[]
    id?: StringFilter<"BusinessDocument"> | string
    businessId?: StringFilter<"BusinessDocument"> | string
    name?: StringFilter<"BusinessDocument"> | string
    type?: StringFilter<"BusinessDocument"> | string
    fileUrl?: StringFilter<"BusinessDocument"> | string
    fileHash?: StringNullableFilter<"BusinessDocument"> | string | null
    fileSize?: IntNullableFilter<"BusinessDocument"> | number | null
    mimeType?: StringNullableFilter<"BusinessDocument"> | string | null
    isPublic?: BoolFilter<"BusinessDocument"> | boolean
    isVerified?: BoolFilter<"BusinessDocument"> | boolean
    verifiedBy?: StringNullableFilter<"BusinessDocument"> | string | null
    verifiedAt?: DateTimeNullableFilter<"BusinessDocument"> | Date | string | null
    uploadedAt?: DateTimeFilter<"BusinessDocument"> | Date | string
    business?: XOR<BusinessRelationFilter, BusinessWhereInput>
  }

  export type BusinessDocumentOrderByWithRelationInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrder
    fileHash?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    isVerified?: SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    business?: BusinessOrderByWithRelationInput
  }

  export type BusinessDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BusinessDocumentWhereInput | BusinessDocumentWhereInput[]
    OR?: BusinessDocumentWhereInput[]
    NOT?: BusinessDocumentWhereInput | BusinessDocumentWhereInput[]
    businessId?: StringFilter<"BusinessDocument"> | string
    name?: StringFilter<"BusinessDocument"> | string
    type?: StringFilter<"BusinessDocument"> | string
    fileUrl?: StringFilter<"BusinessDocument"> | string
    fileHash?: StringNullableFilter<"BusinessDocument"> | string | null
    fileSize?: IntNullableFilter<"BusinessDocument"> | number | null
    mimeType?: StringNullableFilter<"BusinessDocument"> | string | null
    isPublic?: BoolFilter<"BusinessDocument"> | boolean
    isVerified?: BoolFilter<"BusinessDocument"> | boolean
    verifiedBy?: StringNullableFilter<"BusinessDocument"> | string | null
    verifiedAt?: DateTimeNullableFilter<"BusinessDocument"> | Date | string | null
    uploadedAt?: DateTimeFilter<"BusinessDocument"> | Date | string
    business?: XOR<BusinessRelationFilter, BusinessWhereInput>
  }, "id">

  export type BusinessDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrder
    fileHash?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    isVerified?: SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    _count?: BusinessDocumentCountOrderByAggregateInput
    _avg?: BusinessDocumentAvgOrderByAggregateInput
    _max?: BusinessDocumentMaxOrderByAggregateInput
    _min?: BusinessDocumentMinOrderByAggregateInput
    _sum?: BusinessDocumentSumOrderByAggregateInput
  }

  export type BusinessDocumentScalarWhereWithAggregatesInput = {
    AND?: BusinessDocumentScalarWhereWithAggregatesInput | BusinessDocumentScalarWhereWithAggregatesInput[]
    OR?: BusinessDocumentScalarWhereWithAggregatesInput[]
    NOT?: BusinessDocumentScalarWhereWithAggregatesInput | BusinessDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BusinessDocument"> | string
    businessId?: StringWithAggregatesFilter<"BusinessDocument"> | string
    name?: StringWithAggregatesFilter<"BusinessDocument"> | string
    type?: StringWithAggregatesFilter<"BusinessDocument"> | string
    fileUrl?: StringWithAggregatesFilter<"BusinessDocument"> | string
    fileHash?: StringNullableWithAggregatesFilter<"BusinessDocument"> | string | null
    fileSize?: IntNullableWithAggregatesFilter<"BusinessDocument"> | number | null
    mimeType?: StringNullableWithAggregatesFilter<"BusinessDocument"> | string | null
    isPublic?: BoolWithAggregatesFilter<"BusinessDocument"> | boolean
    isVerified?: BoolWithAggregatesFilter<"BusinessDocument"> | boolean
    verifiedBy?: StringNullableWithAggregatesFilter<"BusinessDocument"> | string | null
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"BusinessDocument"> | Date | string | null
    uploadedAt?: DateTimeWithAggregatesFilter<"BusinessDocument"> | Date | string
  }

  export type RevenueReportWhereInput = {
    AND?: RevenueReportWhereInput | RevenueReportWhereInput[]
    OR?: RevenueReportWhereInput[]
    NOT?: RevenueReportWhereInput | RevenueReportWhereInput[]
    id?: StringFilter<"RevenueReport"> | string
    businessId?: StringFilter<"RevenueReport"> | string
    period?: StringFilter<"RevenueReport"> | string
    periodStart?: DateTimeFilter<"RevenueReport"> | Date | string
    periodEnd?: DateTimeFilter<"RevenueReport"> | Date | string
    grossRevenue?: StringFilter<"RevenueReport"> | string
    eligibleRevenue?: StringNullableFilter<"RevenueReport"> | string | null
    distributionAmount?: StringNullableFilter<"RevenueReport"> | string | null
    documentUrl?: StringNullableFilter<"RevenueReport"> | string | null
    documentHash?: StringNullableFilter<"RevenueReport"> | string | null
    isVerified?: BoolFilter<"RevenueReport"> | boolean
    verifiedBy?: StringNullableFilter<"RevenueReport"> | string | null
    verifiedAt?: DateTimeNullableFilter<"RevenueReport"> | Date | string | null
    submittedAt?: DateTimeFilter<"RevenueReport"> | Date | string
    business?: XOR<BusinessRelationFilter, BusinessWhereInput>
  }

  export type RevenueReportOrderByWithRelationInput = {
    id?: SortOrder
    businessId?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    grossRevenue?: SortOrder
    eligibleRevenue?: SortOrderInput | SortOrder
    distributionAmount?: SortOrderInput | SortOrder
    documentUrl?: SortOrderInput | SortOrder
    documentHash?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    submittedAt?: SortOrder
    business?: BusinessOrderByWithRelationInput
  }

  export type RevenueReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    businessId_period?: RevenueReportBusinessIdPeriodCompoundUniqueInput
    AND?: RevenueReportWhereInput | RevenueReportWhereInput[]
    OR?: RevenueReportWhereInput[]
    NOT?: RevenueReportWhereInput | RevenueReportWhereInput[]
    businessId?: StringFilter<"RevenueReport"> | string
    period?: StringFilter<"RevenueReport"> | string
    periodStart?: DateTimeFilter<"RevenueReport"> | Date | string
    periodEnd?: DateTimeFilter<"RevenueReport"> | Date | string
    grossRevenue?: StringFilter<"RevenueReport"> | string
    eligibleRevenue?: StringNullableFilter<"RevenueReport"> | string | null
    distributionAmount?: StringNullableFilter<"RevenueReport"> | string | null
    documentUrl?: StringNullableFilter<"RevenueReport"> | string | null
    documentHash?: StringNullableFilter<"RevenueReport"> | string | null
    isVerified?: BoolFilter<"RevenueReport"> | boolean
    verifiedBy?: StringNullableFilter<"RevenueReport"> | string | null
    verifiedAt?: DateTimeNullableFilter<"RevenueReport"> | Date | string | null
    submittedAt?: DateTimeFilter<"RevenueReport"> | Date | string
    business?: XOR<BusinessRelationFilter, BusinessWhereInput>
  }, "id" | "businessId_period">

  export type RevenueReportOrderByWithAggregationInput = {
    id?: SortOrder
    businessId?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    grossRevenue?: SortOrder
    eligibleRevenue?: SortOrderInput | SortOrder
    distributionAmount?: SortOrderInput | SortOrder
    documentUrl?: SortOrderInput | SortOrder
    documentHash?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    submittedAt?: SortOrder
    _count?: RevenueReportCountOrderByAggregateInput
    _max?: RevenueReportMaxOrderByAggregateInput
    _min?: RevenueReportMinOrderByAggregateInput
  }

  export type RevenueReportScalarWhereWithAggregatesInput = {
    AND?: RevenueReportScalarWhereWithAggregatesInput | RevenueReportScalarWhereWithAggregatesInput[]
    OR?: RevenueReportScalarWhereWithAggregatesInput[]
    NOT?: RevenueReportScalarWhereWithAggregatesInput | RevenueReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RevenueReport"> | string
    businessId?: StringWithAggregatesFilter<"RevenueReport"> | string
    period?: StringWithAggregatesFilter<"RevenueReport"> | string
    periodStart?: DateTimeWithAggregatesFilter<"RevenueReport"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"RevenueReport"> | Date | string
    grossRevenue?: StringWithAggregatesFilter<"RevenueReport"> | string
    eligibleRevenue?: StringNullableWithAggregatesFilter<"RevenueReport"> | string | null
    distributionAmount?: StringNullableWithAggregatesFilter<"RevenueReport"> | string | null
    documentUrl?: StringNullableWithAggregatesFilter<"RevenueReport"> | string | null
    documentHash?: StringNullableWithAggregatesFilter<"RevenueReport"> | string | null
    isVerified?: BoolWithAggregatesFilter<"RevenueReport"> | boolean
    verifiedBy?: StringNullableWithAggregatesFilter<"RevenueReport"> | string | null
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"RevenueReport"> | Date | string | null
    submittedAt?: DateTimeWithAggregatesFilter<"RevenueReport"> | Date | string
  }

  export type PrivateIdentityVerificationWhereInput = {
    AND?: PrivateIdentityVerificationWhereInput | PrivateIdentityVerificationWhereInput[]
    OR?: PrivateIdentityVerificationWhereInput[]
    NOT?: PrivateIdentityVerificationWhereInput | PrivateIdentityVerificationWhereInput[]
    id?: StringFilter<"PrivateIdentityVerification"> | string
    userId?: StringFilter<"PrivateIdentityVerification"> | string
    status?: EnumIdentityStatusFilter<"PrivateIdentityVerification"> | $Enums.IdentityStatus
    level?: StringNullableFilter<"PrivateIdentityVerification"> | string | null
    provider?: StringNullableFilter<"PrivateIdentityVerification"> | string | null
    providerSessionId?: StringNullableFilter<"PrivateIdentityVerification"> | string | null
    providerStatus?: StringNullableFilter<"PrivateIdentityVerification"> | string | null
    verifiedAt?: DateTimeNullableFilter<"PrivateIdentityVerification"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"PrivateIdentityVerification"> | Date | string | null
    rejectionReason?: StringNullableFilter<"PrivateIdentityVerification"> | string | null
    retryCount?: IntFilter<"PrivateIdentityVerification"> | number
    lastAttemptAt?: DateTimeNullableFilter<"PrivateIdentityVerification"> | Date | string | null
    isAccredited?: BoolFilter<"PrivateIdentityVerification"> | boolean
    createdAt?: DateTimeFilter<"PrivateIdentityVerification"> | Date | string
    updatedAt?: DateTimeFilter<"PrivateIdentityVerification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PrivateIdentityVerificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    level?: SortOrderInput | SortOrder
    provider?: SortOrderInput | SortOrder
    providerSessionId?: SortOrderInput | SortOrder
    providerStatus?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    lastAttemptAt?: SortOrderInput | SortOrder
    isAccredited?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PrivateIdentityVerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: PrivateIdentityVerificationWhereInput | PrivateIdentityVerificationWhereInput[]
    OR?: PrivateIdentityVerificationWhereInput[]
    NOT?: PrivateIdentityVerificationWhereInput | PrivateIdentityVerificationWhereInput[]
    status?: EnumIdentityStatusFilter<"PrivateIdentityVerification"> | $Enums.IdentityStatus
    level?: StringNullableFilter<"PrivateIdentityVerification"> | string | null
    provider?: StringNullableFilter<"PrivateIdentityVerification"> | string | null
    providerSessionId?: StringNullableFilter<"PrivateIdentityVerification"> | string | null
    providerStatus?: StringNullableFilter<"PrivateIdentityVerification"> | string | null
    verifiedAt?: DateTimeNullableFilter<"PrivateIdentityVerification"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"PrivateIdentityVerification"> | Date | string | null
    rejectionReason?: StringNullableFilter<"PrivateIdentityVerification"> | string | null
    retryCount?: IntFilter<"PrivateIdentityVerification"> | number
    lastAttemptAt?: DateTimeNullableFilter<"PrivateIdentityVerification"> | Date | string | null
    isAccredited?: BoolFilter<"PrivateIdentityVerification"> | boolean
    createdAt?: DateTimeFilter<"PrivateIdentityVerification"> | Date | string
    updatedAt?: DateTimeFilter<"PrivateIdentityVerification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type PrivateIdentityVerificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    level?: SortOrderInput | SortOrder
    provider?: SortOrderInput | SortOrder
    providerSessionId?: SortOrderInput | SortOrder
    providerStatus?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    lastAttemptAt?: SortOrderInput | SortOrder
    isAccredited?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PrivateIdentityVerificationCountOrderByAggregateInput
    _avg?: PrivateIdentityVerificationAvgOrderByAggregateInput
    _max?: PrivateIdentityVerificationMaxOrderByAggregateInput
    _min?: PrivateIdentityVerificationMinOrderByAggregateInput
    _sum?: PrivateIdentityVerificationSumOrderByAggregateInput
  }

  export type PrivateIdentityVerificationScalarWhereWithAggregatesInput = {
    AND?: PrivateIdentityVerificationScalarWhereWithAggregatesInput | PrivateIdentityVerificationScalarWhereWithAggregatesInput[]
    OR?: PrivateIdentityVerificationScalarWhereWithAggregatesInput[]
    NOT?: PrivateIdentityVerificationScalarWhereWithAggregatesInput | PrivateIdentityVerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PrivateIdentityVerification"> | string
    userId?: StringWithAggregatesFilter<"PrivateIdentityVerification"> | string
    status?: EnumIdentityStatusWithAggregatesFilter<"PrivateIdentityVerification"> | $Enums.IdentityStatus
    level?: StringNullableWithAggregatesFilter<"PrivateIdentityVerification"> | string | null
    provider?: StringNullableWithAggregatesFilter<"PrivateIdentityVerification"> | string | null
    providerSessionId?: StringNullableWithAggregatesFilter<"PrivateIdentityVerification"> | string | null
    providerStatus?: StringNullableWithAggregatesFilter<"PrivateIdentityVerification"> | string | null
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"PrivateIdentityVerification"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"PrivateIdentityVerification"> | Date | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"PrivateIdentityVerification"> | string | null
    retryCount?: IntWithAggregatesFilter<"PrivateIdentityVerification"> | number
    lastAttemptAt?: DateTimeNullableWithAggregatesFilter<"PrivateIdentityVerification"> | Date | string | null
    isAccredited?: BoolWithAggregatesFilter<"PrivateIdentityVerification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PrivateIdentityVerification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PrivateIdentityVerification"> | Date | string
  }

  export type ContactMessageWhereInput = {
    AND?: ContactMessageWhereInput | ContactMessageWhereInput[]
    OR?: ContactMessageWhereInput[]
    NOT?: ContactMessageWhereInput | ContactMessageWhereInput[]
    id?: StringFilter<"ContactMessage"> | string
    userId?: StringNullableFilter<"ContactMessage"> | string | null
    name?: StringFilter<"ContactMessage"> | string
    email?: StringFilter<"ContactMessage"> | string
    subject?: StringNullableFilter<"ContactMessage"> | string | null
    message?: StringFilter<"ContactMessage"> | string
    category?: StringNullableFilter<"ContactMessage"> | string | null
    status?: EnumMessageStatusFilter<"ContactMessage"> | $Enums.MessageStatus
    assignedTo?: StringNullableFilter<"ContactMessage"> | string | null
    responseText?: StringNullableFilter<"ContactMessage"> | string | null
    respondedAt?: DateTimeNullableFilter<"ContactMessage"> | Date | string | null
    ipAddress?: StringNullableFilter<"ContactMessage"> | string | null
    userAgent?: StringNullableFilter<"ContactMessage"> | string | null
    createdAt?: DateTimeFilter<"ContactMessage"> | Date | string
    updatedAt?: DateTimeFilter<"ContactMessage"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    adminNotes?: AdminNoteListRelationFilter
  }

  export type ContactMessageOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrderInput | SortOrder
    message?: SortOrder
    category?: SortOrderInput | SortOrder
    status?: SortOrder
    assignedTo?: SortOrderInput | SortOrder
    responseText?: SortOrderInput | SortOrder
    respondedAt?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    adminNotes?: AdminNoteOrderByRelationAggregateInput
  }

  export type ContactMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactMessageWhereInput | ContactMessageWhereInput[]
    OR?: ContactMessageWhereInput[]
    NOT?: ContactMessageWhereInput | ContactMessageWhereInput[]
    userId?: StringNullableFilter<"ContactMessage"> | string | null
    name?: StringFilter<"ContactMessage"> | string
    email?: StringFilter<"ContactMessage"> | string
    subject?: StringNullableFilter<"ContactMessage"> | string | null
    message?: StringFilter<"ContactMessage"> | string
    category?: StringNullableFilter<"ContactMessage"> | string | null
    status?: EnumMessageStatusFilter<"ContactMessage"> | $Enums.MessageStatus
    assignedTo?: StringNullableFilter<"ContactMessage"> | string | null
    responseText?: StringNullableFilter<"ContactMessage"> | string | null
    respondedAt?: DateTimeNullableFilter<"ContactMessage"> | Date | string | null
    ipAddress?: StringNullableFilter<"ContactMessage"> | string | null
    userAgent?: StringNullableFilter<"ContactMessage"> | string | null
    createdAt?: DateTimeFilter<"ContactMessage"> | Date | string
    updatedAt?: DateTimeFilter<"ContactMessage"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    adminNotes?: AdminNoteListRelationFilter
  }, "id">

  export type ContactMessageOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrderInput | SortOrder
    message?: SortOrder
    category?: SortOrderInput | SortOrder
    status?: SortOrder
    assignedTo?: SortOrderInput | SortOrder
    responseText?: SortOrderInput | SortOrder
    respondedAt?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactMessageCountOrderByAggregateInput
    _max?: ContactMessageMaxOrderByAggregateInput
    _min?: ContactMessageMinOrderByAggregateInput
  }

  export type ContactMessageScalarWhereWithAggregatesInput = {
    AND?: ContactMessageScalarWhereWithAggregatesInput | ContactMessageScalarWhereWithAggregatesInput[]
    OR?: ContactMessageScalarWhereWithAggregatesInput[]
    NOT?: ContactMessageScalarWhereWithAggregatesInput | ContactMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContactMessage"> | string
    userId?: StringNullableWithAggregatesFilter<"ContactMessage"> | string | null
    name?: StringWithAggregatesFilter<"ContactMessage"> | string
    email?: StringWithAggregatesFilter<"ContactMessage"> | string
    subject?: StringNullableWithAggregatesFilter<"ContactMessage"> | string | null
    message?: StringWithAggregatesFilter<"ContactMessage"> | string
    category?: StringNullableWithAggregatesFilter<"ContactMessage"> | string | null
    status?: EnumMessageStatusWithAggregatesFilter<"ContactMessage"> | $Enums.MessageStatus
    assignedTo?: StringNullableWithAggregatesFilter<"ContactMessage"> | string | null
    responseText?: StringNullableWithAggregatesFilter<"ContactMessage"> | string | null
    respondedAt?: DateTimeNullableWithAggregatesFilter<"ContactMessage"> | Date | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"ContactMessage"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"ContactMessage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ContactMessage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContactMessage"> | Date | string
  }

  export type LaunchApplicationWhereInput = {
    AND?: LaunchApplicationWhereInput | LaunchApplicationWhereInput[]
    OR?: LaunchApplicationWhereInput[]
    NOT?: LaunchApplicationWhereInput | LaunchApplicationWhereInput[]
    id?: StringFilter<"LaunchApplication"> | string
    userId?: StringNullableFilter<"LaunchApplication"> | string | null
    applicantName?: StringFilter<"LaunchApplication"> | string
    applicantEmail?: StringFilter<"LaunchApplication"> | string
    applicantRole?: StringNullableFilter<"LaunchApplication"> | string | null
    companyName?: StringNullableFilter<"LaunchApplication"> | string | null
    website?: StringNullableFilter<"LaunchApplication"> | string | null
    type?: EnumApplicationTypeFilter<"LaunchApplication"> | $Enums.ApplicationType
    description?: StringFilter<"LaunchApplication"> | string
    raiseAmount?: StringNullableFilter<"LaunchApplication"> | string | null
    timeline?: StringNullableFilter<"LaunchApplication"> | string | null
    twitter?: StringNullableFilter<"LaunchApplication"> | string | null
    discord?: StringNullableFilter<"LaunchApplication"> | string | null
    telegram?: StringNullableFilter<"LaunchApplication"> | string | null
    referralSource?: StringNullableFilter<"LaunchApplication"> | string | null
    status?: EnumApplicationStatusFilter<"LaunchApplication"> | $Enums.ApplicationStatus
    reviewedBy?: StringNullableFilter<"LaunchApplication"> | string | null
    reviewedAt?: DateTimeNullableFilter<"LaunchApplication"> | Date | string | null
    rejectionReason?: StringNullableFilter<"LaunchApplication"> | string | null
    ipAddress?: StringNullableFilter<"LaunchApplication"> | string | null
    userAgent?: StringNullableFilter<"LaunchApplication"> | string | null
    createdAt?: DateTimeFilter<"LaunchApplication"> | Date | string
    updatedAt?: DateTimeFilter<"LaunchApplication"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    adminNotes?: AdminNoteListRelationFilter
  }

  export type LaunchApplicationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    applicantName?: SortOrder
    applicantEmail?: SortOrder
    applicantRole?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    type?: SortOrder
    description?: SortOrder
    raiseAmount?: SortOrderInput | SortOrder
    timeline?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    discord?: SortOrderInput | SortOrder
    telegram?: SortOrderInput | SortOrder
    referralSource?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    adminNotes?: AdminNoteOrderByRelationAggregateInput
  }

  export type LaunchApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LaunchApplicationWhereInput | LaunchApplicationWhereInput[]
    OR?: LaunchApplicationWhereInput[]
    NOT?: LaunchApplicationWhereInput | LaunchApplicationWhereInput[]
    userId?: StringNullableFilter<"LaunchApplication"> | string | null
    applicantName?: StringFilter<"LaunchApplication"> | string
    applicantEmail?: StringFilter<"LaunchApplication"> | string
    applicantRole?: StringNullableFilter<"LaunchApplication"> | string | null
    companyName?: StringNullableFilter<"LaunchApplication"> | string | null
    website?: StringNullableFilter<"LaunchApplication"> | string | null
    type?: EnumApplicationTypeFilter<"LaunchApplication"> | $Enums.ApplicationType
    description?: StringFilter<"LaunchApplication"> | string
    raiseAmount?: StringNullableFilter<"LaunchApplication"> | string | null
    timeline?: StringNullableFilter<"LaunchApplication"> | string | null
    twitter?: StringNullableFilter<"LaunchApplication"> | string | null
    discord?: StringNullableFilter<"LaunchApplication"> | string | null
    telegram?: StringNullableFilter<"LaunchApplication"> | string | null
    referralSource?: StringNullableFilter<"LaunchApplication"> | string | null
    status?: EnumApplicationStatusFilter<"LaunchApplication"> | $Enums.ApplicationStatus
    reviewedBy?: StringNullableFilter<"LaunchApplication"> | string | null
    reviewedAt?: DateTimeNullableFilter<"LaunchApplication"> | Date | string | null
    rejectionReason?: StringNullableFilter<"LaunchApplication"> | string | null
    ipAddress?: StringNullableFilter<"LaunchApplication"> | string | null
    userAgent?: StringNullableFilter<"LaunchApplication"> | string | null
    createdAt?: DateTimeFilter<"LaunchApplication"> | Date | string
    updatedAt?: DateTimeFilter<"LaunchApplication"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    adminNotes?: AdminNoteListRelationFilter
  }, "id">

  export type LaunchApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    applicantName?: SortOrder
    applicantEmail?: SortOrder
    applicantRole?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    type?: SortOrder
    description?: SortOrder
    raiseAmount?: SortOrderInput | SortOrder
    timeline?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    discord?: SortOrderInput | SortOrder
    telegram?: SortOrderInput | SortOrder
    referralSource?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LaunchApplicationCountOrderByAggregateInput
    _max?: LaunchApplicationMaxOrderByAggregateInput
    _min?: LaunchApplicationMinOrderByAggregateInput
  }

  export type LaunchApplicationScalarWhereWithAggregatesInput = {
    AND?: LaunchApplicationScalarWhereWithAggregatesInput | LaunchApplicationScalarWhereWithAggregatesInput[]
    OR?: LaunchApplicationScalarWhereWithAggregatesInput[]
    NOT?: LaunchApplicationScalarWhereWithAggregatesInput | LaunchApplicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LaunchApplication"> | string
    userId?: StringNullableWithAggregatesFilter<"LaunchApplication"> | string | null
    applicantName?: StringWithAggregatesFilter<"LaunchApplication"> | string
    applicantEmail?: StringWithAggregatesFilter<"LaunchApplication"> | string
    applicantRole?: StringNullableWithAggregatesFilter<"LaunchApplication"> | string | null
    companyName?: StringNullableWithAggregatesFilter<"LaunchApplication"> | string | null
    website?: StringNullableWithAggregatesFilter<"LaunchApplication"> | string | null
    type?: EnumApplicationTypeWithAggregatesFilter<"LaunchApplication"> | $Enums.ApplicationType
    description?: StringWithAggregatesFilter<"LaunchApplication"> | string
    raiseAmount?: StringNullableWithAggregatesFilter<"LaunchApplication"> | string | null
    timeline?: StringNullableWithAggregatesFilter<"LaunchApplication"> | string | null
    twitter?: StringNullableWithAggregatesFilter<"LaunchApplication"> | string | null
    discord?: StringNullableWithAggregatesFilter<"LaunchApplication"> | string | null
    telegram?: StringNullableWithAggregatesFilter<"LaunchApplication"> | string | null
    referralSource?: StringNullableWithAggregatesFilter<"LaunchApplication"> | string | null
    status?: EnumApplicationStatusWithAggregatesFilter<"LaunchApplication"> | $Enums.ApplicationStatus
    reviewedBy?: StringNullableWithAggregatesFilter<"LaunchApplication"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"LaunchApplication"> | Date | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"LaunchApplication"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"LaunchApplication"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"LaunchApplication"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LaunchApplication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LaunchApplication"> | Date | string
  }

  export type TrustScoreEventWhereInput = {
    AND?: TrustScoreEventWhereInput | TrustScoreEventWhereInput[]
    OR?: TrustScoreEventWhereInput[]
    NOT?: TrustScoreEventWhereInput | TrustScoreEventWhereInput[]
    id?: StringFilter<"TrustScoreEvent"> | string
    projectId?: StringNullableFilter<"TrustScoreEvent"> | string | null
    businessId?: StringNullableFilter<"TrustScoreEvent"> | string | null
    userId?: StringNullableFilter<"TrustScoreEvent"> | string | null
    eventType?: EnumTrustScoreEventTypeFilter<"TrustScoreEvent"> | $Enums.TrustScoreEventType
    points?: IntFilter<"TrustScoreEvent"> | number
    reason?: StringFilter<"TrustScoreEvent"> | string
    metadata?: JsonNullableFilter<"TrustScoreEvent">
    triggeredBy?: StringNullableFilter<"TrustScoreEvent"> | string | null
    createdAt?: DateTimeFilter<"TrustScoreEvent"> | Date | string
    project?: XOR<CryptoProjectNullableRelationFilter, CryptoProjectWhereInput> | null
    business?: XOR<BusinessNullableRelationFilter, BusinessWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type TrustScoreEventOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrderInput | SortOrder
    businessId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    points?: SortOrder
    reason?: SortOrder
    metadata?: SortOrderInput | SortOrder
    triggeredBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    project?: CryptoProjectOrderByWithRelationInput
    business?: BusinessOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TrustScoreEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrustScoreEventWhereInput | TrustScoreEventWhereInput[]
    OR?: TrustScoreEventWhereInput[]
    NOT?: TrustScoreEventWhereInput | TrustScoreEventWhereInput[]
    projectId?: StringNullableFilter<"TrustScoreEvent"> | string | null
    businessId?: StringNullableFilter<"TrustScoreEvent"> | string | null
    userId?: StringNullableFilter<"TrustScoreEvent"> | string | null
    eventType?: EnumTrustScoreEventTypeFilter<"TrustScoreEvent"> | $Enums.TrustScoreEventType
    points?: IntFilter<"TrustScoreEvent"> | number
    reason?: StringFilter<"TrustScoreEvent"> | string
    metadata?: JsonNullableFilter<"TrustScoreEvent">
    triggeredBy?: StringNullableFilter<"TrustScoreEvent"> | string | null
    createdAt?: DateTimeFilter<"TrustScoreEvent"> | Date | string
    project?: XOR<CryptoProjectNullableRelationFilter, CryptoProjectWhereInput> | null
    business?: XOR<BusinessNullableRelationFilter, BusinessWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type TrustScoreEventOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrderInput | SortOrder
    businessId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    points?: SortOrder
    reason?: SortOrder
    metadata?: SortOrderInput | SortOrder
    triggeredBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TrustScoreEventCountOrderByAggregateInput
    _avg?: TrustScoreEventAvgOrderByAggregateInput
    _max?: TrustScoreEventMaxOrderByAggregateInput
    _min?: TrustScoreEventMinOrderByAggregateInput
    _sum?: TrustScoreEventSumOrderByAggregateInput
  }

  export type TrustScoreEventScalarWhereWithAggregatesInput = {
    AND?: TrustScoreEventScalarWhereWithAggregatesInput | TrustScoreEventScalarWhereWithAggregatesInput[]
    OR?: TrustScoreEventScalarWhereWithAggregatesInput[]
    NOT?: TrustScoreEventScalarWhereWithAggregatesInput | TrustScoreEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrustScoreEvent"> | string
    projectId?: StringNullableWithAggregatesFilter<"TrustScoreEvent"> | string | null
    businessId?: StringNullableWithAggregatesFilter<"TrustScoreEvent"> | string | null
    userId?: StringNullableWithAggregatesFilter<"TrustScoreEvent"> | string | null
    eventType?: EnumTrustScoreEventTypeWithAggregatesFilter<"TrustScoreEvent"> | $Enums.TrustScoreEventType
    points?: IntWithAggregatesFilter<"TrustScoreEvent"> | number
    reason?: StringWithAggregatesFilter<"TrustScoreEvent"> | string
    metadata?: JsonNullableWithAggregatesFilter<"TrustScoreEvent">
    triggeredBy?: StringNullableWithAggregatesFilter<"TrustScoreEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TrustScoreEvent"> | Date | string
  }

  export type AdminNoteWhereInput = {
    AND?: AdminNoteWhereInput | AdminNoteWhereInput[]
    OR?: AdminNoteWhereInput[]
    NOT?: AdminNoteWhereInput | AdminNoteWhereInput[]
    id?: StringFilter<"AdminNote"> | string
    authorId?: StringFilter<"AdminNote"> | string
    projectId?: StringNullableFilter<"AdminNote"> | string | null
    businessId?: StringNullableFilter<"AdminNote"> | string | null
    contactId?: StringNullableFilter<"AdminNote"> | string | null
    applicationId?: StringNullableFilter<"AdminNote"> | string | null
    note?: StringFilter<"AdminNote"> | string
    isInternal?: BoolFilter<"AdminNote"> | boolean
    createdAt?: DateTimeFilter<"AdminNote"> | Date | string
    updatedAt?: DateTimeFilter<"AdminNote"> | Date | string
    author?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<CryptoProjectNullableRelationFilter, CryptoProjectWhereInput> | null
    business?: XOR<BusinessNullableRelationFilter, BusinessWhereInput> | null
    contact?: XOR<ContactMessageNullableRelationFilter, ContactMessageWhereInput> | null
    application?: XOR<LaunchApplicationNullableRelationFilter, LaunchApplicationWhereInput> | null
  }

  export type AdminNoteOrderByWithRelationInput = {
    id?: SortOrder
    authorId?: SortOrder
    projectId?: SortOrderInput | SortOrder
    businessId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    applicationId?: SortOrderInput | SortOrder
    note?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserOrderByWithRelationInput
    project?: CryptoProjectOrderByWithRelationInput
    business?: BusinessOrderByWithRelationInput
    contact?: ContactMessageOrderByWithRelationInput
    application?: LaunchApplicationOrderByWithRelationInput
  }

  export type AdminNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminNoteWhereInput | AdminNoteWhereInput[]
    OR?: AdminNoteWhereInput[]
    NOT?: AdminNoteWhereInput | AdminNoteWhereInput[]
    authorId?: StringFilter<"AdminNote"> | string
    projectId?: StringNullableFilter<"AdminNote"> | string | null
    businessId?: StringNullableFilter<"AdminNote"> | string | null
    contactId?: StringNullableFilter<"AdminNote"> | string | null
    applicationId?: StringNullableFilter<"AdminNote"> | string | null
    note?: StringFilter<"AdminNote"> | string
    isInternal?: BoolFilter<"AdminNote"> | boolean
    createdAt?: DateTimeFilter<"AdminNote"> | Date | string
    updatedAt?: DateTimeFilter<"AdminNote"> | Date | string
    author?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<CryptoProjectNullableRelationFilter, CryptoProjectWhereInput> | null
    business?: XOR<BusinessNullableRelationFilter, BusinessWhereInput> | null
    contact?: XOR<ContactMessageNullableRelationFilter, ContactMessageWhereInput> | null
    application?: XOR<LaunchApplicationNullableRelationFilter, LaunchApplicationWhereInput> | null
  }, "id">

  export type AdminNoteOrderByWithAggregationInput = {
    id?: SortOrder
    authorId?: SortOrder
    projectId?: SortOrderInput | SortOrder
    businessId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    applicationId?: SortOrderInput | SortOrder
    note?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminNoteCountOrderByAggregateInput
    _max?: AdminNoteMaxOrderByAggregateInput
    _min?: AdminNoteMinOrderByAggregateInput
  }

  export type AdminNoteScalarWhereWithAggregatesInput = {
    AND?: AdminNoteScalarWhereWithAggregatesInput | AdminNoteScalarWhereWithAggregatesInput[]
    OR?: AdminNoteScalarWhereWithAggregatesInput[]
    NOT?: AdminNoteScalarWhereWithAggregatesInput | AdminNoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminNote"> | string
    authorId?: StringWithAggregatesFilter<"AdminNote"> | string
    projectId?: StringNullableWithAggregatesFilter<"AdminNote"> | string | null
    businessId?: StringNullableWithAggregatesFilter<"AdminNote"> | string | null
    contactId?: StringNullableWithAggregatesFilter<"AdminNote"> | string | null
    applicationId?: StringNullableWithAggregatesFilter<"AdminNote"> | string | null
    note?: StringWithAggregatesFilter<"AdminNote"> | string
    isInternal?: BoolWithAggregatesFilter<"AdminNote"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AdminNote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminNote"> | Date | string
  }

  export type SystemLogWhereInput = {
    AND?: SystemLogWhereInput | SystemLogWhereInput[]
    OR?: SystemLogWhereInput[]
    NOT?: SystemLogWhereInput | SystemLogWhereInput[]
    id?: StringFilter<"SystemLog"> | string
    level?: EnumLogLevelFilter<"SystemLog"> | $Enums.LogLevel
    category?: EnumLogCategoryFilter<"SystemLog"> | $Enums.LogCategory
    action?: StringFilter<"SystemLog"> | string
    message?: StringFilter<"SystemLog"> | string
    metadata?: JsonNullableFilter<"SystemLog">
    userId?: StringNullableFilter<"SystemLog"> | string | null
    ipAddress?: StringNullableFilter<"SystemLog"> | string | null
    userAgent?: StringNullableFilter<"SystemLog"> | string | null
    requestId?: StringNullableFilter<"SystemLog"> | string | null
    endpoint?: StringNullableFilter<"SystemLog"> | string | null
    method?: StringNullableFilter<"SystemLog"> | string | null
    statusCode?: IntNullableFilter<"SystemLog"> | number | null
    responseTime?: IntNullableFilter<"SystemLog"> | number | null
    createdAt?: DateTimeFilter<"SystemLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type SystemLogOrderByWithRelationInput = {
    id?: SortOrder
    level?: SortOrder
    category?: SortOrder
    action?: SortOrder
    message?: SortOrder
    metadata?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    requestId?: SortOrderInput | SortOrder
    endpoint?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    statusCode?: SortOrderInput | SortOrder
    responseTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SystemLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemLogWhereInput | SystemLogWhereInput[]
    OR?: SystemLogWhereInput[]
    NOT?: SystemLogWhereInput | SystemLogWhereInput[]
    level?: EnumLogLevelFilter<"SystemLog"> | $Enums.LogLevel
    category?: EnumLogCategoryFilter<"SystemLog"> | $Enums.LogCategory
    action?: StringFilter<"SystemLog"> | string
    message?: StringFilter<"SystemLog"> | string
    metadata?: JsonNullableFilter<"SystemLog">
    userId?: StringNullableFilter<"SystemLog"> | string | null
    ipAddress?: StringNullableFilter<"SystemLog"> | string | null
    userAgent?: StringNullableFilter<"SystemLog"> | string | null
    requestId?: StringNullableFilter<"SystemLog"> | string | null
    endpoint?: StringNullableFilter<"SystemLog"> | string | null
    method?: StringNullableFilter<"SystemLog"> | string | null
    statusCode?: IntNullableFilter<"SystemLog"> | number | null
    responseTime?: IntNullableFilter<"SystemLog"> | number | null
    createdAt?: DateTimeFilter<"SystemLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type SystemLogOrderByWithAggregationInput = {
    id?: SortOrder
    level?: SortOrder
    category?: SortOrder
    action?: SortOrder
    message?: SortOrder
    metadata?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    requestId?: SortOrderInput | SortOrder
    endpoint?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    statusCode?: SortOrderInput | SortOrder
    responseTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SystemLogCountOrderByAggregateInput
    _avg?: SystemLogAvgOrderByAggregateInput
    _max?: SystemLogMaxOrderByAggregateInput
    _min?: SystemLogMinOrderByAggregateInput
    _sum?: SystemLogSumOrderByAggregateInput
  }

  export type SystemLogScalarWhereWithAggregatesInput = {
    AND?: SystemLogScalarWhereWithAggregatesInput | SystemLogScalarWhereWithAggregatesInput[]
    OR?: SystemLogScalarWhereWithAggregatesInput[]
    NOT?: SystemLogScalarWhereWithAggregatesInput | SystemLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemLog"> | string
    level?: EnumLogLevelWithAggregatesFilter<"SystemLog"> | $Enums.LogLevel
    category?: EnumLogCategoryWithAggregatesFilter<"SystemLog"> | $Enums.LogCategory
    action?: StringWithAggregatesFilter<"SystemLog"> | string
    message?: StringWithAggregatesFilter<"SystemLog"> | string
    metadata?: JsonNullableWithAggregatesFilter<"SystemLog">
    userId?: StringNullableWithAggregatesFilter<"SystemLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"SystemLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"SystemLog"> | string | null
    requestId?: StringNullableWithAggregatesFilter<"SystemLog"> | string | null
    endpoint?: StringNullableWithAggregatesFilter<"SystemLog"> | string | null
    method?: StringNullableWithAggregatesFilter<"SystemLog"> | string | null
    statusCode?: IntNullableWithAggregatesFilter<"SystemLog"> | number | null
    responseTime?: IntNullableWithAggregatesFilter<"SystemLog"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"SystemLog"> | Date | string
  }

  export type DexPairWhereInput = {
    AND?: DexPairWhereInput | DexPairWhereInput[]
    OR?: DexPairWhereInput[]
    NOT?: DexPairWhereInput | DexPairWhereInput[]
    id?: StringFilter<"DexPair"> | string
    tokenA?: StringFilter<"DexPair"> | string
    tokenB?: StringFilter<"DexPair"> | string
    poolAddress?: StringNullableFilter<"DexPair"> | string | null
    reserveA?: StringNullableFilter<"DexPair"> | string | null
    reserveB?: StringNullableFilter<"DexPair"> | string | null
    fee?: FloatFilter<"DexPair"> | number
    isActive?: BoolFilter<"DexPair"> | boolean
    isRegulated?: BoolFilter<"DexPair"> | boolean
    warmupEndsAt?: DateTimeNullableFilter<"DexPair"> | Date | string | null
    maxSlippage?: FloatFilter<"DexPair"> | number
    createdAt?: DateTimeFilter<"DexPair"> | Date | string
    updatedAt?: DateTimeFilter<"DexPair"> | Date | string
  }

  export type DexPairOrderByWithRelationInput = {
    id?: SortOrder
    tokenA?: SortOrder
    tokenB?: SortOrder
    poolAddress?: SortOrderInput | SortOrder
    reserveA?: SortOrderInput | SortOrder
    reserveB?: SortOrderInput | SortOrder
    fee?: SortOrder
    isActive?: SortOrder
    isRegulated?: SortOrder
    warmupEndsAt?: SortOrderInput | SortOrder
    maxSlippage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DexPairWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tokenA_tokenB?: DexPairTokenATokenBCompoundUniqueInput
    AND?: DexPairWhereInput | DexPairWhereInput[]
    OR?: DexPairWhereInput[]
    NOT?: DexPairWhereInput | DexPairWhereInput[]
    tokenA?: StringFilter<"DexPair"> | string
    tokenB?: StringFilter<"DexPair"> | string
    poolAddress?: StringNullableFilter<"DexPair"> | string | null
    reserveA?: StringNullableFilter<"DexPair"> | string | null
    reserveB?: StringNullableFilter<"DexPair"> | string | null
    fee?: FloatFilter<"DexPair"> | number
    isActive?: BoolFilter<"DexPair"> | boolean
    isRegulated?: BoolFilter<"DexPair"> | boolean
    warmupEndsAt?: DateTimeNullableFilter<"DexPair"> | Date | string | null
    maxSlippage?: FloatFilter<"DexPair"> | number
    createdAt?: DateTimeFilter<"DexPair"> | Date | string
    updatedAt?: DateTimeFilter<"DexPair"> | Date | string
  }, "id" | "tokenA_tokenB">

  export type DexPairOrderByWithAggregationInput = {
    id?: SortOrder
    tokenA?: SortOrder
    tokenB?: SortOrder
    poolAddress?: SortOrderInput | SortOrder
    reserveA?: SortOrderInput | SortOrder
    reserveB?: SortOrderInput | SortOrder
    fee?: SortOrder
    isActive?: SortOrder
    isRegulated?: SortOrder
    warmupEndsAt?: SortOrderInput | SortOrder
    maxSlippage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DexPairCountOrderByAggregateInput
    _avg?: DexPairAvgOrderByAggregateInput
    _max?: DexPairMaxOrderByAggregateInput
    _min?: DexPairMinOrderByAggregateInput
    _sum?: DexPairSumOrderByAggregateInput
  }

  export type DexPairScalarWhereWithAggregatesInput = {
    AND?: DexPairScalarWhereWithAggregatesInput | DexPairScalarWhereWithAggregatesInput[]
    OR?: DexPairScalarWhereWithAggregatesInput[]
    NOT?: DexPairScalarWhereWithAggregatesInput | DexPairScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DexPair"> | string
    tokenA?: StringWithAggregatesFilter<"DexPair"> | string
    tokenB?: StringWithAggregatesFilter<"DexPair"> | string
    poolAddress?: StringNullableWithAggregatesFilter<"DexPair"> | string | null
    reserveA?: StringNullableWithAggregatesFilter<"DexPair"> | string | null
    reserveB?: StringNullableWithAggregatesFilter<"DexPair"> | string | null
    fee?: FloatWithAggregatesFilter<"DexPair"> | number
    isActive?: BoolWithAggregatesFilter<"DexPair"> | boolean
    isRegulated?: BoolWithAggregatesFilter<"DexPair"> | boolean
    warmupEndsAt?: DateTimeNullableWithAggregatesFilter<"DexPair"> | Date | string | null
    maxSlippage?: FloatWithAggregatesFilter<"DexPair"> | number
    createdAt?: DateTimeWithAggregatesFilter<"DexPair"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DexPair"> | Date | string
  }

  export type RateLimitRecordWhereInput = {
    AND?: RateLimitRecordWhereInput | RateLimitRecordWhereInput[]
    OR?: RateLimitRecordWhereInput[]
    NOT?: RateLimitRecordWhereInput | RateLimitRecordWhereInput[]
    id?: StringFilter<"RateLimitRecord"> | string
    identifier?: StringFilter<"RateLimitRecord"> | string
    endpoint?: StringFilter<"RateLimitRecord"> | string
    windowStart?: DateTimeFilter<"RateLimitRecord"> | Date | string
    requestCount?: IntFilter<"RateLimitRecord"> | number
    createdAt?: DateTimeFilter<"RateLimitRecord"> | Date | string
  }

  export type RateLimitRecordOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    endpoint?: SortOrder
    windowStart?: SortOrder
    requestCount?: SortOrder
    createdAt?: SortOrder
  }

  export type RateLimitRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    identifier_endpoint_windowStart?: RateLimitRecordIdentifierEndpointWindowStartCompoundUniqueInput
    AND?: RateLimitRecordWhereInput | RateLimitRecordWhereInput[]
    OR?: RateLimitRecordWhereInput[]
    NOT?: RateLimitRecordWhereInput | RateLimitRecordWhereInput[]
    identifier?: StringFilter<"RateLimitRecord"> | string
    endpoint?: StringFilter<"RateLimitRecord"> | string
    windowStart?: DateTimeFilter<"RateLimitRecord"> | Date | string
    requestCount?: IntFilter<"RateLimitRecord"> | number
    createdAt?: DateTimeFilter<"RateLimitRecord"> | Date | string
  }, "id" | "identifier_endpoint_windowStart">

  export type RateLimitRecordOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    endpoint?: SortOrder
    windowStart?: SortOrder
    requestCount?: SortOrder
    createdAt?: SortOrder
    _count?: RateLimitRecordCountOrderByAggregateInput
    _avg?: RateLimitRecordAvgOrderByAggregateInput
    _max?: RateLimitRecordMaxOrderByAggregateInput
    _min?: RateLimitRecordMinOrderByAggregateInput
    _sum?: RateLimitRecordSumOrderByAggregateInput
  }

  export type RateLimitRecordScalarWhereWithAggregatesInput = {
    AND?: RateLimitRecordScalarWhereWithAggregatesInput | RateLimitRecordScalarWhereWithAggregatesInput[]
    OR?: RateLimitRecordScalarWhereWithAggregatesInput[]
    NOT?: RateLimitRecordScalarWhereWithAggregatesInput | RateLimitRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RateLimitRecord"> | string
    identifier?: StringWithAggregatesFilter<"RateLimitRecord"> | string
    endpoint?: StringWithAggregatesFilter<"RateLimitRecord"> | string
    windowStart?: DateTimeWithAggregatesFilter<"RateLimitRecord"> | Date | string
    requestCount?: IntWithAggregatesFilter<"RateLimitRecord"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RateLimitRecord"> | Date | string
  }

  export type SecurityEventWhereInput = {
    AND?: SecurityEventWhereInput | SecurityEventWhereInput[]
    OR?: SecurityEventWhereInput[]
    NOT?: SecurityEventWhereInput | SecurityEventWhereInput[]
    id?: StringFilter<"SecurityEvent"> | string
    eventType?: StringFilter<"SecurityEvent"> | string
    severity?: StringFilter<"SecurityEvent"> | string
    identifier?: StringNullableFilter<"SecurityEvent"> | string | null
    description?: StringFilter<"SecurityEvent"> | string
    metadata?: JsonNullableFilter<"SecurityEvent">
    actionTaken?: StringNullableFilter<"SecurityEvent"> | string | null
    createdAt?: DateTimeFilter<"SecurityEvent"> | Date | string
  }

  export type SecurityEventOrderByWithRelationInput = {
    id?: SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    identifier?: SortOrderInput | SortOrder
    description?: SortOrder
    metadata?: SortOrderInput | SortOrder
    actionTaken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type SecurityEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SecurityEventWhereInput | SecurityEventWhereInput[]
    OR?: SecurityEventWhereInput[]
    NOT?: SecurityEventWhereInput | SecurityEventWhereInput[]
    eventType?: StringFilter<"SecurityEvent"> | string
    severity?: StringFilter<"SecurityEvent"> | string
    identifier?: StringNullableFilter<"SecurityEvent"> | string | null
    description?: StringFilter<"SecurityEvent"> | string
    metadata?: JsonNullableFilter<"SecurityEvent">
    actionTaken?: StringNullableFilter<"SecurityEvent"> | string | null
    createdAt?: DateTimeFilter<"SecurityEvent"> | Date | string
  }, "id">

  export type SecurityEventOrderByWithAggregationInput = {
    id?: SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    identifier?: SortOrderInput | SortOrder
    description?: SortOrder
    metadata?: SortOrderInput | SortOrder
    actionTaken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SecurityEventCountOrderByAggregateInput
    _max?: SecurityEventMaxOrderByAggregateInput
    _min?: SecurityEventMinOrderByAggregateInput
  }

  export type SecurityEventScalarWhereWithAggregatesInput = {
    AND?: SecurityEventScalarWhereWithAggregatesInput | SecurityEventScalarWhereWithAggregatesInput[]
    OR?: SecurityEventScalarWhereWithAggregatesInput[]
    NOT?: SecurityEventScalarWhereWithAggregatesInput | SecurityEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SecurityEvent"> | string
    eventType?: StringWithAggregatesFilter<"SecurityEvent"> | string
    severity?: StringWithAggregatesFilter<"SecurityEvent"> | string
    identifier?: StringNullableWithAggregatesFilter<"SecurityEvent"> | string | null
    description?: StringWithAggregatesFilter<"SecurityEvent"> | string
    metadata?: JsonNullableWithAggregatesFilter<"SecurityEvent">
    actionTaken?: StringNullableWithAggregatesFilter<"SecurityEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SecurityEvent"> | Date | string
  }

  export type BlockedEntityWhereInput = {
    AND?: BlockedEntityWhereInput | BlockedEntityWhereInput[]
    OR?: BlockedEntityWhereInput[]
    NOT?: BlockedEntityWhereInput | BlockedEntityWhereInput[]
    id?: StringFilter<"BlockedEntity"> | string
    type?: StringFilter<"BlockedEntity"> | string
    value?: StringFilter<"BlockedEntity"> | string
    reason?: StringFilter<"BlockedEntity"> | string
    blockedBy?: StringNullableFilter<"BlockedEntity"> | string | null
    expiresAt?: DateTimeNullableFilter<"BlockedEntity"> | Date | string | null
    isActive?: BoolFilter<"BlockedEntity"> | boolean
    createdAt?: DateTimeFilter<"BlockedEntity"> | Date | string
    updatedAt?: DateTimeFilter<"BlockedEntity"> | Date | string
  }

  export type BlockedEntityOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    value?: SortOrder
    reason?: SortOrder
    blockedBy?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlockedEntityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    type_value?: BlockedEntityTypeValueCompoundUniqueInput
    AND?: BlockedEntityWhereInput | BlockedEntityWhereInput[]
    OR?: BlockedEntityWhereInput[]
    NOT?: BlockedEntityWhereInput | BlockedEntityWhereInput[]
    type?: StringFilter<"BlockedEntity"> | string
    value?: StringFilter<"BlockedEntity"> | string
    reason?: StringFilter<"BlockedEntity"> | string
    blockedBy?: StringNullableFilter<"BlockedEntity"> | string | null
    expiresAt?: DateTimeNullableFilter<"BlockedEntity"> | Date | string | null
    isActive?: BoolFilter<"BlockedEntity"> | boolean
    createdAt?: DateTimeFilter<"BlockedEntity"> | Date | string
    updatedAt?: DateTimeFilter<"BlockedEntity"> | Date | string
  }, "id" | "type_value">

  export type BlockedEntityOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    value?: SortOrder
    reason?: SortOrder
    blockedBy?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BlockedEntityCountOrderByAggregateInput
    _max?: BlockedEntityMaxOrderByAggregateInput
    _min?: BlockedEntityMinOrderByAggregateInput
  }

  export type BlockedEntityScalarWhereWithAggregatesInput = {
    AND?: BlockedEntityScalarWhereWithAggregatesInput | BlockedEntityScalarWhereWithAggregatesInput[]
    OR?: BlockedEntityScalarWhereWithAggregatesInput[]
    NOT?: BlockedEntityScalarWhereWithAggregatesInput | BlockedEntityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BlockedEntity"> | string
    type?: StringWithAggregatesFilter<"BlockedEntity"> | string
    value?: StringWithAggregatesFilter<"BlockedEntity"> | string
    reason?: StringWithAggregatesFilter<"BlockedEntity"> | string
    blockedBy?: StringNullableWithAggregatesFilter<"BlockedEntity"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"BlockedEntity"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"BlockedEntity"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BlockedEntity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BlockedEntity"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    walletAddress?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    isEmailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    displayName?: string | null
    avatarUrl?: string | null
    bio?: string | null
    apiCallCount?: number
    apiCallResetAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cryptoProjects?: CryptoProjectCreateNestedManyWithoutUserInput
    businesses?: BusinessCreateNestedManyWithoutUserInput
    identityVerification?: PrivateIdentityVerificationCreateNestedOneWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    systemLogs?: SystemLogCreateNestedManyWithoutUserInput
    trustScoreEvents?: TrustScoreEventCreateNestedManyWithoutUserInput
    contactMessages?: ContactMessageCreateNestedManyWithoutUserInput
    applications?: LaunchApplicationCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    walletAddress?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    isEmailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    displayName?: string | null
    avatarUrl?: string | null
    bio?: string | null
    apiCallCount?: number
    apiCallResetAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cryptoProjects?: CryptoProjectUncheckedCreateNestedManyWithoutUserInput
    businesses?: BusinessUncheckedCreateNestedManyWithoutUserInput
    identityVerification?: PrivateIdentityVerificationUncheckedCreateNestedOneWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutUserInput
    trustScoreEvents?: TrustScoreEventUncheckedCreateNestedManyWithoutUserInput
    contactMessages?: ContactMessageUncheckedCreateNestedManyWithoutUserInput
    applications?: LaunchApplicationUncheckedCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallCount?: IntFieldUpdateOperationsInput | number
    apiCallResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cryptoProjects?: CryptoProjectUpdateManyWithoutUserNestedInput
    businesses?: BusinessUpdateManyWithoutUserNestedInput
    identityVerification?: PrivateIdentityVerificationUpdateOneWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    systemLogs?: SystemLogUpdateManyWithoutUserNestedInput
    trustScoreEvents?: TrustScoreEventUpdateManyWithoutUserNestedInput
    contactMessages?: ContactMessageUpdateManyWithoutUserNestedInput
    applications?: LaunchApplicationUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallCount?: IntFieldUpdateOperationsInput | number
    apiCallResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cryptoProjects?: CryptoProjectUncheckedUpdateManyWithoutUserNestedInput
    businesses?: BusinessUncheckedUpdateManyWithoutUserNestedInput
    identityVerification?: PrivateIdentityVerificationUncheckedUpdateOneWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutUserNestedInput
    trustScoreEvents?: TrustScoreEventUncheckedUpdateManyWithoutUserNestedInput
    contactMessages?: ContactMessageUncheckedUpdateManyWithoutUserNestedInput
    applications?: LaunchApplicationUncheckedUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    walletAddress?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    isEmailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    displayName?: string | null
    avatarUrl?: string | null
    bio?: string | null
    apiCallCount?: number
    apiCallResetAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallCount?: IntFieldUpdateOperationsInput | number
    apiCallResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallCount?: IntFieldUpdateOperationsInput | number
    apiCallResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    token: string
    refreshToken?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    isRevoked?: boolean
    revokedAt?: Date | string | null
    revokedReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    refreshToken?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    isRevoked?: boolean
    revokedAt?: Date | string | null
    revokedReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    token: string
    refreshToken?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    isRevoked?: boolean
    revokedAt?: Date | string | null
    revokedReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoProjectCreateInput = {
    id?: string
    name: string
    symbol?: string | null
    description?: string | null
    category?: string | null
    website?: string | null
    whitepaper?: string | null
    twitter?: string | null
    discord?: string | null
    telegram?: string | null
    github?: string | null
    tokenType?: $Enums.TokenType
    totalSupply?: string | null
    decimals?: number
    teamAllocationPercent?: number | null
    teamVestingMonths?: number | null
    teamCliffMonths?: number | null
    vestingType?: $Enums.VestingType | null
    initialLiquidity?: string | null
    liquidityLockMonths?: number | null
    liquidityLockTxHash?: string | null
    auditProvider?: string | null
    auditReportUrl?: string | null
    auditDate?: Date | string | null
    contractAddress?: string | null
    contractVerified?: boolean
    status?: $Enums.ProjectStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    rejectionReason?: string | null
    trustScore?: number
    trustScoreUpdatedAt?: Date | string | null
    launchDate?: Date | string | null
    softCap?: string | null
    hardCap?: string | null
    minContribution?: string | null
    maxContribution?: string | null
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCryptoProjectsInput
    trustScoreEvents?: TrustScoreEventCreateNestedManyWithoutProjectInput
    adminNotes?: AdminNoteCreateNestedManyWithoutProjectInput
    documents?: ProjectDocumentCreateNestedManyWithoutProjectInput
  }

  export type CryptoProjectUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    symbol?: string | null
    description?: string | null
    category?: string | null
    website?: string | null
    whitepaper?: string | null
    twitter?: string | null
    discord?: string | null
    telegram?: string | null
    github?: string | null
    tokenType?: $Enums.TokenType
    totalSupply?: string | null
    decimals?: number
    teamAllocationPercent?: number | null
    teamVestingMonths?: number | null
    teamCliffMonths?: number | null
    vestingType?: $Enums.VestingType | null
    initialLiquidity?: string | null
    liquidityLockMonths?: number | null
    liquidityLockTxHash?: string | null
    auditProvider?: string | null
    auditReportUrl?: string | null
    auditDate?: Date | string | null
    contractAddress?: string | null
    contractVerified?: boolean
    status?: $Enums.ProjectStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    rejectionReason?: string | null
    trustScore?: number
    trustScoreUpdatedAt?: Date | string | null
    launchDate?: Date | string | null
    softCap?: string | null
    hardCap?: string | null
    minContribution?: string | null
    maxContribution?: string | null
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    trustScoreEvents?: TrustScoreEventUncheckedCreateNestedManyWithoutProjectInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutProjectInput
    documents?: ProjectDocumentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type CryptoProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    whitepaper?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    totalSupply?: NullableStringFieldUpdateOperationsInput | string | null
    decimals?: IntFieldUpdateOperationsInput | number
    teamAllocationPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    teamVestingMonths?: NullableIntFieldUpdateOperationsInput | number | null
    teamCliffMonths?: NullableIntFieldUpdateOperationsInput | number | null
    vestingType?: NullableEnumVestingTypeFieldUpdateOperationsInput | $Enums.VestingType | null
    initialLiquidity?: NullableStringFieldUpdateOperationsInput | string | null
    liquidityLockMonths?: NullableIntFieldUpdateOperationsInput | number | null
    liquidityLockTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    auditProvider?: NullableStringFieldUpdateOperationsInput | string | null
    auditReportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    auditDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    contractVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    trustScoreUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    launchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    softCap?: NullableStringFieldUpdateOperationsInput | string | null
    hardCap?: NullableStringFieldUpdateOperationsInput | string | null
    minContribution?: NullableStringFieldUpdateOperationsInput | string | null
    maxContribution?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCryptoProjectsNestedInput
    trustScoreEvents?: TrustScoreEventUpdateManyWithoutProjectNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutProjectNestedInput
    documents?: ProjectDocumentUpdateManyWithoutProjectNestedInput
  }

  export type CryptoProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    whitepaper?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    totalSupply?: NullableStringFieldUpdateOperationsInput | string | null
    decimals?: IntFieldUpdateOperationsInput | number
    teamAllocationPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    teamVestingMonths?: NullableIntFieldUpdateOperationsInput | number | null
    teamCliffMonths?: NullableIntFieldUpdateOperationsInput | number | null
    vestingType?: NullableEnumVestingTypeFieldUpdateOperationsInput | $Enums.VestingType | null
    initialLiquidity?: NullableStringFieldUpdateOperationsInput | string | null
    liquidityLockMonths?: NullableIntFieldUpdateOperationsInput | number | null
    liquidityLockTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    auditProvider?: NullableStringFieldUpdateOperationsInput | string | null
    auditReportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    auditDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    contractVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    trustScoreUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    launchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    softCap?: NullableStringFieldUpdateOperationsInput | string | null
    hardCap?: NullableStringFieldUpdateOperationsInput | string | null
    minContribution?: NullableStringFieldUpdateOperationsInput | string | null
    maxContribution?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trustScoreEvents?: TrustScoreEventUncheckedUpdateManyWithoutProjectNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutProjectNestedInput
    documents?: ProjectDocumentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type CryptoProjectCreateManyInput = {
    id?: string
    userId: string
    name: string
    symbol?: string | null
    description?: string | null
    category?: string | null
    website?: string | null
    whitepaper?: string | null
    twitter?: string | null
    discord?: string | null
    telegram?: string | null
    github?: string | null
    tokenType?: $Enums.TokenType
    totalSupply?: string | null
    decimals?: number
    teamAllocationPercent?: number | null
    teamVestingMonths?: number | null
    teamCliffMonths?: number | null
    vestingType?: $Enums.VestingType | null
    initialLiquidity?: string | null
    liquidityLockMonths?: number | null
    liquidityLockTxHash?: string | null
    auditProvider?: string | null
    auditReportUrl?: string | null
    auditDate?: Date | string | null
    contractAddress?: string | null
    contractVerified?: boolean
    status?: $Enums.ProjectStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    rejectionReason?: string | null
    trustScore?: number
    trustScoreUpdatedAt?: Date | string | null
    launchDate?: Date | string | null
    softCap?: string | null
    hardCap?: string | null
    minContribution?: string | null
    maxContribution?: string | null
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    whitepaper?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    totalSupply?: NullableStringFieldUpdateOperationsInput | string | null
    decimals?: IntFieldUpdateOperationsInput | number
    teamAllocationPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    teamVestingMonths?: NullableIntFieldUpdateOperationsInput | number | null
    teamCliffMonths?: NullableIntFieldUpdateOperationsInput | number | null
    vestingType?: NullableEnumVestingTypeFieldUpdateOperationsInput | $Enums.VestingType | null
    initialLiquidity?: NullableStringFieldUpdateOperationsInput | string | null
    liquidityLockMonths?: NullableIntFieldUpdateOperationsInput | number | null
    liquidityLockTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    auditProvider?: NullableStringFieldUpdateOperationsInput | string | null
    auditReportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    auditDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    contractVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    trustScoreUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    launchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    softCap?: NullableStringFieldUpdateOperationsInput | string | null
    hardCap?: NullableStringFieldUpdateOperationsInput | string | null
    minContribution?: NullableStringFieldUpdateOperationsInput | string | null
    maxContribution?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CryptoProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    whitepaper?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    totalSupply?: NullableStringFieldUpdateOperationsInput | string | null
    decimals?: IntFieldUpdateOperationsInput | number
    teamAllocationPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    teamVestingMonths?: NullableIntFieldUpdateOperationsInput | number | null
    teamCliffMonths?: NullableIntFieldUpdateOperationsInput | number | null
    vestingType?: NullableEnumVestingTypeFieldUpdateOperationsInput | $Enums.VestingType | null
    initialLiquidity?: NullableStringFieldUpdateOperationsInput | string | null
    liquidityLockMonths?: NullableIntFieldUpdateOperationsInput | number | null
    liquidityLockTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    auditProvider?: NullableStringFieldUpdateOperationsInput | string | null
    auditReportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    auditDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    contractVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    trustScoreUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    launchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    softCap?: NullableStringFieldUpdateOperationsInput | string | null
    hardCap?: NullableStringFieldUpdateOperationsInput | string | null
    minContribution?: NullableStringFieldUpdateOperationsInput | string | null
    maxContribution?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectDocumentCreateInput = {
    id?: string
    name: string
    type: string
    fileUrl: string
    fileHash?: string | null
    fileSize?: number | null
    mimeType?: string | null
    isPublic?: boolean
    uploadedAt?: Date | string
    project: CryptoProjectCreateNestedOneWithoutDocumentsInput
  }

  export type ProjectDocumentUncheckedCreateInput = {
    id?: string
    projectId: string
    name: string
    type: string
    fileUrl: string
    fileHash?: string | null
    fileSize?: number | null
    mimeType?: string | null
    isPublic?: boolean
    uploadedAt?: Date | string
  }

  export type ProjectDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileHash?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: CryptoProjectUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type ProjectDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileHash?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectDocumentCreateManyInput = {
    id?: string
    projectId: string
    name: string
    type: string
    fileUrl: string
    fileHash?: string | null
    fileSize?: number | null
    mimeType?: string | null
    isPublic?: boolean
    uploadedAt?: Date | string
  }

  export type ProjectDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileHash?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileHash?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessCreateInput = {
    id?: string
    legalName: string
    dba?: string | null
    entityType?: string | null
    jurisdiction?: string | null
    ein?: string | null
    registrationNumber?: string | null
    incorporationDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    businessEmail?: string | null
    businessPhone?: string | null
    website?: string | null
    description?: string | null
    industry?: string | null
    employeeCount?: number | null
    annualRevenue?: string | null
    linkedin?: string | null
    twitter?: string | null
    kybLevel?: $Enums.KYBLevel
    kybProvider?: string | null
    kybVerifiedAt?: Date | string | null
    kybExpiresAt?: Date | string | null
    kybRejectionReason?: string | null
    tokenType?: $Enums.TokenType | null
    raiseAmount?: string | null
    equityPercent?: number | null
    revenueSharePercent?: number | null
    minInvestment?: string | null
    maxInvestment?: string | null
    status?: $Enums.BusinessStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    rejectionReason?: string | null
    trustScore?: number
    trustScoreUpdatedAt?: Date | string | null
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBusinessesInput
    founders?: BusinessFounderCreateNestedManyWithoutBusinessInput
    documents?: BusinessDocumentCreateNestedManyWithoutBusinessInput
    trustScoreEvents?: TrustScoreEventCreateNestedManyWithoutBusinessInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBusinessInput
    revenueReports?: RevenueReportCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateInput = {
    id?: string
    userId: string
    legalName: string
    dba?: string | null
    entityType?: string | null
    jurisdiction?: string | null
    ein?: string | null
    registrationNumber?: string | null
    incorporationDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    businessEmail?: string | null
    businessPhone?: string | null
    website?: string | null
    description?: string | null
    industry?: string | null
    employeeCount?: number | null
    annualRevenue?: string | null
    linkedin?: string | null
    twitter?: string | null
    kybLevel?: $Enums.KYBLevel
    kybProvider?: string | null
    kybVerifiedAt?: Date | string | null
    kybExpiresAt?: Date | string | null
    kybRejectionReason?: string | null
    tokenType?: $Enums.TokenType | null
    raiseAmount?: string | null
    equityPercent?: number | null
    revenueSharePercent?: number | null
    minInvestment?: string | null
    maxInvestment?: string | null
    status?: $Enums.BusinessStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    rejectionReason?: string | null
    trustScore?: number
    trustScoreUpdatedAt?: Date | string | null
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    founders?: BusinessFounderUncheckedCreateNestedManyWithoutBusinessInput
    documents?: BusinessDocumentUncheckedCreateNestedManyWithoutBusinessInput
    trustScoreEvents?: TrustScoreEventUncheckedCreateNestedManyWithoutBusinessInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBusinessInput
    revenueReports?: RevenueReportUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    legalName?: StringFieldUpdateOperationsInput | string
    dba?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    ein?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    incorporationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    businessEmail?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    annualRevenue?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    kybLevel?: EnumKYBLevelFieldUpdateOperationsInput | $Enums.KYBLevel
    kybProvider?: NullableStringFieldUpdateOperationsInput | string | null
    kybVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybRejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableEnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType | null
    raiseAmount?: NullableStringFieldUpdateOperationsInput | string | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    revenueSharePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    maxInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    trustScoreUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBusinessesNestedInput
    founders?: BusinessFounderUpdateManyWithoutBusinessNestedInput
    documents?: BusinessDocumentUpdateManyWithoutBusinessNestedInput
    trustScoreEvents?: TrustScoreEventUpdateManyWithoutBusinessNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBusinessNestedInput
    revenueReports?: RevenueReportUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    legalName?: StringFieldUpdateOperationsInput | string
    dba?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    ein?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    incorporationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    businessEmail?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    annualRevenue?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    kybLevel?: EnumKYBLevelFieldUpdateOperationsInput | $Enums.KYBLevel
    kybProvider?: NullableStringFieldUpdateOperationsInput | string | null
    kybVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybRejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableEnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType | null
    raiseAmount?: NullableStringFieldUpdateOperationsInput | string | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    revenueSharePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    maxInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    trustScoreUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founders?: BusinessFounderUncheckedUpdateManyWithoutBusinessNestedInput
    documents?: BusinessDocumentUncheckedUpdateManyWithoutBusinessNestedInput
    trustScoreEvents?: TrustScoreEventUncheckedUpdateManyWithoutBusinessNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBusinessNestedInput
    revenueReports?: RevenueReportUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessCreateManyInput = {
    id?: string
    userId: string
    legalName: string
    dba?: string | null
    entityType?: string | null
    jurisdiction?: string | null
    ein?: string | null
    registrationNumber?: string | null
    incorporationDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    businessEmail?: string | null
    businessPhone?: string | null
    website?: string | null
    description?: string | null
    industry?: string | null
    employeeCount?: number | null
    annualRevenue?: string | null
    linkedin?: string | null
    twitter?: string | null
    kybLevel?: $Enums.KYBLevel
    kybProvider?: string | null
    kybVerifiedAt?: Date | string | null
    kybExpiresAt?: Date | string | null
    kybRejectionReason?: string | null
    tokenType?: $Enums.TokenType | null
    raiseAmount?: string | null
    equityPercent?: number | null
    revenueSharePercent?: number | null
    minInvestment?: string | null
    maxInvestment?: string | null
    status?: $Enums.BusinessStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    rejectionReason?: string | null
    trustScore?: number
    trustScoreUpdatedAt?: Date | string | null
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    legalName?: StringFieldUpdateOperationsInput | string
    dba?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    ein?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    incorporationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    businessEmail?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    annualRevenue?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    kybLevel?: EnumKYBLevelFieldUpdateOperationsInput | $Enums.KYBLevel
    kybProvider?: NullableStringFieldUpdateOperationsInput | string | null
    kybVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybRejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableEnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType | null
    raiseAmount?: NullableStringFieldUpdateOperationsInput | string | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    revenueSharePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    maxInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    trustScoreUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    legalName?: StringFieldUpdateOperationsInput | string
    dba?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    ein?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    incorporationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    businessEmail?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    annualRevenue?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    kybLevel?: EnumKYBLevelFieldUpdateOperationsInput | $Enums.KYBLevel
    kybProvider?: NullableStringFieldUpdateOperationsInput | string | null
    kybVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybRejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableEnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType | null
    raiseAmount?: NullableStringFieldUpdateOperationsInput | string | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    revenueSharePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    maxInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    trustScoreUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessFounderCreateInput = {
    id?: string
    name: string
    role: string
    email?: string | null
    ownershipPercent?: number | null
    walletAddress?: string | null
    linkedinUrl?: string | null
    kycVerified?: boolean
    kycVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    business: BusinessCreateNestedOneWithoutFoundersInput
  }

  export type BusinessFounderUncheckedCreateInput = {
    id?: string
    businessId: string
    name: string
    role: string
    email?: string | null
    ownershipPercent?: number | null
    walletAddress?: string | null
    linkedinUrl?: string | null
    kycVerified?: boolean
    kycVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessFounderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutFoundersNestedInput
  }

  export type BusinessFounderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessFounderCreateManyInput = {
    id?: string
    businessId: string
    name: string
    role: string
    email?: string | null
    ownershipPercent?: number | null
    walletAddress?: string | null
    linkedinUrl?: string | null
    kycVerified?: boolean
    kycVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessFounderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessFounderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessDocumentCreateInput = {
    id?: string
    name: string
    type: string
    fileUrl: string
    fileHash?: string | null
    fileSize?: number | null
    mimeType?: string | null
    isPublic?: boolean
    isVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    uploadedAt?: Date | string
    business: BusinessCreateNestedOneWithoutDocumentsInput
  }

  export type BusinessDocumentUncheckedCreateInput = {
    id?: string
    businessId: string
    name: string
    type: string
    fileUrl: string
    fileHash?: string | null
    fileSize?: number | null
    mimeType?: string | null
    isPublic?: boolean
    isVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    uploadedAt?: Date | string
  }

  export type BusinessDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileHash?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type BusinessDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileHash?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessDocumentCreateManyInput = {
    id?: string
    businessId: string
    name: string
    type: string
    fileUrl: string
    fileHash?: string | null
    fileSize?: number | null
    mimeType?: string | null
    isPublic?: boolean
    isVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    uploadedAt?: Date | string
  }

  export type BusinessDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileHash?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileHash?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueReportCreateInput = {
    id?: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    grossRevenue: string
    eligibleRevenue?: string | null
    distributionAmount?: string | null
    documentUrl?: string | null
    documentHash?: string | null
    isVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    submittedAt?: Date | string
    business: BusinessCreateNestedOneWithoutRevenueReportsInput
  }

  export type RevenueReportUncheckedCreateInput = {
    id?: string
    businessId: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    grossRevenue: string
    eligibleRevenue?: string | null
    distributionAmount?: string | null
    documentUrl?: string | null
    documentHash?: string | null
    isVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    submittedAt?: Date | string
  }

  export type RevenueReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    grossRevenue?: StringFieldUpdateOperationsInput | string
    eligibleRevenue?: NullableStringFieldUpdateOperationsInput | string | null
    distributionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutRevenueReportsNestedInput
  }

  export type RevenueReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    grossRevenue?: StringFieldUpdateOperationsInput | string
    eligibleRevenue?: NullableStringFieldUpdateOperationsInput | string | null
    distributionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueReportCreateManyInput = {
    id?: string
    businessId: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    grossRevenue: string
    eligibleRevenue?: string | null
    distributionAmount?: string | null
    documentUrl?: string | null
    documentHash?: string | null
    isVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    submittedAt?: Date | string
  }

  export type RevenueReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    grossRevenue?: StringFieldUpdateOperationsInput | string
    eligibleRevenue?: NullableStringFieldUpdateOperationsInput | string | null
    distributionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    grossRevenue?: StringFieldUpdateOperationsInput | string
    eligibleRevenue?: NullableStringFieldUpdateOperationsInput | string | null
    distributionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateIdentityVerificationCreateInput = {
    id?: string
    status?: $Enums.IdentityStatus
    level?: string | null
    provider?: string | null
    providerSessionId?: string | null
    providerStatus?: string | null
    verifiedAt?: Date | string | null
    expiresAt?: Date | string | null
    rejectionReason?: string | null
    retryCount?: number
    lastAttemptAt?: Date | string | null
    isAccredited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutIdentityVerificationInput
  }

  export type PrivateIdentityVerificationUncheckedCreateInput = {
    id?: string
    userId: string
    status?: $Enums.IdentityStatus
    level?: string | null
    provider?: string | null
    providerSessionId?: string | null
    providerStatus?: string | null
    verifiedAt?: Date | string | null
    expiresAt?: Date | string | null
    rejectionReason?: string | null
    retryCount?: number
    lastAttemptAt?: Date | string | null
    isAccredited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivateIdentityVerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumIdentityStatusFieldUpdateOperationsInput | $Enums.IdentityStatus
    level?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    providerStatus?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAccredited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutIdentityVerificationNestedInput
  }

  export type PrivateIdentityVerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumIdentityStatusFieldUpdateOperationsInput | $Enums.IdentityStatus
    level?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    providerStatus?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAccredited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateIdentityVerificationCreateManyInput = {
    id?: string
    userId: string
    status?: $Enums.IdentityStatus
    level?: string | null
    provider?: string | null
    providerSessionId?: string | null
    providerStatus?: string | null
    verifiedAt?: Date | string | null
    expiresAt?: Date | string | null
    rejectionReason?: string | null
    retryCount?: number
    lastAttemptAt?: Date | string | null
    isAccredited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivateIdentityVerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumIdentityStatusFieldUpdateOperationsInput | $Enums.IdentityStatus
    level?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    providerStatus?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAccredited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateIdentityVerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumIdentityStatusFieldUpdateOperationsInput | $Enums.IdentityStatus
    level?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    providerStatus?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAccredited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactMessageCreateInput = {
    id?: string
    name: string
    email: string
    subject?: string | null
    message: string
    category?: string | null
    status?: $Enums.MessageStatus
    assignedTo?: string | null
    responseText?: string | null
    respondedAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutContactMessagesInput
    adminNotes?: AdminNoteCreateNestedManyWithoutContactInput
  }

  export type ContactMessageUncheckedCreateInput = {
    id?: string
    userId?: string | null
    name: string
    email: string
    subject?: string | null
    message: string
    category?: string | null
    status?: $Enums.MessageStatus
    assignedTo?: string | null
    responseText?: string | null
    respondedAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    responseText?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutContactMessagesNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutContactNestedInput
  }

  export type ContactMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    responseText?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactMessageCreateManyInput = {
    id?: string
    userId?: string | null
    name: string
    email: string
    subject?: string | null
    message: string
    category?: string | null
    status?: $Enums.MessageStatus
    assignedTo?: string | null
    responseText?: string | null
    respondedAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    responseText?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    responseText?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunchApplicationCreateInput = {
    id?: string
    applicantName: string
    applicantEmail: string
    applicantRole?: string | null
    companyName?: string | null
    website?: string | null
    type: $Enums.ApplicationType
    description: string
    raiseAmount?: string | null
    timeline?: string | null
    twitter?: string | null
    discord?: string | null
    telegram?: string | null
    referralSource?: string | null
    status?: $Enums.ApplicationStatus
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutApplicationsInput
    adminNotes?: AdminNoteCreateNestedManyWithoutApplicationInput
  }

  export type LaunchApplicationUncheckedCreateInput = {
    id?: string
    userId?: string | null
    applicantName: string
    applicantEmail: string
    applicantRole?: string | null
    companyName?: string | null
    website?: string | null
    type: $Enums.ApplicationType
    description: string
    raiseAmount?: string | null
    timeline?: string | null
    twitter?: string | null
    discord?: string | null
    telegram?: string | null
    referralSource?: string | null
    status?: $Enums.ApplicationStatus
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type LaunchApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantEmail?: StringFieldUpdateOperationsInput | string
    applicantRole?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumApplicationTypeFieldUpdateOperationsInput | $Enums.ApplicationType
    description?: StringFieldUpdateOperationsInput | string
    raiseAmount?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutApplicationsNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutApplicationNestedInput
  }

  export type LaunchApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantEmail?: StringFieldUpdateOperationsInput | string
    applicantRole?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumApplicationTypeFieldUpdateOperationsInput | $Enums.ApplicationType
    description?: StringFieldUpdateOperationsInput | string
    raiseAmount?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type LaunchApplicationCreateManyInput = {
    id?: string
    userId?: string | null
    applicantName: string
    applicantEmail: string
    applicantRole?: string | null
    companyName?: string | null
    website?: string | null
    type: $Enums.ApplicationType
    description: string
    raiseAmount?: string | null
    timeline?: string | null
    twitter?: string | null
    discord?: string | null
    telegram?: string | null
    referralSource?: string | null
    status?: $Enums.ApplicationStatus
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaunchApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantEmail?: StringFieldUpdateOperationsInput | string
    applicantRole?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumApplicationTypeFieldUpdateOperationsInput | $Enums.ApplicationType
    description?: StringFieldUpdateOperationsInput | string
    raiseAmount?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunchApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantEmail?: StringFieldUpdateOperationsInput | string
    applicantRole?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumApplicationTypeFieldUpdateOperationsInput | $Enums.ApplicationType
    description?: StringFieldUpdateOperationsInput | string
    raiseAmount?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrustScoreEventCreateInput = {
    id?: string
    eventType: $Enums.TrustScoreEventType
    points: number
    reason: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredBy?: string | null
    createdAt?: Date | string
    project?: CryptoProjectCreateNestedOneWithoutTrustScoreEventsInput
    business?: BusinessCreateNestedOneWithoutTrustScoreEventsInput
    user?: UserCreateNestedOneWithoutTrustScoreEventsInput
  }

  export type TrustScoreEventUncheckedCreateInput = {
    id?: string
    projectId?: string | null
    businessId?: string | null
    userId?: string | null
    eventType: $Enums.TrustScoreEventType
    points: number
    reason: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredBy?: string | null
    createdAt?: Date | string
  }

  export type TrustScoreEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumTrustScoreEventTypeFieldUpdateOperationsInput | $Enums.TrustScoreEventType
    points?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: CryptoProjectUpdateOneWithoutTrustScoreEventsNestedInput
    business?: BusinessUpdateOneWithoutTrustScoreEventsNestedInput
    user?: UserUpdateOneWithoutTrustScoreEventsNestedInput
  }

  export type TrustScoreEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumTrustScoreEventTypeFieldUpdateOperationsInput | $Enums.TrustScoreEventType
    points?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrustScoreEventCreateManyInput = {
    id?: string
    projectId?: string | null
    businessId?: string | null
    userId?: string | null
    eventType: $Enums.TrustScoreEventType
    points: number
    reason: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredBy?: string | null
    createdAt?: Date | string
  }

  export type TrustScoreEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumTrustScoreEventTypeFieldUpdateOperationsInput | $Enums.TrustScoreEventType
    points?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrustScoreEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumTrustScoreEventTypeFieldUpdateOperationsInput | $Enums.TrustScoreEventType
    points?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminNoteCreateInput = {
    id?: string
    note: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutAdminNotesInput
    project?: CryptoProjectCreateNestedOneWithoutAdminNotesInput
    business?: BusinessCreateNestedOneWithoutAdminNotesInput
    contact?: ContactMessageCreateNestedOneWithoutAdminNotesInput
    application?: LaunchApplicationCreateNestedOneWithoutAdminNotesInput
  }

  export type AdminNoteUncheckedCreateInput = {
    id?: string
    authorId: string
    projectId?: string | null
    businessId?: string | null
    contactId?: string | null
    applicationId?: string | null
    note: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminNoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutAdminNotesNestedInput
    project?: CryptoProjectUpdateOneWithoutAdminNotesNestedInput
    business?: BusinessUpdateOneWithoutAdminNotesNestedInput
    contact?: ContactMessageUpdateOneWithoutAdminNotesNestedInput
    application?: LaunchApplicationUpdateOneWithoutAdminNotesNestedInput
  }

  export type AdminNoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    applicationId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminNoteCreateManyInput = {
    id?: string
    authorId: string
    projectId?: string | null
    businessId?: string | null
    contactId?: string | null
    applicationId?: string | null
    note: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminNoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminNoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    applicationId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLogCreateInput = {
    id?: string
    level: $Enums.LogLevel
    category: $Enums.LogCategory
    action: string
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    requestId?: string | null
    endpoint?: string | null
    method?: string | null
    statusCode?: number | null
    responseTime?: number | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutSystemLogsInput
  }

  export type SystemLogUncheckedCreateInput = {
    id?: string
    level: $Enums.LogLevel
    category: $Enums.LogCategory
    action: string
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    requestId?: string | null
    endpoint?: string | null
    method?: string | null
    statusCode?: number | null
    responseTime?: number | null
    createdAt?: Date | string
  }

  export type SystemLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    category?: EnumLogCategoryFieldUpdateOperationsInput | $Enums.LogCategory
    action?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutSystemLogsNestedInput
  }

  export type SystemLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    category?: EnumLogCategoryFieldUpdateOperationsInput | $Enums.LogCategory
    action?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLogCreateManyInput = {
    id?: string
    level: $Enums.LogLevel
    category: $Enums.LogCategory
    action: string
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    requestId?: string | null
    endpoint?: string | null
    method?: string | null
    statusCode?: number | null
    responseTime?: number | null
    createdAt?: Date | string
  }

  export type SystemLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    category?: EnumLogCategoryFieldUpdateOperationsInput | $Enums.LogCategory
    action?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    category?: EnumLogCategoryFieldUpdateOperationsInput | $Enums.LogCategory
    action?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DexPairCreateInput = {
    id?: string
    tokenA: string
    tokenB: string
    poolAddress?: string | null
    reserveA?: string | null
    reserveB?: string | null
    fee?: number
    isActive?: boolean
    isRegulated?: boolean
    warmupEndsAt?: Date | string | null
    maxSlippage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DexPairUncheckedCreateInput = {
    id?: string
    tokenA: string
    tokenB: string
    poolAddress?: string | null
    reserveA?: string | null
    reserveB?: string | null
    fee?: number
    isActive?: boolean
    isRegulated?: boolean
    warmupEndsAt?: Date | string | null
    maxSlippage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DexPairUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenA?: StringFieldUpdateOperationsInput | string
    tokenB?: StringFieldUpdateOperationsInput | string
    poolAddress?: NullableStringFieldUpdateOperationsInput | string | null
    reserveA?: NullableStringFieldUpdateOperationsInput | string | null
    reserveB?: NullableStringFieldUpdateOperationsInput | string | null
    fee?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isRegulated?: BoolFieldUpdateOperationsInput | boolean
    warmupEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxSlippage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DexPairUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenA?: StringFieldUpdateOperationsInput | string
    tokenB?: StringFieldUpdateOperationsInput | string
    poolAddress?: NullableStringFieldUpdateOperationsInput | string | null
    reserveA?: NullableStringFieldUpdateOperationsInput | string | null
    reserveB?: NullableStringFieldUpdateOperationsInput | string | null
    fee?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isRegulated?: BoolFieldUpdateOperationsInput | boolean
    warmupEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxSlippage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DexPairCreateManyInput = {
    id?: string
    tokenA: string
    tokenB: string
    poolAddress?: string | null
    reserveA?: string | null
    reserveB?: string | null
    fee?: number
    isActive?: boolean
    isRegulated?: boolean
    warmupEndsAt?: Date | string | null
    maxSlippage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DexPairUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenA?: StringFieldUpdateOperationsInput | string
    tokenB?: StringFieldUpdateOperationsInput | string
    poolAddress?: NullableStringFieldUpdateOperationsInput | string | null
    reserveA?: NullableStringFieldUpdateOperationsInput | string | null
    reserveB?: NullableStringFieldUpdateOperationsInput | string | null
    fee?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isRegulated?: BoolFieldUpdateOperationsInput | boolean
    warmupEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxSlippage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DexPairUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenA?: StringFieldUpdateOperationsInput | string
    tokenB?: StringFieldUpdateOperationsInput | string
    poolAddress?: NullableStringFieldUpdateOperationsInput | string | null
    reserveA?: NullableStringFieldUpdateOperationsInput | string | null
    reserveB?: NullableStringFieldUpdateOperationsInput | string | null
    fee?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isRegulated?: BoolFieldUpdateOperationsInput | boolean
    warmupEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxSlippage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RateLimitRecordCreateInput = {
    id?: string
    identifier: string
    endpoint: string
    windowStart: Date | string
    requestCount?: number
    createdAt?: Date | string
  }

  export type RateLimitRecordUncheckedCreateInput = {
    id?: string
    identifier: string
    endpoint: string
    windowStart: Date | string
    requestCount?: number
    createdAt?: Date | string
  }

  export type RateLimitRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    windowStart?: DateTimeFieldUpdateOperationsInput | Date | string
    requestCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RateLimitRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    windowStart?: DateTimeFieldUpdateOperationsInput | Date | string
    requestCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RateLimitRecordCreateManyInput = {
    id?: string
    identifier: string
    endpoint: string
    windowStart: Date | string
    requestCount?: number
    createdAt?: Date | string
  }

  export type RateLimitRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    windowStart?: DateTimeFieldUpdateOperationsInput | Date | string
    requestCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RateLimitRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    windowStart?: DateTimeFieldUpdateOperationsInput | Date | string
    requestCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityEventCreateInput = {
    id?: string
    eventType: string
    severity: string
    identifier?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    actionTaken?: string | null
    createdAt?: Date | string
  }

  export type SecurityEventUncheckedCreateInput = {
    id?: string
    eventType: string
    severity: string
    identifier?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    actionTaken?: string | null
    createdAt?: Date | string
  }

  export type SecurityEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityEventCreateManyInput = {
    id?: string
    eventType: string
    severity: string
    identifier?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    actionTaken?: string | null
    createdAt?: Date | string
  }

  export type SecurityEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    identifier?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedEntityCreateInput = {
    id?: string
    type: string
    value: string
    reason: string
    blockedBy?: string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlockedEntityUncheckedCreateInput = {
    id?: string
    type: string
    value: string
    reason: string
    blockedBy?: string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlockedEntityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    blockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedEntityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    blockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedEntityCreateManyInput = {
    id?: string
    type: string
    value: string
    reason: string
    blockedBy?: string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlockedEntityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    blockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedEntityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    blockedBy?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CryptoProjectListRelationFilter = {
    every?: CryptoProjectWhereInput
    some?: CryptoProjectWhereInput
    none?: CryptoProjectWhereInput
  }

  export type BusinessListRelationFilter = {
    every?: BusinessWhereInput
    some?: BusinessWhereInput
    none?: BusinessWhereInput
  }

  export type PrivateIdentityVerificationNullableRelationFilter = {
    is?: PrivateIdentityVerificationWhereInput | null
    isNot?: PrivateIdentityVerificationWhereInput | null
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type SystemLogListRelationFilter = {
    every?: SystemLogWhereInput
    some?: SystemLogWhereInput
    none?: SystemLogWhereInput
  }

  export type TrustScoreEventListRelationFilter = {
    every?: TrustScoreEventWhereInput
    some?: TrustScoreEventWhereInput
    none?: TrustScoreEventWhereInput
  }

  export type ContactMessageListRelationFilter = {
    every?: ContactMessageWhereInput
    some?: ContactMessageWhereInput
    none?: ContactMessageWhereInput
  }

  export type LaunchApplicationListRelationFilter = {
    every?: LaunchApplicationWhereInput
    some?: LaunchApplicationWhereInput
    none?: LaunchApplicationWhereInput
  }

  export type AdminNoteListRelationFilter = {
    every?: AdminNoteWhereInput
    some?: AdminNoteWhereInput
    none?: AdminNoteWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CryptoProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SystemLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrustScoreEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LaunchApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    walletAddress?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    isEmailVerified?: SortOrder
    emailVerifiedAt?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    failedLoginCount?: SortOrder
    lockedUntil?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    bio?: SortOrder
    apiCallCount?: SortOrder
    apiCallResetAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    failedLoginCount?: SortOrder
    apiCallCount?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    walletAddress?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    isEmailVerified?: SortOrder
    emailVerifiedAt?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    failedLoginCount?: SortOrder
    lockedUntil?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    bio?: SortOrder
    apiCallCount?: SortOrder
    apiCallResetAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    walletAddress?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    isEmailVerified?: SortOrder
    emailVerifiedAt?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    failedLoginCount?: SortOrder
    lockedUntil?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    displayName?: SortOrder
    avatarUrl?: SortOrder
    bio?: SortOrder
    apiCallCount?: SortOrder
    apiCallResetAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    failedLoginCount?: SortOrder
    apiCallCount?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
    revokedAt?: SortOrder
    revokedReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
    revokedAt?: SortOrder
    revokedReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
    revokedAt?: SortOrder
    revokedReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTokenTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TokenType | EnumTokenTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTokenTypeFilter<$PrismaModel> | $Enums.TokenType
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumVestingTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.VestingType | EnumVestingTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.VestingType[] | ListEnumVestingTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VestingType[] | ListEnumVestingTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVestingTypeNullableFilter<$PrismaModel> | $Enums.VestingType | null
  }

  export type EnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type ProjectDocumentListRelationFilter = {
    every?: ProjectDocumentWhereInput
    some?: ProjectDocumentWhereInput
    none?: ProjectDocumentWhereInput
  }

  export type ProjectDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CryptoProjectCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    description?: SortOrder
    category?: SortOrder
    website?: SortOrder
    whitepaper?: SortOrder
    twitter?: SortOrder
    discord?: SortOrder
    telegram?: SortOrder
    github?: SortOrder
    tokenType?: SortOrder
    totalSupply?: SortOrder
    decimals?: SortOrder
    teamAllocationPercent?: SortOrder
    teamVestingMonths?: SortOrder
    teamCliffMonths?: SortOrder
    vestingType?: SortOrder
    initialLiquidity?: SortOrder
    liquidityLockMonths?: SortOrder
    liquidityLockTxHash?: SortOrder
    auditProvider?: SortOrder
    auditReportUrl?: SortOrder
    auditDate?: SortOrder
    contractAddress?: SortOrder
    contractVerified?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrder
    reviewedBy?: SortOrder
    rejectionReason?: SortOrder
    trustScore?: SortOrder
    trustScoreUpdatedAt?: SortOrder
    launchDate?: SortOrder
    softCap?: SortOrder
    hardCap?: SortOrder
    minContribution?: SortOrder
    maxContribution?: SortOrder
    isVerified?: SortOrder
    isFeatured?: SortOrder
    isPaused?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CryptoProjectAvgOrderByAggregateInput = {
    decimals?: SortOrder
    teamAllocationPercent?: SortOrder
    teamVestingMonths?: SortOrder
    teamCliffMonths?: SortOrder
    liquidityLockMonths?: SortOrder
    trustScore?: SortOrder
  }

  export type CryptoProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    description?: SortOrder
    category?: SortOrder
    website?: SortOrder
    whitepaper?: SortOrder
    twitter?: SortOrder
    discord?: SortOrder
    telegram?: SortOrder
    github?: SortOrder
    tokenType?: SortOrder
    totalSupply?: SortOrder
    decimals?: SortOrder
    teamAllocationPercent?: SortOrder
    teamVestingMonths?: SortOrder
    teamCliffMonths?: SortOrder
    vestingType?: SortOrder
    initialLiquidity?: SortOrder
    liquidityLockMonths?: SortOrder
    liquidityLockTxHash?: SortOrder
    auditProvider?: SortOrder
    auditReportUrl?: SortOrder
    auditDate?: SortOrder
    contractAddress?: SortOrder
    contractVerified?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrder
    reviewedBy?: SortOrder
    rejectionReason?: SortOrder
    trustScore?: SortOrder
    trustScoreUpdatedAt?: SortOrder
    launchDate?: SortOrder
    softCap?: SortOrder
    hardCap?: SortOrder
    minContribution?: SortOrder
    maxContribution?: SortOrder
    isVerified?: SortOrder
    isFeatured?: SortOrder
    isPaused?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CryptoProjectMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    description?: SortOrder
    category?: SortOrder
    website?: SortOrder
    whitepaper?: SortOrder
    twitter?: SortOrder
    discord?: SortOrder
    telegram?: SortOrder
    github?: SortOrder
    tokenType?: SortOrder
    totalSupply?: SortOrder
    decimals?: SortOrder
    teamAllocationPercent?: SortOrder
    teamVestingMonths?: SortOrder
    teamCliffMonths?: SortOrder
    vestingType?: SortOrder
    initialLiquidity?: SortOrder
    liquidityLockMonths?: SortOrder
    liquidityLockTxHash?: SortOrder
    auditProvider?: SortOrder
    auditReportUrl?: SortOrder
    auditDate?: SortOrder
    contractAddress?: SortOrder
    contractVerified?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrder
    reviewedBy?: SortOrder
    rejectionReason?: SortOrder
    trustScore?: SortOrder
    trustScoreUpdatedAt?: SortOrder
    launchDate?: SortOrder
    softCap?: SortOrder
    hardCap?: SortOrder
    minContribution?: SortOrder
    maxContribution?: SortOrder
    isVerified?: SortOrder
    isFeatured?: SortOrder
    isPaused?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CryptoProjectSumOrderByAggregateInput = {
    decimals?: SortOrder
    teamAllocationPercent?: SortOrder
    teamVestingMonths?: SortOrder
    teamCliffMonths?: SortOrder
    liquidityLockMonths?: SortOrder
    trustScore?: SortOrder
  }

  export type EnumTokenTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TokenType | EnumTokenTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTokenTypeWithAggregatesFilter<$PrismaModel> | $Enums.TokenType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTokenTypeFilter<$PrismaModel>
    _max?: NestedEnumTokenTypeFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumVestingTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VestingType | EnumVestingTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.VestingType[] | ListEnumVestingTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VestingType[] | ListEnumVestingTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVestingTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.VestingType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumVestingTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumVestingTypeNullableFilter<$PrismaModel>
  }

  export type EnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type CryptoProjectRelationFilter = {
    is?: CryptoProjectWhereInput
    isNot?: CryptoProjectWhereInput
  }

  export type ProjectDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrder
    fileHash?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    isPublic?: SortOrder
    uploadedAt?: SortOrder
  }

  export type ProjectDocumentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type ProjectDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrder
    fileHash?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    isPublic?: SortOrder
    uploadedAt?: SortOrder
  }

  export type ProjectDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrder
    fileHash?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    isPublic?: SortOrder
    uploadedAt?: SortOrder
  }

  export type ProjectDocumentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type EnumKYBLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.KYBLevel | EnumKYBLevelFieldRefInput<$PrismaModel>
    in?: $Enums.KYBLevel[] | ListEnumKYBLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYBLevel[] | ListEnumKYBLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumKYBLevelFilter<$PrismaModel> | $Enums.KYBLevel
  }

  export type EnumTokenTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TokenType | EnumTokenTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTokenTypeNullableFilter<$PrismaModel> | $Enums.TokenType | null
  }

  export type EnumBusinessStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BusinessStatus | EnumBusinessStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BusinessStatus[] | ListEnumBusinessStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BusinessStatus[] | ListEnumBusinessStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBusinessStatusFilter<$PrismaModel> | $Enums.BusinessStatus
  }

  export type BusinessFounderListRelationFilter = {
    every?: BusinessFounderWhereInput
    some?: BusinessFounderWhereInput
    none?: BusinessFounderWhereInput
  }

  export type BusinessDocumentListRelationFilter = {
    every?: BusinessDocumentWhereInput
    some?: BusinessDocumentWhereInput
    none?: BusinessDocumentWhereInput
  }

  export type RevenueReportListRelationFilter = {
    every?: RevenueReportWhereInput
    some?: RevenueReportWhereInput
    none?: RevenueReportWhereInput
  }

  export type BusinessFounderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RevenueReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    legalName?: SortOrder
    dba?: SortOrder
    entityType?: SortOrder
    jurisdiction?: SortOrder
    ein?: SortOrder
    registrationNumber?: SortOrder
    incorporationDate?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    businessEmail?: SortOrder
    businessPhone?: SortOrder
    website?: SortOrder
    description?: SortOrder
    industry?: SortOrder
    employeeCount?: SortOrder
    annualRevenue?: SortOrder
    linkedin?: SortOrder
    twitter?: SortOrder
    kybLevel?: SortOrder
    kybProvider?: SortOrder
    kybVerifiedAt?: SortOrder
    kybExpiresAt?: SortOrder
    kybRejectionReason?: SortOrder
    tokenType?: SortOrder
    raiseAmount?: SortOrder
    equityPercent?: SortOrder
    revenueSharePercent?: SortOrder
    minInvestment?: SortOrder
    maxInvestment?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrder
    reviewedBy?: SortOrder
    rejectionReason?: SortOrder
    trustScore?: SortOrder
    trustScoreUpdatedAt?: SortOrder
    isVerified?: SortOrder
    isFeatured?: SortOrder
    isPaused?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessAvgOrderByAggregateInput = {
    employeeCount?: SortOrder
    equityPercent?: SortOrder
    revenueSharePercent?: SortOrder
    trustScore?: SortOrder
  }

  export type BusinessMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    legalName?: SortOrder
    dba?: SortOrder
    entityType?: SortOrder
    jurisdiction?: SortOrder
    ein?: SortOrder
    registrationNumber?: SortOrder
    incorporationDate?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    businessEmail?: SortOrder
    businessPhone?: SortOrder
    website?: SortOrder
    description?: SortOrder
    industry?: SortOrder
    employeeCount?: SortOrder
    annualRevenue?: SortOrder
    linkedin?: SortOrder
    twitter?: SortOrder
    kybLevel?: SortOrder
    kybProvider?: SortOrder
    kybVerifiedAt?: SortOrder
    kybExpiresAt?: SortOrder
    kybRejectionReason?: SortOrder
    tokenType?: SortOrder
    raiseAmount?: SortOrder
    equityPercent?: SortOrder
    revenueSharePercent?: SortOrder
    minInvestment?: SortOrder
    maxInvestment?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrder
    reviewedBy?: SortOrder
    rejectionReason?: SortOrder
    trustScore?: SortOrder
    trustScoreUpdatedAt?: SortOrder
    isVerified?: SortOrder
    isFeatured?: SortOrder
    isPaused?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    legalName?: SortOrder
    dba?: SortOrder
    entityType?: SortOrder
    jurisdiction?: SortOrder
    ein?: SortOrder
    registrationNumber?: SortOrder
    incorporationDate?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    businessEmail?: SortOrder
    businessPhone?: SortOrder
    website?: SortOrder
    description?: SortOrder
    industry?: SortOrder
    employeeCount?: SortOrder
    annualRevenue?: SortOrder
    linkedin?: SortOrder
    twitter?: SortOrder
    kybLevel?: SortOrder
    kybProvider?: SortOrder
    kybVerifiedAt?: SortOrder
    kybExpiresAt?: SortOrder
    kybRejectionReason?: SortOrder
    tokenType?: SortOrder
    raiseAmount?: SortOrder
    equityPercent?: SortOrder
    revenueSharePercent?: SortOrder
    minInvestment?: SortOrder
    maxInvestment?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrder
    reviewedBy?: SortOrder
    rejectionReason?: SortOrder
    trustScore?: SortOrder
    trustScoreUpdatedAt?: SortOrder
    isVerified?: SortOrder
    isFeatured?: SortOrder
    isPaused?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessSumOrderByAggregateInput = {
    employeeCount?: SortOrder
    equityPercent?: SortOrder
    revenueSharePercent?: SortOrder
    trustScore?: SortOrder
  }

  export type EnumKYBLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KYBLevel | EnumKYBLevelFieldRefInput<$PrismaModel>
    in?: $Enums.KYBLevel[] | ListEnumKYBLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYBLevel[] | ListEnumKYBLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumKYBLevelWithAggregatesFilter<$PrismaModel> | $Enums.KYBLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKYBLevelFilter<$PrismaModel>
    _max?: NestedEnumKYBLevelFilter<$PrismaModel>
  }

  export type EnumTokenTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TokenType | EnumTokenTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTokenTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.TokenType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTokenTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumTokenTypeNullableFilter<$PrismaModel>
  }

  export type EnumBusinessStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BusinessStatus | EnumBusinessStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BusinessStatus[] | ListEnumBusinessStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BusinessStatus[] | ListEnumBusinessStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBusinessStatusWithAggregatesFilter<$PrismaModel> | $Enums.BusinessStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBusinessStatusFilter<$PrismaModel>
    _max?: NestedEnumBusinessStatusFilter<$PrismaModel>
  }

  export type BusinessRelationFilter = {
    is?: BusinessWhereInput
    isNot?: BusinessWhereInput
  }

  export type BusinessFounderCountOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrder
    ownershipPercent?: SortOrder
    walletAddress?: SortOrder
    linkedinUrl?: SortOrder
    kycVerified?: SortOrder
    kycVerifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessFounderAvgOrderByAggregateInput = {
    ownershipPercent?: SortOrder
  }

  export type BusinessFounderMaxOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrder
    ownershipPercent?: SortOrder
    walletAddress?: SortOrder
    linkedinUrl?: SortOrder
    kycVerified?: SortOrder
    kycVerifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessFounderMinOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrder
    ownershipPercent?: SortOrder
    walletAddress?: SortOrder
    linkedinUrl?: SortOrder
    kycVerified?: SortOrder
    kycVerifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessFounderSumOrderByAggregateInput = {
    ownershipPercent?: SortOrder
  }

  export type BusinessDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrder
    fileHash?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    isPublic?: SortOrder
    isVerified?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
    uploadedAt?: SortOrder
  }

  export type BusinessDocumentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type BusinessDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrder
    fileHash?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    isPublic?: SortOrder
    isVerified?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
    uploadedAt?: SortOrder
  }

  export type BusinessDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrder
    fileHash?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    isPublic?: SortOrder
    isVerified?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
    uploadedAt?: SortOrder
  }

  export type BusinessDocumentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type RevenueReportBusinessIdPeriodCompoundUniqueInput = {
    businessId: string
    period: string
  }

  export type RevenueReportCountOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    grossRevenue?: SortOrder
    eligibleRevenue?: SortOrder
    distributionAmount?: SortOrder
    documentUrl?: SortOrder
    documentHash?: SortOrder
    isVerified?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
    submittedAt?: SortOrder
  }

  export type RevenueReportMaxOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    grossRevenue?: SortOrder
    eligibleRevenue?: SortOrder
    distributionAmount?: SortOrder
    documentUrl?: SortOrder
    documentHash?: SortOrder
    isVerified?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
    submittedAt?: SortOrder
  }

  export type RevenueReportMinOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    grossRevenue?: SortOrder
    eligibleRevenue?: SortOrder
    distributionAmount?: SortOrder
    documentUrl?: SortOrder
    documentHash?: SortOrder
    isVerified?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
    submittedAt?: SortOrder
  }

  export type EnumIdentityStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IdentityStatus | EnumIdentityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IdentityStatus[] | ListEnumIdentityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdentityStatus[] | ListEnumIdentityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIdentityStatusFilter<$PrismaModel> | $Enums.IdentityStatus
  }

  export type PrivateIdentityVerificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    level?: SortOrder
    provider?: SortOrder
    providerSessionId?: SortOrder
    providerStatus?: SortOrder
    verifiedAt?: SortOrder
    expiresAt?: SortOrder
    rejectionReason?: SortOrder
    retryCount?: SortOrder
    lastAttemptAt?: SortOrder
    isAccredited?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrivateIdentityVerificationAvgOrderByAggregateInput = {
    retryCount?: SortOrder
  }

  export type PrivateIdentityVerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    level?: SortOrder
    provider?: SortOrder
    providerSessionId?: SortOrder
    providerStatus?: SortOrder
    verifiedAt?: SortOrder
    expiresAt?: SortOrder
    rejectionReason?: SortOrder
    retryCount?: SortOrder
    lastAttemptAt?: SortOrder
    isAccredited?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrivateIdentityVerificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    level?: SortOrder
    provider?: SortOrder
    providerSessionId?: SortOrder
    providerStatus?: SortOrder
    verifiedAt?: SortOrder
    expiresAt?: SortOrder
    rejectionReason?: SortOrder
    retryCount?: SortOrder
    lastAttemptAt?: SortOrder
    isAccredited?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrivateIdentityVerificationSumOrderByAggregateInput = {
    retryCount?: SortOrder
  }

  export type EnumIdentityStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IdentityStatus | EnumIdentityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IdentityStatus[] | ListEnumIdentityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdentityStatus[] | ListEnumIdentityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIdentityStatusWithAggregatesFilter<$PrismaModel> | $Enums.IdentityStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIdentityStatusFilter<$PrismaModel>
    _max?: NestedEnumIdentityStatusFilter<$PrismaModel>
  }

  export type EnumMessageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusFilter<$PrismaModel> | $Enums.MessageStatus
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ContactMessageCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    category?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    responseText?: SortOrder
    respondedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    category?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    responseText?: SortOrder
    respondedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMessageMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    category?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    responseText?: SortOrder
    respondedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMessageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusWithAggregatesFilter<$PrismaModel> | $Enums.MessageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageStatusFilter<$PrismaModel>
    _max?: NestedEnumMessageStatusFilter<$PrismaModel>
  }

  export type EnumApplicationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationType | EnumApplicationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationType[] | ListEnumApplicationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationType[] | ListEnumApplicationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationTypeFilter<$PrismaModel> | $Enums.ApplicationType
  }

  export type EnumApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusFilter<$PrismaModel> | $Enums.ApplicationStatus
  }

  export type LaunchApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    applicantName?: SortOrder
    applicantEmail?: SortOrder
    applicantRole?: SortOrder
    companyName?: SortOrder
    website?: SortOrder
    type?: SortOrder
    description?: SortOrder
    raiseAmount?: SortOrder
    timeline?: SortOrder
    twitter?: SortOrder
    discord?: SortOrder
    telegram?: SortOrder
    referralSource?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    rejectionReason?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaunchApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    applicantName?: SortOrder
    applicantEmail?: SortOrder
    applicantRole?: SortOrder
    companyName?: SortOrder
    website?: SortOrder
    type?: SortOrder
    description?: SortOrder
    raiseAmount?: SortOrder
    timeline?: SortOrder
    twitter?: SortOrder
    discord?: SortOrder
    telegram?: SortOrder
    referralSource?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    rejectionReason?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LaunchApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    applicantName?: SortOrder
    applicantEmail?: SortOrder
    applicantRole?: SortOrder
    companyName?: SortOrder
    website?: SortOrder
    type?: SortOrder
    description?: SortOrder
    raiseAmount?: SortOrder
    timeline?: SortOrder
    twitter?: SortOrder
    discord?: SortOrder
    telegram?: SortOrder
    referralSource?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    rejectionReason?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumApplicationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationType | EnumApplicationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationType[] | ListEnumApplicationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationType[] | ListEnumApplicationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationTypeWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationTypeFilter<$PrismaModel>
    _max?: NestedEnumApplicationTypeFilter<$PrismaModel>
  }

  export type EnumApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicationStatusFilter<$PrismaModel>
  }

  export type EnumTrustScoreEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TrustScoreEventType | EnumTrustScoreEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrustScoreEventType[] | ListEnumTrustScoreEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrustScoreEventType[] | ListEnumTrustScoreEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTrustScoreEventTypeFilter<$PrismaModel> | $Enums.TrustScoreEventType
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type CryptoProjectNullableRelationFilter = {
    is?: CryptoProjectWhereInput | null
    isNot?: CryptoProjectWhereInput | null
  }

  export type BusinessNullableRelationFilter = {
    is?: BusinessWhereInput | null
    isNot?: BusinessWhereInput | null
  }

  export type TrustScoreEventCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    businessId?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    points?: SortOrder
    reason?: SortOrder
    metadata?: SortOrder
    triggeredBy?: SortOrder
    createdAt?: SortOrder
  }

  export type TrustScoreEventAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type TrustScoreEventMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    businessId?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    points?: SortOrder
    reason?: SortOrder
    triggeredBy?: SortOrder
    createdAt?: SortOrder
  }

  export type TrustScoreEventMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    businessId?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    points?: SortOrder
    reason?: SortOrder
    triggeredBy?: SortOrder
    createdAt?: SortOrder
  }

  export type TrustScoreEventSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type EnumTrustScoreEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrustScoreEventType | EnumTrustScoreEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrustScoreEventType[] | ListEnumTrustScoreEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrustScoreEventType[] | ListEnumTrustScoreEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTrustScoreEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.TrustScoreEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrustScoreEventTypeFilter<$PrismaModel>
    _max?: NestedEnumTrustScoreEventTypeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type ContactMessageNullableRelationFilter = {
    is?: ContactMessageWhereInput | null
    isNot?: ContactMessageWhereInput | null
  }

  export type LaunchApplicationNullableRelationFilter = {
    is?: LaunchApplicationWhereInput | null
    isNot?: LaunchApplicationWhereInput | null
  }

  export type AdminNoteCountOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    projectId?: SortOrder
    businessId?: SortOrder
    contactId?: SortOrder
    applicationId?: SortOrder
    note?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    projectId?: SortOrder
    businessId?: SortOrder
    contactId?: SortOrder
    applicationId?: SortOrder
    note?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminNoteMinOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    projectId?: SortOrder
    businessId?: SortOrder
    contactId?: SortOrder
    applicationId?: SortOrder
    note?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumLogLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.LogLevel | EnumLogLevelFieldRefInput<$PrismaModel>
    in?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLogLevelFilter<$PrismaModel> | $Enums.LogLevel
  }

  export type EnumLogCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.LogCategory | EnumLogCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.LogCategory[] | ListEnumLogCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogCategory[] | ListEnumLogCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumLogCategoryFilter<$PrismaModel> | $Enums.LogCategory
  }

  export type SystemLogCountOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    category?: SortOrder
    action?: SortOrder
    message?: SortOrder
    metadata?: SortOrder
    userId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    requestId?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    responseTime?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemLogAvgOrderByAggregateInput = {
    statusCode?: SortOrder
    responseTime?: SortOrder
  }

  export type SystemLogMaxOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    category?: SortOrder
    action?: SortOrder
    message?: SortOrder
    userId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    requestId?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    responseTime?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemLogMinOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    category?: SortOrder
    action?: SortOrder
    message?: SortOrder
    userId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    requestId?: SortOrder
    endpoint?: SortOrder
    method?: SortOrder
    statusCode?: SortOrder
    responseTime?: SortOrder
    createdAt?: SortOrder
  }

  export type SystemLogSumOrderByAggregateInput = {
    statusCode?: SortOrder
    responseTime?: SortOrder
  }

  export type EnumLogLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LogLevel | EnumLogLevelFieldRefInput<$PrismaModel>
    in?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLogLevelWithAggregatesFilter<$PrismaModel> | $Enums.LogLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLogLevelFilter<$PrismaModel>
    _max?: NestedEnumLogLevelFilter<$PrismaModel>
  }

  export type EnumLogCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LogCategory | EnumLogCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.LogCategory[] | ListEnumLogCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogCategory[] | ListEnumLogCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumLogCategoryWithAggregatesFilter<$PrismaModel> | $Enums.LogCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLogCategoryFilter<$PrismaModel>
    _max?: NestedEnumLogCategoryFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DexPairTokenATokenBCompoundUniqueInput = {
    tokenA: string
    tokenB: string
  }

  export type DexPairCountOrderByAggregateInput = {
    id?: SortOrder
    tokenA?: SortOrder
    tokenB?: SortOrder
    poolAddress?: SortOrder
    reserveA?: SortOrder
    reserveB?: SortOrder
    fee?: SortOrder
    isActive?: SortOrder
    isRegulated?: SortOrder
    warmupEndsAt?: SortOrder
    maxSlippage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DexPairAvgOrderByAggregateInput = {
    fee?: SortOrder
    maxSlippage?: SortOrder
  }

  export type DexPairMaxOrderByAggregateInput = {
    id?: SortOrder
    tokenA?: SortOrder
    tokenB?: SortOrder
    poolAddress?: SortOrder
    reserveA?: SortOrder
    reserveB?: SortOrder
    fee?: SortOrder
    isActive?: SortOrder
    isRegulated?: SortOrder
    warmupEndsAt?: SortOrder
    maxSlippage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DexPairMinOrderByAggregateInput = {
    id?: SortOrder
    tokenA?: SortOrder
    tokenB?: SortOrder
    poolAddress?: SortOrder
    reserveA?: SortOrder
    reserveB?: SortOrder
    fee?: SortOrder
    isActive?: SortOrder
    isRegulated?: SortOrder
    warmupEndsAt?: SortOrder
    maxSlippage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DexPairSumOrderByAggregateInput = {
    fee?: SortOrder
    maxSlippage?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type RateLimitRecordIdentifierEndpointWindowStartCompoundUniqueInput = {
    identifier: string
    endpoint: string
    windowStart: Date | string
  }

  export type RateLimitRecordCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    endpoint?: SortOrder
    windowStart?: SortOrder
    requestCount?: SortOrder
    createdAt?: SortOrder
  }

  export type RateLimitRecordAvgOrderByAggregateInput = {
    requestCount?: SortOrder
  }

  export type RateLimitRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    endpoint?: SortOrder
    windowStart?: SortOrder
    requestCount?: SortOrder
    createdAt?: SortOrder
  }

  export type RateLimitRecordMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    endpoint?: SortOrder
    windowStart?: SortOrder
    requestCount?: SortOrder
    createdAt?: SortOrder
  }

  export type RateLimitRecordSumOrderByAggregateInput = {
    requestCount?: SortOrder
  }

  export type SecurityEventCountOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    identifier?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    actionTaken?: SortOrder
    createdAt?: SortOrder
  }

  export type SecurityEventMaxOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    identifier?: SortOrder
    description?: SortOrder
    actionTaken?: SortOrder
    createdAt?: SortOrder
  }

  export type SecurityEventMinOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    severity?: SortOrder
    identifier?: SortOrder
    description?: SortOrder
    actionTaken?: SortOrder
    createdAt?: SortOrder
  }

  export type BlockedEntityTypeValueCompoundUniqueInput = {
    type: string
    value: string
  }

  export type BlockedEntityCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    value?: SortOrder
    reason?: SortOrder
    blockedBy?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlockedEntityMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    value?: SortOrder
    reason?: SortOrder
    blockedBy?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlockedEntityMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    value?: SortOrder
    reason?: SortOrder
    blockedBy?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CryptoProjectCreateNestedManyWithoutUserInput = {
    create?: XOR<CryptoProjectCreateWithoutUserInput, CryptoProjectUncheckedCreateWithoutUserInput> | CryptoProjectCreateWithoutUserInput[] | CryptoProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CryptoProjectCreateOrConnectWithoutUserInput | CryptoProjectCreateOrConnectWithoutUserInput[]
    createMany?: CryptoProjectCreateManyUserInputEnvelope
    connect?: CryptoProjectWhereUniqueInput | CryptoProjectWhereUniqueInput[]
  }

  export type BusinessCreateNestedManyWithoutUserInput = {
    create?: XOR<BusinessCreateWithoutUserInput, BusinessUncheckedCreateWithoutUserInput> | BusinessCreateWithoutUserInput[] | BusinessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BusinessCreateOrConnectWithoutUserInput | BusinessCreateOrConnectWithoutUserInput[]
    createMany?: BusinessCreateManyUserInputEnvelope
    connect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
  }

  export type PrivateIdentityVerificationCreateNestedOneWithoutUserInput = {
    create?: XOR<PrivateIdentityVerificationCreateWithoutUserInput, PrivateIdentityVerificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: PrivateIdentityVerificationCreateOrConnectWithoutUserInput
    connect?: PrivateIdentityVerificationWhereUniqueInput
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type SystemLogCreateNestedManyWithoutUserInput = {
    create?: XOR<SystemLogCreateWithoutUserInput, SystemLogUncheckedCreateWithoutUserInput> | SystemLogCreateWithoutUserInput[] | SystemLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SystemLogCreateOrConnectWithoutUserInput | SystemLogCreateOrConnectWithoutUserInput[]
    createMany?: SystemLogCreateManyUserInputEnvelope
    connect?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
  }

  export type TrustScoreEventCreateNestedManyWithoutUserInput = {
    create?: XOR<TrustScoreEventCreateWithoutUserInput, TrustScoreEventUncheckedCreateWithoutUserInput> | TrustScoreEventCreateWithoutUserInput[] | TrustScoreEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrustScoreEventCreateOrConnectWithoutUserInput | TrustScoreEventCreateOrConnectWithoutUserInput[]
    createMany?: TrustScoreEventCreateManyUserInputEnvelope
    connect?: TrustScoreEventWhereUniqueInput | TrustScoreEventWhereUniqueInput[]
  }

  export type ContactMessageCreateNestedManyWithoutUserInput = {
    create?: XOR<ContactMessageCreateWithoutUserInput, ContactMessageUncheckedCreateWithoutUserInput> | ContactMessageCreateWithoutUserInput[] | ContactMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactMessageCreateOrConnectWithoutUserInput | ContactMessageCreateOrConnectWithoutUserInput[]
    createMany?: ContactMessageCreateManyUserInputEnvelope
    connect?: ContactMessageWhereUniqueInput | ContactMessageWhereUniqueInput[]
  }

  export type LaunchApplicationCreateNestedManyWithoutUserInput = {
    create?: XOR<LaunchApplicationCreateWithoutUserInput, LaunchApplicationUncheckedCreateWithoutUserInput> | LaunchApplicationCreateWithoutUserInput[] | LaunchApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LaunchApplicationCreateOrConnectWithoutUserInput | LaunchApplicationCreateOrConnectWithoutUserInput[]
    createMany?: LaunchApplicationCreateManyUserInputEnvelope
    connect?: LaunchApplicationWhereUniqueInput | LaunchApplicationWhereUniqueInput[]
  }

  export type AdminNoteCreateNestedManyWithoutAuthorInput = {
    create?: XOR<AdminNoteCreateWithoutAuthorInput, AdminNoteUncheckedCreateWithoutAuthorInput> | AdminNoteCreateWithoutAuthorInput[] | AdminNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: AdminNoteCreateOrConnectWithoutAuthorInput | AdminNoteCreateOrConnectWithoutAuthorInput[]
    createMany?: AdminNoteCreateManyAuthorInputEnvelope
    connect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
  }

  export type CryptoProjectUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CryptoProjectCreateWithoutUserInput, CryptoProjectUncheckedCreateWithoutUserInput> | CryptoProjectCreateWithoutUserInput[] | CryptoProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CryptoProjectCreateOrConnectWithoutUserInput | CryptoProjectCreateOrConnectWithoutUserInput[]
    createMany?: CryptoProjectCreateManyUserInputEnvelope
    connect?: CryptoProjectWhereUniqueInput | CryptoProjectWhereUniqueInput[]
  }

  export type BusinessUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BusinessCreateWithoutUserInput, BusinessUncheckedCreateWithoutUserInput> | BusinessCreateWithoutUserInput[] | BusinessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BusinessCreateOrConnectWithoutUserInput | BusinessCreateOrConnectWithoutUserInput[]
    createMany?: BusinessCreateManyUserInputEnvelope
    connect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
  }

  export type PrivateIdentityVerificationUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PrivateIdentityVerificationCreateWithoutUserInput, PrivateIdentityVerificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: PrivateIdentityVerificationCreateOrConnectWithoutUserInput
    connect?: PrivateIdentityVerificationWhereUniqueInput
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type SystemLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SystemLogCreateWithoutUserInput, SystemLogUncheckedCreateWithoutUserInput> | SystemLogCreateWithoutUserInput[] | SystemLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SystemLogCreateOrConnectWithoutUserInput | SystemLogCreateOrConnectWithoutUserInput[]
    createMany?: SystemLogCreateManyUserInputEnvelope
    connect?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
  }

  export type TrustScoreEventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TrustScoreEventCreateWithoutUserInput, TrustScoreEventUncheckedCreateWithoutUserInput> | TrustScoreEventCreateWithoutUserInput[] | TrustScoreEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrustScoreEventCreateOrConnectWithoutUserInput | TrustScoreEventCreateOrConnectWithoutUserInput[]
    createMany?: TrustScoreEventCreateManyUserInputEnvelope
    connect?: TrustScoreEventWhereUniqueInput | TrustScoreEventWhereUniqueInput[]
  }

  export type ContactMessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ContactMessageCreateWithoutUserInput, ContactMessageUncheckedCreateWithoutUserInput> | ContactMessageCreateWithoutUserInput[] | ContactMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactMessageCreateOrConnectWithoutUserInput | ContactMessageCreateOrConnectWithoutUserInput[]
    createMany?: ContactMessageCreateManyUserInputEnvelope
    connect?: ContactMessageWhereUniqueInput | ContactMessageWhereUniqueInput[]
  }

  export type LaunchApplicationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LaunchApplicationCreateWithoutUserInput, LaunchApplicationUncheckedCreateWithoutUserInput> | LaunchApplicationCreateWithoutUserInput[] | LaunchApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LaunchApplicationCreateOrConnectWithoutUserInput | LaunchApplicationCreateOrConnectWithoutUserInput[]
    createMany?: LaunchApplicationCreateManyUserInputEnvelope
    connect?: LaunchApplicationWhereUniqueInput | LaunchApplicationWhereUniqueInput[]
  }

  export type AdminNoteUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<AdminNoteCreateWithoutAuthorInput, AdminNoteUncheckedCreateWithoutAuthorInput> | AdminNoteCreateWithoutAuthorInput[] | AdminNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: AdminNoteCreateOrConnectWithoutAuthorInput | AdminNoteCreateOrConnectWithoutAuthorInput[]
    createMany?: AdminNoteCreateManyAuthorInputEnvelope
    connect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CryptoProjectUpdateManyWithoutUserNestedInput = {
    create?: XOR<CryptoProjectCreateWithoutUserInput, CryptoProjectUncheckedCreateWithoutUserInput> | CryptoProjectCreateWithoutUserInput[] | CryptoProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CryptoProjectCreateOrConnectWithoutUserInput | CryptoProjectCreateOrConnectWithoutUserInput[]
    upsert?: CryptoProjectUpsertWithWhereUniqueWithoutUserInput | CryptoProjectUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CryptoProjectCreateManyUserInputEnvelope
    set?: CryptoProjectWhereUniqueInput | CryptoProjectWhereUniqueInput[]
    disconnect?: CryptoProjectWhereUniqueInput | CryptoProjectWhereUniqueInput[]
    delete?: CryptoProjectWhereUniqueInput | CryptoProjectWhereUniqueInput[]
    connect?: CryptoProjectWhereUniqueInput | CryptoProjectWhereUniqueInput[]
    update?: CryptoProjectUpdateWithWhereUniqueWithoutUserInput | CryptoProjectUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CryptoProjectUpdateManyWithWhereWithoutUserInput | CryptoProjectUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CryptoProjectScalarWhereInput | CryptoProjectScalarWhereInput[]
  }

  export type BusinessUpdateManyWithoutUserNestedInput = {
    create?: XOR<BusinessCreateWithoutUserInput, BusinessUncheckedCreateWithoutUserInput> | BusinessCreateWithoutUserInput[] | BusinessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BusinessCreateOrConnectWithoutUserInput | BusinessCreateOrConnectWithoutUserInput[]
    upsert?: BusinessUpsertWithWhereUniqueWithoutUserInput | BusinessUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BusinessCreateManyUserInputEnvelope
    set?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    disconnect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    delete?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    connect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    update?: BusinessUpdateWithWhereUniqueWithoutUserInput | BusinessUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BusinessUpdateManyWithWhereWithoutUserInput | BusinessUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BusinessScalarWhereInput | BusinessScalarWhereInput[]
  }

  export type PrivateIdentityVerificationUpdateOneWithoutUserNestedInput = {
    create?: XOR<PrivateIdentityVerificationCreateWithoutUserInput, PrivateIdentityVerificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: PrivateIdentityVerificationCreateOrConnectWithoutUserInput
    upsert?: PrivateIdentityVerificationUpsertWithoutUserInput
    disconnect?: PrivateIdentityVerificationWhereInput | boolean
    delete?: PrivateIdentityVerificationWhereInput | boolean
    connect?: PrivateIdentityVerificationWhereUniqueInput
    update?: XOR<XOR<PrivateIdentityVerificationUpdateToOneWithWhereWithoutUserInput, PrivateIdentityVerificationUpdateWithoutUserInput>, PrivateIdentityVerificationUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type SystemLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<SystemLogCreateWithoutUserInput, SystemLogUncheckedCreateWithoutUserInput> | SystemLogCreateWithoutUserInput[] | SystemLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SystemLogCreateOrConnectWithoutUserInput | SystemLogCreateOrConnectWithoutUserInput[]
    upsert?: SystemLogUpsertWithWhereUniqueWithoutUserInput | SystemLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SystemLogCreateManyUserInputEnvelope
    set?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    disconnect?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    delete?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    connect?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    update?: SystemLogUpdateWithWhereUniqueWithoutUserInput | SystemLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SystemLogUpdateManyWithWhereWithoutUserInput | SystemLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SystemLogScalarWhereInput | SystemLogScalarWhereInput[]
  }

  export type TrustScoreEventUpdateManyWithoutUserNestedInput = {
    create?: XOR<TrustScoreEventCreateWithoutUserInput, TrustScoreEventUncheckedCreateWithoutUserInput> | TrustScoreEventCreateWithoutUserInput[] | TrustScoreEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrustScoreEventCreateOrConnectWithoutUserInput | TrustScoreEventCreateOrConnectWithoutUserInput[]
    upsert?: TrustScoreEventUpsertWithWhereUniqueWithoutUserInput | TrustScoreEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TrustScoreEventCreateManyUserInputEnvelope
    set?: TrustScoreEventWhereUniqueInput | TrustScoreEventWhereUniqueInput[]
    disconnect?: TrustScoreEventWhereUniqueInput | TrustScoreEventWhereUniqueInput[]
    delete?: TrustScoreEventWhereUniqueInput | TrustScoreEventWhereUniqueInput[]
    connect?: TrustScoreEventWhereUniqueInput | TrustScoreEventWhereUniqueInput[]
    update?: TrustScoreEventUpdateWithWhereUniqueWithoutUserInput | TrustScoreEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TrustScoreEventUpdateManyWithWhereWithoutUserInput | TrustScoreEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TrustScoreEventScalarWhereInput | TrustScoreEventScalarWhereInput[]
  }

  export type ContactMessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContactMessageCreateWithoutUserInput, ContactMessageUncheckedCreateWithoutUserInput> | ContactMessageCreateWithoutUserInput[] | ContactMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactMessageCreateOrConnectWithoutUserInput | ContactMessageCreateOrConnectWithoutUserInput[]
    upsert?: ContactMessageUpsertWithWhereUniqueWithoutUserInput | ContactMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContactMessageCreateManyUserInputEnvelope
    set?: ContactMessageWhereUniqueInput | ContactMessageWhereUniqueInput[]
    disconnect?: ContactMessageWhereUniqueInput | ContactMessageWhereUniqueInput[]
    delete?: ContactMessageWhereUniqueInput | ContactMessageWhereUniqueInput[]
    connect?: ContactMessageWhereUniqueInput | ContactMessageWhereUniqueInput[]
    update?: ContactMessageUpdateWithWhereUniqueWithoutUserInput | ContactMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContactMessageUpdateManyWithWhereWithoutUserInput | ContactMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContactMessageScalarWhereInput | ContactMessageScalarWhereInput[]
  }

  export type LaunchApplicationUpdateManyWithoutUserNestedInput = {
    create?: XOR<LaunchApplicationCreateWithoutUserInput, LaunchApplicationUncheckedCreateWithoutUserInput> | LaunchApplicationCreateWithoutUserInput[] | LaunchApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LaunchApplicationCreateOrConnectWithoutUserInput | LaunchApplicationCreateOrConnectWithoutUserInput[]
    upsert?: LaunchApplicationUpsertWithWhereUniqueWithoutUserInput | LaunchApplicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LaunchApplicationCreateManyUserInputEnvelope
    set?: LaunchApplicationWhereUniqueInput | LaunchApplicationWhereUniqueInput[]
    disconnect?: LaunchApplicationWhereUniqueInput | LaunchApplicationWhereUniqueInput[]
    delete?: LaunchApplicationWhereUniqueInput | LaunchApplicationWhereUniqueInput[]
    connect?: LaunchApplicationWhereUniqueInput | LaunchApplicationWhereUniqueInput[]
    update?: LaunchApplicationUpdateWithWhereUniqueWithoutUserInput | LaunchApplicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LaunchApplicationUpdateManyWithWhereWithoutUserInput | LaunchApplicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LaunchApplicationScalarWhereInput | LaunchApplicationScalarWhereInput[]
  }

  export type AdminNoteUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<AdminNoteCreateWithoutAuthorInput, AdminNoteUncheckedCreateWithoutAuthorInput> | AdminNoteCreateWithoutAuthorInput[] | AdminNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: AdminNoteCreateOrConnectWithoutAuthorInput | AdminNoteCreateOrConnectWithoutAuthorInput[]
    upsert?: AdminNoteUpsertWithWhereUniqueWithoutAuthorInput | AdminNoteUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: AdminNoteCreateManyAuthorInputEnvelope
    set?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    disconnect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    delete?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    connect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    update?: AdminNoteUpdateWithWhereUniqueWithoutAuthorInput | AdminNoteUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: AdminNoteUpdateManyWithWhereWithoutAuthorInput | AdminNoteUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: AdminNoteScalarWhereInput | AdminNoteScalarWhereInput[]
  }

  export type CryptoProjectUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CryptoProjectCreateWithoutUserInput, CryptoProjectUncheckedCreateWithoutUserInput> | CryptoProjectCreateWithoutUserInput[] | CryptoProjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CryptoProjectCreateOrConnectWithoutUserInput | CryptoProjectCreateOrConnectWithoutUserInput[]
    upsert?: CryptoProjectUpsertWithWhereUniqueWithoutUserInput | CryptoProjectUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CryptoProjectCreateManyUserInputEnvelope
    set?: CryptoProjectWhereUniqueInput | CryptoProjectWhereUniqueInput[]
    disconnect?: CryptoProjectWhereUniqueInput | CryptoProjectWhereUniqueInput[]
    delete?: CryptoProjectWhereUniqueInput | CryptoProjectWhereUniqueInput[]
    connect?: CryptoProjectWhereUniqueInput | CryptoProjectWhereUniqueInput[]
    update?: CryptoProjectUpdateWithWhereUniqueWithoutUserInput | CryptoProjectUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CryptoProjectUpdateManyWithWhereWithoutUserInput | CryptoProjectUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CryptoProjectScalarWhereInput | CryptoProjectScalarWhereInput[]
  }

  export type BusinessUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BusinessCreateWithoutUserInput, BusinessUncheckedCreateWithoutUserInput> | BusinessCreateWithoutUserInput[] | BusinessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BusinessCreateOrConnectWithoutUserInput | BusinessCreateOrConnectWithoutUserInput[]
    upsert?: BusinessUpsertWithWhereUniqueWithoutUserInput | BusinessUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BusinessCreateManyUserInputEnvelope
    set?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    disconnect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    delete?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    connect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    update?: BusinessUpdateWithWhereUniqueWithoutUserInput | BusinessUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BusinessUpdateManyWithWhereWithoutUserInput | BusinessUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BusinessScalarWhereInput | BusinessScalarWhereInput[]
  }

  export type PrivateIdentityVerificationUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PrivateIdentityVerificationCreateWithoutUserInput, PrivateIdentityVerificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: PrivateIdentityVerificationCreateOrConnectWithoutUserInput
    upsert?: PrivateIdentityVerificationUpsertWithoutUserInput
    disconnect?: PrivateIdentityVerificationWhereInput | boolean
    delete?: PrivateIdentityVerificationWhereInput | boolean
    connect?: PrivateIdentityVerificationWhereUniqueInput
    update?: XOR<XOR<PrivateIdentityVerificationUpdateToOneWithWhereWithoutUserInput, PrivateIdentityVerificationUpdateWithoutUserInput>, PrivateIdentityVerificationUncheckedUpdateWithoutUserInput>
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type SystemLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SystemLogCreateWithoutUserInput, SystemLogUncheckedCreateWithoutUserInput> | SystemLogCreateWithoutUserInput[] | SystemLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SystemLogCreateOrConnectWithoutUserInput | SystemLogCreateOrConnectWithoutUserInput[]
    upsert?: SystemLogUpsertWithWhereUniqueWithoutUserInput | SystemLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SystemLogCreateManyUserInputEnvelope
    set?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    disconnect?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    delete?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    connect?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    update?: SystemLogUpdateWithWhereUniqueWithoutUserInput | SystemLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SystemLogUpdateManyWithWhereWithoutUserInput | SystemLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SystemLogScalarWhereInput | SystemLogScalarWhereInput[]
  }

  export type TrustScoreEventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TrustScoreEventCreateWithoutUserInput, TrustScoreEventUncheckedCreateWithoutUserInput> | TrustScoreEventCreateWithoutUserInput[] | TrustScoreEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TrustScoreEventCreateOrConnectWithoutUserInput | TrustScoreEventCreateOrConnectWithoutUserInput[]
    upsert?: TrustScoreEventUpsertWithWhereUniqueWithoutUserInput | TrustScoreEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TrustScoreEventCreateManyUserInputEnvelope
    set?: TrustScoreEventWhereUniqueInput | TrustScoreEventWhereUniqueInput[]
    disconnect?: TrustScoreEventWhereUniqueInput | TrustScoreEventWhereUniqueInput[]
    delete?: TrustScoreEventWhereUniqueInput | TrustScoreEventWhereUniqueInput[]
    connect?: TrustScoreEventWhereUniqueInput | TrustScoreEventWhereUniqueInput[]
    update?: TrustScoreEventUpdateWithWhereUniqueWithoutUserInput | TrustScoreEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TrustScoreEventUpdateManyWithWhereWithoutUserInput | TrustScoreEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TrustScoreEventScalarWhereInput | TrustScoreEventScalarWhereInput[]
  }

  export type ContactMessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContactMessageCreateWithoutUserInput, ContactMessageUncheckedCreateWithoutUserInput> | ContactMessageCreateWithoutUserInput[] | ContactMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactMessageCreateOrConnectWithoutUserInput | ContactMessageCreateOrConnectWithoutUserInput[]
    upsert?: ContactMessageUpsertWithWhereUniqueWithoutUserInput | ContactMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContactMessageCreateManyUserInputEnvelope
    set?: ContactMessageWhereUniqueInput | ContactMessageWhereUniqueInput[]
    disconnect?: ContactMessageWhereUniqueInput | ContactMessageWhereUniqueInput[]
    delete?: ContactMessageWhereUniqueInput | ContactMessageWhereUniqueInput[]
    connect?: ContactMessageWhereUniqueInput | ContactMessageWhereUniqueInput[]
    update?: ContactMessageUpdateWithWhereUniqueWithoutUserInput | ContactMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContactMessageUpdateManyWithWhereWithoutUserInput | ContactMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContactMessageScalarWhereInput | ContactMessageScalarWhereInput[]
  }

  export type LaunchApplicationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LaunchApplicationCreateWithoutUserInput, LaunchApplicationUncheckedCreateWithoutUserInput> | LaunchApplicationCreateWithoutUserInput[] | LaunchApplicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LaunchApplicationCreateOrConnectWithoutUserInput | LaunchApplicationCreateOrConnectWithoutUserInput[]
    upsert?: LaunchApplicationUpsertWithWhereUniqueWithoutUserInput | LaunchApplicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LaunchApplicationCreateManyUserInputEnvelope
    set?: LaunchApplicationWhereUniqueInput | LaunchApplicationWhereUniqueInput[]
    disconnect?: LaunchApplicationWhereUniqueInput | LaunchApplicationWhereUniqueInput[]
    delete?: LaunchApplicationWhereUniqueInput | LaunchApplicationWhereUniqueInput[]
    connect?: LaunchApplicationWhereUniqueInput | LaunchApplicationWhereUniqueInput[]
    update?: LaunchApplicationUpdateWithWhereUniqueWithoutUserInput | LaunchApplicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LaunchApplicationUpdateManyWithWhereWithoutUserInput | LaunchApplicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LaunchApplicationScalarWhereInput | LaunchApplicationScalarWhereInput[]
  }

  export type AdminNoteUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<AdminNoteCreateWithoutAuthorInput, AdminNoteUncheckedCreateWithoutAuthorInput> | AdminNoteCreateWithoutAuthorInput[] | AdminNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: AdminNoteCreateOrConnectWithoutAuthorInput | AdminNoteCreateOrConnectWithoutAuthorInput[]
    upsert?: AdminNoteUpsertWithWhereUniqueWithoutAuthorInput | AdminNoteUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: AdminNoteCreateManyAuthorInputEnvelope
    set?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    disconnect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    delete?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    connect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    update?: AdminNoteUpdateWithWhereUniqueWithoutAuthorInput | AdminNoteUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: AdminNoteUpdateManyWithWhereWithoutAuthorInput | AdminNoteUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: AdminNoteScalarWhereInput | AdminNoteScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutCryptoProjectsInput = {
    create?: XOR<UserCreateWithoutCryptoProjectsInput, UserUncheckedCreateWithoutCryptoProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCryptoProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type TrustScoreEventCreateNestedManyWithoutProjectInput = {
    create?: XOR<TrustScoreEventCreateWithoutProjectInput, TrustScoreEventUncheckedCreateWithoutProjectInput> | TrustScoreEventCreateWithoutProjectInput[] | TrustScoreEventUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TrustScoreEventCreateOrConnectWithoutProjectInput | TrustScoreEventCreateOrConnectWithoutProjectInput[]
    createMany?: TrustScoreEventCreateManyProjectInputEnvelope
    connect?: TrustScoreEventWhereUniqueInput | TrustScoreEventWhereUniqueInput[]
  }

  export type AdminNoteCreateNestedManyWithoutProjectInput = {
    create?: XOR<AdminNoteCreateWithoutProjectInput, AdminNoteUncheckedCreateWithoutProjectInput> | AdminNoteCreateWithoutProjectInput[] | AdminNoteUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AdminNoteCreateOrConnectWithoutProjectInput | AdminNoteCreateOrConnectWithoutProjectInput[]
    createMany?: AdminNoteCreateManyProjectInputEnvelope
    connect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
  }

  export type ProjectDocumentCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectDocumentCreateWithoutProjectInput, ProjectDocumentUncheckedCreateWithoutProjectInput> | ProjectDocumentCreateWithoutProjectInput[] | ProjectDocumentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectDocumentCreateOrConnectWithoutProjectInput | ProjectDocumentCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectDocumentCreateManyProjectInputEnvelope
    connect?: ProjectDocumentWhereUniqueInput | ProjectDocumentWhereUniqueInput[]
  }

  export type TrustScoreEventUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TrustScoreEventCreateWithoutProjectInput, TrustScoreEventUncheckedCreateWithoutProjectInput> | TrustScoreEventCreateWithoutProjectInput[] | TrustScoreEventUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TrustScoreEventCreateOrConnectWithoutProjectInput | TrustScoreEventCreateOrConnectWithoutProjectInput[]
    createMany?: TrustScoreEventCreateManyProjectInputEnvelope
    connect?: TrustScoreEventWhereUniqueInput | TrustScoreEventWhereUniqueInput[]
  }

  export type AdminNoteUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<AdminNoteCreateWithoutProjectInput, AdminNoteUncheckedCreateWithoutProjectInput> | AdminNoteCreateWithoutProjectInput[] | AdminNoteUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AdminNoteCreateOrConnectWithoutProjectInput | AdminNoteCreateOrConnectWithoutProjectInput[]
    createMany?: AdminNoteCreateManyProjectInputEnvelope
    connect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
  }

  export type ProjectDocumentUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectDocumentCreateWithoutProjectInput, ProjectDocumentUncheckedCreateWithoutProjectInput> | ProjectDocumentCreateWithoutProjectInput[] | ProjectDocumentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectDocumentCreateOrConnectWithoutProjectInput | ProjectDocumentCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectDocumentCreateManyProjectInputEnvelope
    connect?: ProjectDocumentWhereUniqueInput | ProjectDocumentWhereUniqueInput[]
  }

  export type EnumTokenTypeFieldUpdateOperationsInput = {
    set?: $Enums.TokenType
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumVestingTypeFieldUpdateOperationsInput = {
    set?: $Enums.VestingType | null
  }

  export type EnumProjectStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProjectStatus
  }

  export type UserUpdateOneRequiredWithoutCryptoProjectsNestedInput = {
    create?: XOR<UserCreateWithoutCryptoProjectsInput, UserUncheckedCreateWithoutCryptoProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCryptoProjectsInput
    upsert?: UserUpsertWithoutCryptoProjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCryptoProjectsInput, UserUpdateWithoutCryptoProjectsInput>, UserUncheckedUpdateWithoutCryptoProjectsInput>
  }

  export type TrustScoreEventUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TrustScoreEventCreateWithoutProjectInput, TrustScoreEventUncheckedCreateWithoutProjectInput> | TrustScoreEventCreateWithoutProjectInput[] | TrustScoreEventUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TrustScoreEventCreateOrConnectWithoutProjectInput | TrustScoreEventCreateOrConnectWithoutProjectInput[]
    upsert?: TrustScoreEventUpsertWithWhereUniqueWithoutProjectInput | TrustScoreEventUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TrustScoreEventCreateManyProjectInputEnvelope
    set?: TrustScoreEventWhereUniqueInput | TrustScoreEventWhereUniqueInput[]
    disconnect?: TrustScoreEventWhereUniqueInput | TrustScoreEventWhereUniqueInput[]
    delete?: TrustScoreEventWhereUniqueInput | TrustScoreEventWhereUniqueInput[]
    connect?: TrustScoreEventWhereUniqueInput | TrustScoreEventWhereUniqueInput[]
    update?: TrustScoreEventUpdateWithWhereUniqueWithoutProjectInput | TrustScoreEventUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TrustScoreEventUpdateManyWithWhereWithoutProjectInput | TrustScoreEventUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TrustScoreEventScalarWhereInput | TrustScoreEventScalarWhereInput[]
  }

  export type AdminNoteUpdateManyWithoutProjectNestedInput = {
    create?: XOR<AdminNoteCreateWithoutProjectInput, AdminNoteUncheckedCreateWithoutProjectInput> | AdminNoteCreateWithoutProjectInput[] | AdminNoteUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AdminNoteCreateOrConnectWithoutProjectInput | AdminNoteCreateOrConnectWithoutProjectInput[]
    upsert?: AdminNoteUpsertWithWhereUniqueWithoutProjectInput | AdminNoteUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: AdminNoteCreateManyProjectInputEnvelope
    set?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    disconnect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    delete?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    connect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    update?: AdminNoteUpdateWithWhereUniqueWithoutProjectInput | AdminNoteUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: AdminNoteUpdateManyWithWhereWithoutProjectInput | AdminNoteUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: AdminNoteScalarWhereInput | AdminNoteScalarWhereInput[]
  }

  export type ProjectDocumentUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectDocumentCreateWithoutProjectInput, ProjectDocumentUncheckedCreateWithoutProjectInput> | ProjectDocumentCreateWithoutProjectInput[] | ProjectDocumentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectDocumentCreateOrConnectWithoutProjectInput | ProjectDocumentCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectDocumentUpsertWithWhereUniqueWithoutProjectInput | ProjectDocumentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectDocumentCreateManyProjectInputEnvelope
    set?: ProjectDocumentWhereUniqueInput | ProjectDocumentWhereUniqueInput[]
    disconnect?: ProjectDocumentWhereUniqueInput | ProjectDocumentWhereUniqueInput[]
    delete?: ProjectDocumentWhereUniqueInput | ProjectDocumentWhereUniqueInput[]
    connect?: ProjectDocumentWhereUniqueInput | ProjectDocumentWhereUniqueInput[]
    update?: ProjectDocumentUpdateWithWhereUniqueWithoutProjectInput | ProjectDocumentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectDocumentUpdateManyWithWhereWithoutProjectInput | ProjectDocumentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectDocumentScalarWhereInput | ProjectDocumentScalarWhereInput[]
  }

  export type TrustScoreEventUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TrustScoreEventCreateWithoutProjectInput, TrustScoreEventUncheckedCreateWithoutProjectInput> | TrustScoreEventCreateWithoutProjectInput[] | TrustScoreEventUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TrustScoreEventCreateOrConnectWithoutProjectInput | TrustScoreEventCreateOrConnectWithoutProjectInput[]
    upsert?: TrustScoreEventUpsertWithWhereUniqueWithoutProjectInput | TrustScoreEventUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TrustScoreEventCreateManyProjectInputEnvelope
    set?: TrustScoreEventWhereUniqueInput | TrustScoreEventWhereUniqueInput[]
    disconnect?: TrustScoreEventWhereUniqueInput | TrustScoreEventWhereUniqueInput[]
    delete?: TrustScoreEventWhereUniqueInput | TrustScoreEventWhereUniqueInput[]
    connect?: TrustScoreEventWhereUniqueInput | TrustScoreEventWhereUniqueInput[]
    update?: TrustScoreEventUpdateWithWhereUniqueWithoutProjectInput | TrustScoreEventUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TrustScoreEventUpdateManyWithWhereWithoutProjectInput | TrustScoreEventUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TrustScoreEventScalarWhereInput | TrustScoreEventScalarWhereInput[]
  }

  export type AdminNoteUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<AdminNoteCreateWithoutProjectInput, AdminNoteUncheckedCreateWithoutProjectInput> | AdminNoteCreateWithoutProjectInput[] | AdminNoteUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AdminNoteCreateOrConnectWithoutProjectInput | AdminNoteCreateOrConnectWithoutProjectInput[]
    upsert?: AdminNoteUpsertWithWhereUniqueWithoutProjectInput | AdminNoteUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: AdminNoteCreateManyProjectInputEnvelope
    set?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    disconnect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    delete?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    connect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    update?: AdminNoteUpdateWithWhereUniqueWithoutProjectInput | AdminNoteUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: AdminNoteUpdateManyWithWhereWithoutProjectInput | AdminNoteUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: AdminNoteScalarWhereInput | AdminNoteScalarWhereInput[]
  }

  export type ProjectDocumentUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectDocumentCreateWithoutProjectInput, ProjectDocumentUncheckedCreateWithoutProjectInput> | ProjectDocumentCreateWithoutProjectInput[] | ProjectDocumentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectDocumentCreateOrConnectWithoutProjectInput | ProjectDocumentCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectDocumentUpsertWithWhereUniqueWithoutProjectInput | ProjectDocumentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectDocumentCreateManyProjectInputEnvelope
    set?: ProjectDocumentWhereUniqueInput | ProjectDocumentWhereUniqueInput[]
    disconnect?: ProjectDocumentWhereUniqueInput | ProjectDocumentWhereUniqueInput[]
    delete?: ProjectDocumentWhereUniqueInput | ProjectDocumentWhereUniqueInput[]
    connect?: ProjectDocumentWhereUniqueInput | ProjectDocumentWhereUniqueInput[]
    update?: ProjectDocumentUpdateWithWhereUniqueWithoutProjectInput | ProjectDocumentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectDocumentUpdateManyWithWhereWithoutProjectInput | ProjectDocumentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectDocumentScalarWhereInput | ProjectDocumentScalarWhereInput[]
  }

  export type CryptoProjectCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<CryptoProjectCreateWithoutDocumentsInput, CryptoProjectUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: CryptoProjectCreateOrConnectWithoutDocumentsInput
    connect?: CryptoProjectWhereUniqueInput
  }

  export type CryptoProjectUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<CryptoProjectCreateWithoutDocumentsInput, CryptoProjectUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: CryptoProjectCreateOrConnectWithoutDocumentsInput
    upsert?: CryptoProjectUpsertWithoutDocumentsInput
    connect?: CryptoProjectWhereUniqueInput
    update?: XOR<XOR<CryptoProjectUpdateToOneWithWhereWithoutDocumentsInput, CryptoProjectUpdateWithoutDocumentsInput>, CryptoProjectUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserCreateNestedOneWithoutBusinessesInput = {
    create?: XOR<UserCreateWithoutBusinessesInput, UserUncheckedCreateWithoutBusinessesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBusinessesInput
    connect?: UserWhereUniqueInput
  }

  export type BusinessFounderCreateNestedManyWithoutBusinessInput = {
    create?: XOR<BusinessFounderCreateWithoutBusinessInput, BusinessFounderUncheckedCreateWithoutBusinessInput> | BusinessFounderCreateWithoutBusinessInput[] | BusinessFounderUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: BusinessFounderCreateOrConnectWithoutBusinessInput | BusinessFounderCreateOrConnectWithoutBusinessInput[]
    createMany?: BusinessFounderCreateManyBusinessInputEnvelope
    connect?: BusinessFounderWhereUniqueInput | BusinessFounderWhereUniqueInput[]
  }

  export type BusinessDocumentCreateNestedManyWithoutBusinessInput = {
    create?: XOR<BusinessDocumentCreateWithoutBusinessInput, BusinessDocumentUncheckedCreateWithoutBusinessInput> | BusinessDocumentCreateWithoutBusinessInput[] | BusinessDocumentUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: BusinessDocumentCreateOrConnectWithoutBusinessInput | BusinessDocumentCreateOrConnectWithoutBusinessInput[]
    createMany?: BusinessDocumentCreateManyBusinessInputEnvelope
    connect?: BusinessDocumentWhereUniqueInput | BusinessDocumentWhereUniqueInput[]
  }

  export type TrustScoreEventCreateNestedManyWithoutBusinessInput = {
    create?: XOR<TrustScoreEventCreateWithoutBusinessInput, TrustScoreEventUncheckedCreateWithoutBusinessInput> | TrustScoreEventCreateWithoutBusinessInput[] | TrustScoreEventUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: TrustScoreEventCreateOrConnectWithoutBusinessInput | TrustScoreEventCreateOrConnectWithoutBusinessInput[]
    createMany?: TrustScoreEventCreateManyBusinessInputEnvelope
    connect?: TrustScoreEventWhereUniqueInput | TrustScoreEventWhereUniqueInput[]
  }

  export type AdminNoteCreateNestedManyWithoutBusinessInput = {
    create?: XOR<AdminNoteCreateWithoutBusinessInput, AdminNoteUncheckedCreateWithoutBusinessInput> | AdminNoteCreateWithoutBusinessInput[] | AdminNoteUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: AdminNoteCreateOrConnectWithoutBusinessInput | AdminNoteCreateOrConnectWithoutBusinessInput[]
    createMany?: AdminNoteCreateManyBusinessInputEnvelope
    connect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
  }

  export type RevenueReportCreateNestedManyWithoutBusinessInput = {
    create?: XOR<RevenueReportCreateWithoutBusinessInput, RevenueReportUncheckedCreateWithoutBusinessInput> | RevenueReportCreateWithoutBusinessInput[] | RevenueReportUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: RevenueReportCreateOrConnectWithoutBusinessInput | RevenueReportCreateOrConnectWithoutBusinessInput[]
    createMany?: RevenueReportCreateManyBusinessInputEnvelope
    connect?: RevenueReportWhereUniqueInput | RevenueReportWhereUniqueInput[]
  }

  export type BusinessFounderUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<BusinessFounderCreateWithoutBusinessInput, BusinessFounderUncheckedCreateWithoutBusinessInput> | BusinessFounderCreateWithoutBusinessInput[] | BusinessFounderUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: BusinessFounderCreateOrConnectWithoutBusinessInput | BusinessFounderCreateOrConnectWithoutBusinessInput[]
    createMany?: BusinessFounderCreateManyBusinessInputEnvelope
    connect?: BusinessFounderWhereUniqueInput | BusinessFounderWhereUniqueInput[]
  }

  export type BusinessDocumentUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<BusinessDocumentCreateWithoutBusinessInput, BusinessDocumentUncheckedCreateWithoutBusinessInput> | BusinessDocumentCreateWithoutBusinessInput[] | BusinessDocumentUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: BusinessDocumentCreateOrConnectWithoutBusinessInput | BusinessDocumentCreateOrConnectWithoutBusinessInput[]
    createMany?: BusinessDocumentCreateManyBusinessInputEnvelope
    connect?: BusinessDocumentWhereUniqueInput | BusinessDocumentWhereUniqueInput[]
  }

  export type TrustScoreEventUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<TrustScoreEventCreateWithoutBusinessInput, TrustScoreEventUncheckedCreateWithoutBusinessInput> | TrustScoreEventCreateWithoutBusinessInput[] | TrustScoreEventUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: TrustScoreEventCreateOrConnectWithoutBusinessInput | TrustScoreEventCreateOrConnectWithoutBusinessInput[]
    createMany?: TrustScoreEventCreateManyBusinessInputEnvelope
    connect?: TrustScoreEventWhereUniqueInput | TrustScoreEventWhereUniqueInput[]
  }

  export type AdminNoteUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<AdminNoteCreateWithoutBusinessInput, AdminNoteUncheckedCreateWithoutBusinessInput> | AdminNoteCreateWithoutBusinessInput[] | AdminNoteUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: AdminNoteCreateOrConnectWithoutBusinessInput | AdminNoteCreateOrConnectWithoutBusinessInput[]
    createMany?: AdminNoteCreateManyBusinessInputEnvelope
    connect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
  }

  export type RevenueReportUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<RevenueReportCreateWithoutBusinessInput, RevenueReportUncheckedCreateWithoutBusinessInput> | RevenueReportCreateWithoutBusinessInput[] | RevenueReportUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: RevenueReportCreateOrConnectWithoutBusinessInput | RevenueReportCreateOrConnectWithoutBusinessInput[]
    createMany?: RevenueReportCreateManyBusinessInputEnvelope
    connect?: RevenueReportWhereUniqueInput | RevenueReportWhereUniqueInput[]
  }

  export type EnumKYBLevelFieldUpdateOperationsInput = {
    set?: $Enums.KYBLevel
  }

  export type NullableEnumTokenTypeFieldUpdateOperationsInput = {
    set?: $Enums.TokenType | null
  }

  export type EnumBusinessStatusFieldUpdateOperationsInput = {
    set?: $Enums.BusinessStatus
  }

  export type UserUpdateOneRequiredWithoutBusinessesNestedInput = {
    create?: XOR<UserCreateWithoutBusinessesInput, UserUncheckedCreateWithoutBusinessesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBusinessesInput
    upsert?: UserUpsertWithoutBusinessesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBusinessesInput, UserUpdateWithoutBusinessesInput>, UserUncheckedUpdateWithoutBusinessesInput>
  }

  export type BusinessFounderUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<BusinessFounderCreateWithoutBusinessInput, BusinessFounderUncheckedCreateWithoutBusinessInput> | BusinessFounderCreateWithoutBusinessInput[] | BusinessFounderUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: BusinessFounderCreateOrConnectWithoutBusinessInput | BusinessFounderCreateOrConnectWithoutBusinessInput[]
    upsert?: BusinessFounderUpsertWithWhereUniqueWithoutBusinessInput | BusinessFounderUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: BusinessFounderCreateManyBusinessInputEnvelope
    set?: BusinessFounderWhereUniqueInput | BusinessFounderWhereUniqueInput[]
    disconnect?: BusinessFounderWhereUniqueInput | BusinessFounderWhereUniqueInput[]
    delete?: BusinessFounderWhereUniqueInput | BusinessFounderWhereUniqueInput[]
    connect?: BusinessFounderWhereUniqueInput | BusinessFounderWhereUniqueInput[]
    update?: BusinessFounderUpdateWithWhereUniqueWithoutBusinessInput | BusinessFounderUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: BusinessFounderUpdateManyWithWhereWithoutBusinessInput | BusinessFounderUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: BusinessFounderScalarWhereInput | BusinessFounderScalarWhereInput[]
  }

  export type BusinessDocumentUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<BusinessDocumentCreateWithoutBusinessInput, BusinessDocumentUncheckedCreateWithoutBusinessInput> | BusinessDocumentCreateWithoutBusinessInput[] | BusinessDocumentUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: BusinessDocumentCreateOrConnectWithoutBusinessInput | BusinessDocumentCreateOrConnectWithoutBusinessInput[]
    upsert?: BusinessDocumentUpsertWithWhereUniqueWithoutBusinessInput | BusinessDocumentUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: BusinessDocumentCreateManyBusinessInputEnvelope
    set?: BusinessDocumentWhereUniqueInput | BusinessDocumentWhereUniqueInput[]
    disconnect?: BusinessDocumentWhereUniqueInput | BusinessDocumentWhereUniqueInput[]
    delete?: BusinessDocumentWhereUniqueInput | BusinessDocumentWhereUniqueInput[]
    connect?: BusinessDocumentWhereUniqueInput | BusinessDocumentWhereUniqueInput[]
    update?: BusinessDocumentUpdateWithWhereUniqueWithoutBusinessInput | BusinessDocumentUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: BusinessDocumentUpdateManyWithWhereWithoutBusinessInput | BusinessDocumentUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: BusinessDocumentScalarWhereInput | BusinessDocumentScalarWhereInput[]
  }

  export type TrustScoreEventUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<TrustScoreEventCreateWithoutBusinessInput, TrustScoreEventUncheckedCreateWithoutBusinessInput> | TrustScoreEventCreateWithoutBusinessInput[] | TrustScoreEventUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: TrustScoreEventCreateOrConnectWithoutBusinessInput | TrustScoreEventCreateOrConnectWithoutBusinessInput[]
    upsert?: TrustScoreEventUpsertWithWhereUniqueWithoutBusinessInput | TrustScoreEventUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: TrustScoreEventCreateManyBusinessInputEnvelope
    set?: TrustScoreEventWhereUniqueInput | TrustScoreEventWhereUniqueInput[]
    disconnect?: TrustScoreEventWhereUniqueInput | TrustScoreEventWhereUniqueInput[]
    delete?: TrustScoreEventWhereUniqueInput | TrustScoreEventWhereUniqueInput[]
    connect?: TrustScoreEventWhereUniqueInput | TrustScoreEventWhereUniqueInput[]
    update?: TrustScoreEventUpdateWithWhereUniqueWithoutBusinessInput | TrustScoreEventUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: TrustScoreEventUpdateManyWithWhereWithoutBusinessInput | TrustScoreEventUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: TrustScoreEventScalarWhereInput | TrustScoreEventScalarWhereInput[]
  }

  export type AdminNoteUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<AdminNoteCreateWithoutBusinessInput, AdminNoteUncheckedCreateWithoutBusinessInput> | AdminNoteCreateWithoutBusinessInput[] | AdminNoteUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: AdminNoteCreateOrConnectWithoutBusinessInput | AdminNoteCreateOrConnectWithoutBusinessInput[]
    upsert?: AdminNoteUpsertWithWhereUniqueWithoutBusinessInput | AdminNoteUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: AdminNoteCreateManyBusinessInputEnvelope
    set?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    disconnect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    delete?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    connect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    update?: AdminNoteUpdateWithWhereUniqueWithoutBusinessInput | AdminNoteUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: AdminNoteUpdateManyWithWhereWithoutBusinessInput | AdminNoteUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: AdminNoteScalarWhereInput | AdminNoteScalarWhereInput[]
  }

  export type RevenueReportUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<RevenueReportCreateWithoutBusinessInput, RevenueReportUncheckedCreateWithoutBusinessInput> | RevenueReportCreateWithoutBusinessInput[] | RevenueReportUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: RevenueReportCreateOrConnectWithoutBusinessInput | RevenueReportCreateOrConnectWithoutBusinessInput[]
    upsert?: RevenueReportUpsertWithWhereUniqueWithoutBusinessInput | RevenueReportUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: RevenueReportCreateManyBusinessInputEnvelope
    set?: RevenueReportWhereUniqueInput | RevenueReportWhereUniqueInput[]
    disconnect?: RevenueReportWhereUniqueInput | RevenueReportWhereUniqueInput[]
    delete?: RevenueReportWhereUniqueInput | RevenueReportWhereUniqueInput[]
    connect?: RevenueReportWhereUniqueInput | RevenueReportWhereUniqueInput[]
    update?: RevenueReportUpdateWithWhereUniqueWithoutBusinessInput | RevenueReportUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: RevenueReportUpdateManyWithWhereWithoutBusinessInput | RevenueReportUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: RevenueReportScalarWhereInput | RevenueReportScalarWhereInput[]
  }

  export type BusinessFounderUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<BusinessFounderCreateWithoutBusinessInput, BusinessFounderUncheckedCreateWithoutBusinessInput> | BusinessFounderCreateWithoutBusinessInput[] | BusinessFounderUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: BusinessFounderCreateOrConnectWithoutBusinessInput | BusinessFounderCreateOrConnectWithoutBusinessInput[]
    upsert?: BusinessFounderUpsertWithWhereUniqueWithoutBusinessInput | BusinessFounderUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: BusinessFounderCreateManyBusinessInputEnvelope
    set?: BusinessFounderWhereUniqueInput | BusinessFounderWhereUniqueInput[]
    disconnect?: BusinessFounderWhereUniqueInput | BusinessFounderWhereUniqueInput[]
    delete?: BusinessFounderWhereUniqueInput | BusinessFounderWhereUniqueInput[]
    connect?: BusinessFounderWhereUniqueInput | BusinessFounderWhereUniqueInput[]
    update?: BusinessFounderUpdateWithWhereUniqueWithoutBusinessInput | BusinessFounderUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: BusinessFounderUpdateManyWithWhereWithoutBusinessInput | BusinessFounderUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: BusinessFounderScalarWhereInput | BusinessFounderScalarWhereInput[]
  }

  export type BusinessDocumentUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<BusinessDocumentCreateWithoutBusinessInput, BusinessDocumentUncheckedCreateWithoutBusinessInput> | BusinessDocumentCreateWithoutBusinessInput[] | BusinessDocumentUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: BusinessDocumentCreateOrConnectWithoutBusinessInput | BusinessDocumentCreateOrConnectWithoutBusinessInput[]
    upsert?: BusinessDocumentUpsertWithWhereUniqueWithoutBusinessInput | BusinessDocumentUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: BusinessDocumentCreateManyBusinessInputEnvelope
    set?: BusinessDocumentWhereUniqueInput | BusinessDocumentWhereUniqueInput[]
    disconnect?: BusinessDocumentWhereUniqueInput | BusinessDocumentWhereUniqueInput[]
    delete?: BusinessDocumentWhereUniqueInput | BusinessDocumentWhereUniqueInput[]
    connect?: BusinessDocumentWhereUniqueInput | BusinessDocumentWhereUniqueInput[]
    update?: BusinessDocumentUpdateWithWhereUniqueWithoutBusinessInput | BusinessDocumentUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: BusinessDocumentUpdateManyWithWhereWithoutBusinessInput | BusinessDocumentUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: BusinessDocumentScalarWhereInput | BusinessDocumentScalarWhereInput[]
  }

  export type TrustScoreEventUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<TrustScoreEventCreateWithoutBusinessInput, TrustScoreEventUncheckedCreateWithoutBusinessInput> | TrustScoreEventCreateWithoutBusinessInput[] | TrustScoreEventUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: TrustScoreEventCreateOrConnectWithoutBusinessInput | TrustScoreEventCreateOrConnectWithoutBusinessInput[]
    upsert?: TrustScoreEventUpsertWithWhereUniqueWithoutBusinessInput | TrustScoreEventUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: TrustScoreEventCreateManyBusinessInputEnvelope
    set?: TrustScoreEventWhereUniqueInput | TrustScoreEventWhereUniqueInput[]
    disconnect?: TrustScoreEventWhereUniqueInput | TrustScoreEventWhereUniqueInput[]
    delete?: TrustScoreEventWhereUniqueInput | TrustScoreEventWhereUniqueInput[]
    connect?: TrustScoreEventWhereUniqueInput | TrustScoreEventWhereUniqueInput[]
    update?: TrustScoreEventUpdateWithWhereUniqueWithoutBusinessInput | TrustScoreEventUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: TrustScoreEventUpdateManyWithWhereWithoutBusinessInput | TrustScoreEventUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: TrustScoreEventScalarWhereInput | TrustScoreEventScalarWhereInput[]
  }

  export type AdminNoteUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<AdminNoteCreateWithoutBusinessInput, AdminNoteUncheckedCreateWithoutBusinessInput> | AdminNoteCreateWithoutBusinessInput[] | AdminNoteUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: AdminNoteCreateOrConnectWithoutBusinessInput | AdminNoteCreateOrConnectWithoutBusinessInput[]
    upsert?: AdminNoteUpsertWithWhereUniqueWithoutBusinessInput | AdminNoteUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: AdminNoteCreateManyBusinessInputEnvelope
    set?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    disconnect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    delete?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    connect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    update?: AdminNoteUpdateWithWhereUniqueWithoutBusinessInput | AdminNoteUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: AdminNoteUpdateManyWithWhereWithoutBusinessInput | AdminNoteUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: AdminNoteScalarWhereInput | AdminNoteScalarWhereInput[]
  }

  export type RevenueReportUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<RevenueReportCreateWithoutBusinessInput, RevenueReportUncheckedCreateWithoutBusinessInput> | RevenueReportCreateWithoutBusinessInput[] | RevenueReportUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: RevenueReportCreateOrConnectWithoutBusinessInput | RevenueReportCreateOrConnectWithoutBusinessInput[]
    upsert?: RevenueReportUpsertWithWhereUniqueWithoutBusinessInput | RevenueReportUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: RevenueReportCreateManyBusinessInputEnvelope
    set?: RevenueReportWhereUniqueInput | RevenueReportWhereUniqueInput[]
    disconnect?: RevenueReportWhereUniqueInput | RevenueReportWhereUniqueInput[]
    delete?: RevenueReportWhereUniqueInput | RevenueReportWhereUniqueInput[]
    connect?: RevenueReportWhereUniqueInput | RevenueReportWhereUniqueInput[]
    update?: RevenueReportUpdateWithWhereUniqueWithoutBusinessInput | RevenueReportUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: RevenueReportUpdateManyWithWhereWithoutBusinessInput | RevenueReportUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: RevenueReportScalarWhereInput | RevenueReportScalarWhereInput[]
  }

  export type BusinessCreateNestedOneWithoutFoundersInput = {
    create?: XOR<BusinessCreateWithoutFoundersInput, BusinessUncheckedCreateWithoutFoundersInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutFoundersInput
    connect?: BusinessWhereUniqueInput
  }

  export type BusinessUpdateOneRequiredWithoutFoundersNestedInput = {
    create?: XOR<BusinessCreateWithoutFoundersInput, BusinessUncheckedCreateWithoutFoundersInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutFoundersInput
    upsert?: BusinessUpsertWithoutFoundersInput
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutFoundersInput, BusinessUpdateWithoutFoundersInput>, BusinessUncheckedUpdateWithoutFoundersInput>
  }

  export type BusinessCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<BusinessCreateWithoutDocumentsInput, BusinessUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutDocumentsInput
    connect?: BusinessWhereUniqueInput
  }

  export type BusinessUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<BusinessCreateWithoutDocumentsInput, BusinessUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutDocumentsInput
    upsert?: BusinessUpsertWithoutDocumentsInput
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutDocumentsInput, BusinessUpdateWithoutDocumentsInput>, BusinessUncheckedUpdateWithoutDocumentsInput>
  }

  export type BusinessCreateNestedOneWithoutRevenueReportsInput = {
    create?: XOR<BusinessCreateWithoutRevenueReportsInput, BusinessUncheckedCreateWithoutRevenueReportsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutRevenueReportsInput
    connect?: BusinessWhereUniqueInput
  }

  export type BusinessUpdateOneRequiredWithoutRevenueReportsNestedInput = {
    create?: XOR<BusinessCreateWithoutRevenueReportsInput, BusinessUncheckedCreateWithoutRevenueReportsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutRevenueReportsInput
    upsert?: BusinessUpsertWithoutRevenueReportsInput
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutRevenueReportsInput, BusinessUpdateWithoutRevenueReportsInput>, BusinessUncheckedUpdateWithoutRevenueReportsInput>
  }

  export type UserCreateNestedOneWithoutIdentityVerificationInput = {
    create?: XOR<UserCreateWithoutIdentityVerificationInput, UserUncheckedCreateWithoutIdentityVerificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutIdentityVerificationInput
    connect?: UserWhereUniqueInput
  }

  export type EnumIdentityStatusFieldUpdateOperationsInput = {
    set?: $Enums.IdentityStatus
  }

  export type UserUpdateOneRequiredWithoutIdentityVerificationNestedInput = {
    create?: XOR<UserCreateWithoutIdentityVerificationInput, UserUncheckedCreateWithoutIdentityVerificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutIdentityVerificationInput
    upsert?: UserUpsertWithoutIdentityVerificationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIdentityVerificationInput, UserUpdateWithoutIdentityVerificationInput>, UserUncheckedUpdateWithoutIdentityVerificationInput>
  }

  export type UserCreateNestedOneWithoutContactMessagesInput = {
    create?: XOR<UserCreateWithoutContactMessagesInput, UserUncheckedCreateWithoutContactMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type AdminNoteCreateNestedManyWithoutContactInput = {
    create?: XOR<AdminNoteCreateWithoutContactInput, AdminNoteUncheckedCreateWithoutContactInput> | AdminNoteCreateWithoutContactInput[] | AdminNoteUncheckedCreateWithoutContactInput[]
    connectOrCreate?: AdminNoteCreateOrConnectWithoutContactInput | AdminNoteCreateOrConnectWithoutContactInput[]
    createMany?: AdminNoteCreateManyContactInputEnvelope
    connect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
  }

  export type AdminNoteUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<AdminNoteCreateWithoutContactInput, AdminNoteUncheckedCreateWithoutContactInput> | AdminNoteCreateWithoutContactInput[] | AdminNoteUncheckedCreateWithoutContactInput[]
    connectOrCreate?: AdminNoteCreateOrConnectWithoutContactInput | AdminNoteCreateOrConnectWithoutContactInput[]
    createMany?: AdminNoteCreateManyContactInputEnvelope
    connect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
  }

  export type EnumMessageStatusFieldUpdateOperationsInput = {
    set?: $Enums.MessageStatus
  }

  export type UserUpdateOneWithoutContactMessagesNestedInput = {
    create?: XOR<UserCreateWithoutContactMessagesInput, UserUncheckedCreateWithoutContactMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactMessagesInput
    upsert?: UserUpsertWithoutContactMessagesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutContactMessagesInput, UserUpdateWithoutContactMessagesInput>, UserUncheckedUpdateWithoutContactMessagesInput>
  }

  export type AdminNoteUpdateManyWithoutContactNestedInput = {
    create?: XOR<AdminNoteCreateWithoutContactInput, AdminNoteUncheckedCreateWithoutContactInput> | AdminNoteCreateWithoutContactInput[] | AdminNoteUncheckedCreateWithoutContactInput[]
    connectOrCreate?: AdminNoteCreateOrConnectWithoutContactInput | AdminNoteCreateOrConnectWithoutContactInput[]
    upsert?: AdminNoteUpsertWithWhereUniqueWithoutContactInput | AdminNoteUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: AdminNoteCreateManyContactInputEnvelope
    set?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    disconnect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    delete?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    connect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    update?: AdminNoteUpdateWithWhereUniqueWithoutContactInput | AdminNoteUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: AdminNoteUpdateManyWithWhereWithoutContactInput | AdminNoteUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: AdminNoteScalarWhereInput | AdminNoteScalarWhereInput[]
  }

  export type AdminNoteUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<AdminNoteCreateWithoutContactInput, AdminNoteUncheckedCreateWithoutContactInput> | AdminNoteCreateWithoutContactInput[] | AdminNoteUncheckedCreateWithoutContactInput[]
    connectOrCreate?: AdminNoteCreateOrConnectWithoutContactInput | AdminNoteCreateOrConnectWithoutContactInput[]
    upsert?: AdminNoteUpsertWithWhereUniqueWithoutContactInput | AdminNoteUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: AdminNoteCreateManyContactInputEnvelope
    set?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    disconnect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    delete?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    connect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    update?: AdminNoteUpdateWithWhereUniqueWithoutContactInput | AdminNoteUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: AdminNoteUpdateManyWithWhereWithoutContactInput | AdminNoteUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: AdminNoteScalarWhereInput | AdminNoteScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<UserCreateWithoutApplicationsInput, UserUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApplicationsInput
    connect?: UserWhereUniqueInput
  }

  export type AdminNoteCreateNestedManyWithoutApplicationInput = {
    create?: XOR<AdminNoteCreateWithoutApplicationInput, AdminNoteUncheckedCreateWithoutApplicationInput> | AdminNoteCreateWithoutApplicationInput[] | AdminNoteUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: AdminNoteCreateOrConnectWithoutApplicationInput | AdminNoteCreateOrConnectWithoutApplicationInput[]
    createMany?: AdminNoteCreateManyApplicationInputEnvelope
    connect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
  }

  export type AdminNoteUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<AdminNoteCreateWithoutApplicationInput, AdminNoteUncheckedCreateWithoutApplicationInput> | AdminNoteCreateWithoutApplicationInput[] | AdminNoteUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: AdminNoteCreateOrConnectWithoutApplicationInput | AdminNoteCreateOrConnectWithoutApplicationInput[]
    createMany?: AdminNoteCreateManyApplicationInputEnvelope
    connect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
  }

  export type EnumApplicationTypeFieldUpdateOperationsInput = {
    set?: $Enums.ApplicationType
  }

  export type EnumApplicationStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApplicationStatus
  }

  export type UserUpdateOneWithoutApplicationsNestedInput = {
    create?: XOR<UserCreateWithoutApplicationsInput, UserUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApplicationsInput
    upsert?: UserUpsertWithoutApplicationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApplicationsInput, UserUpdateWithoutApplicationsInput>, UserUncheckedUpdateWithoutApplicationsInput>
  }

  export type AdminNoteUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<AdminNoteCreateWithoutApplicationInput, AdminNoteUncheckedCreateWithoutApplicationInput> | AdminNoteCreateWithoutApplicationInput[] | AdminNoteUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: AdminNoteCreateOrConnectWithoutApplicationInput | AdminNoteCreateOrConnectWithoutApplicationInput[]
    upsert?: AdminNoteUpsertWithWhereUniqueWithoutApplicationInput | AdminNoteUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: AdminNoteCreateManyApplicationInputEnvelope
    set?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    disconnect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    delete?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    connect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    update?: AdminNoteUpdateWithWhereUniqueWithoutApplicationInput | AdminNoteUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: AdminNoteUpdateManyWithWhereWithoutApplicationInput | AdminNoteUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: AdminNoteScalarWhereInput | AdminNoteScalarWhereInput[]
  }

  export type AdminNoteUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<AdminNoteCreateWithoutApplicationInput, AdminNoteUncheckedCreateWithoutApplicationInput> | AdminNoteCreateWithoutApplicationInput[] | AdminNoteUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: AdminNoteCreateOrConnectWithoutApplicationInput | AdminNoteCreateOrConnectWithoutApplicationInput[]
    upsert?: AdminNoteUpsertWithWhereUniqueWithoutApplicationInput | AdminNoteUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: AdminNoteCreateManyApplicationInputEnvelope
    set?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    disconnect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    delete?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    connect?: AdminNoteWhereUniqueInput | AdminNoteWhereUniqueInput[]
    update?: AdminNoteUpdateWithWhereUniqueWithoutApplicationInput | AdminNoteUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: AdminNoteUpdateManyWithWhereWithoutApplicationInput | AdminNoteUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: AdminNoteScalarWhereInput | AdminNoteScalarWhereInput[]
  }

  export type CryptoProjectCreateNestedOneWithoutTrustScoreEventsInput = {
    create?: XOR<CryptoProjectCreateWithoutTrustScoreEventsInput, CryptoProjectUncheckedCreateWithoutTrustScoreEventsInput>
    connectOrCreate?: CryptoProjectCreateOrConnectWithoutTrustScoreEventsInput
    connect?: CryptoProjectWhereUniqueInput
  }

  export type BusinessCreateNestedOneWithoutTrustScoreEventsInput = {
    create?: XOR<BusinessCreateWithoutTrustScoreEventsInput, BusinessUncheckedCreateWithoutTrustScoreEventsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutTrustScoreEventsInput
    connect?: BusinessWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTrustScoreEventsInput = {
    create?: XOR<UserCreateWithoutTrustScoreEventsInput, UserUncheckedCreateWithoutTrustScoreEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrustScoreEventsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTrustScoreEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.TrustScoreEventType
  }

  export type CryptoProjectUpdateOneWithoutTrustScoreEventsNestedInput = {
    create?: XOR<CryptoProjectCreateWithoutTrustScoreEventsInput, CryptoProjectUncheckedCreateWithoutTrustScoreEventsInput>
    connectOrCreate?: CryptoProjectCreateOrConnectWithoutTrustScoreEventsInput
    upsert?: CryptoProjectUpsertWithoutTrustScoreEventsInput
    disconnect?: CryptoProjectWhereInput | boolean
    delete?: CryptoProjectWhereInput | boolean
    connect?: CryptoProjectWhereUniqueInput
    update?: XOR<XOR<CryptoProjectUpdateToOneWithWhereWithoutTrustScoreEventsInput, CryptoProjectUpdateWithoutTrustScoreEventsInput>, CryptoProjectUncheckedUpdateWithoutTrustScoreEventsInput>
  }

  export type BusinessUpdateOneWithoutTrustScoreEventsNestedInput = {
    create?: XOR<BusinessCreateWithoutTrustScoreEventsInput, BusinessUncheckedCreateWithoutTrustScoreEventsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutTrustScoreEventsInput
    upsert?: BusinessUpsertWithoutTrustScoreEventsInput
    disconnect?: BusinessWhereInput | boolean
    delete?: BusinessWhereInput | boolean
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutTrustScoreEventsInput, BusinessUpdateWithoutTrustScoreEventsInput>, BusinessUncheckedUpdateWithoutTrustScoreEventsInput>
  }

  export type UserUpdateOneWithoutTrustScoreEventsNestedInput = {
    create?: XOR<UserCreateWithoutTrustScoreEventsInput, UserUncheckedCreateWithoutTrustScoreEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrustScoreEventsInput
    upsert?: UserUpsertWithoutTrustScoreEventsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTrustScoreEventsInput, UserUpdateWithoutTrustScoreEventsInput>, UserUncheckedUpdateWithoutTrustScoreEventsInput>
  }

  export type UserCreateNestedOneWithoutAdminNotesInput = {
    create?: XOR<UserCreateWithoutAdminNotesInput, UserUncheckedCreateWithoutAdminNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminNotesInput
    connect?: UserWhereUniqueInput
  }

  export type CryptoProjectCreateNestedOneWithoutAdminNotesInput = {
    create?: XOR<CryptoProjectCreateWithoutAdminNotesInput, CryptoProjectUncheckedCreateWithoutAdminNotesInput>
    connectOrCreate?: CryptoProjectCreateOrConnectWithoutAdminNotesInput
    connect?: CryptoProjectWhereUniqueInput
  }

  export type BusinessCreateNestedOneWithoutAdminNotesInput = {
    create?: XOR<BusinessCreateWithoutAdminNotesInput, BusinessUncheckedCreateWithoutAdminNotesInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutAdminNotesInput
    connect?: BusinessWhereUniqueInput
  }

  export type ContactMessageCreateNestedOneWithoutAdminNotesInput = {
    create?: XOR<ContactMessageCreateWithoutAdminNotesInput, ContactMessageUncheckedCreateWithoutAdminNotesInput>
    connectOrCreate?: ContactMessageCreateOrConnectWithoutAdminNotesInput
    connect?: ContactMessageWhereUniqueInput
  }

  export type LaunchApplicationCreateNestedOneWithoutAdminNotesInput = {
    create?: XOR<LaunchApplicationCreateWithoutAdminNotesInput, LaunchApplicationUncheckedCreateWithoutAdminNotesInput>
    connectOrCreate?: LaunchApplicationCreateOrConnectWithoutAdminNotesInput
    connect?: LaunchApplicationWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAdminNotesNestedInput = {
    create?: XOR<UserCreateWithoutAdminNotesInput, UserUncheckedCreateWithoutAdminNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminNotesInput
    upsert?: UserUpsertWithoutAdminNotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminNotesInput, UserUpdateWithoutAdminNotesInput>, UserUncheckedUpdateWithoutAdminNotesInput>
  }

  export type CryptoProjectUpdateOneWithoutAdminNotesNestedInput = {
    create?: XOR<CryptoProjectCreateWithoutAdminNotesInput, CryptoProjectUncheckedCreateWithoutAdminNotesInput>
    connectOrCreate?: CryptoProjectCreateOrConnectWithoutAdminNotesInput
    upsert?: CryptoProjectUpsertWithoutAdminNotesInput
    disconnect?: CryptoProjectWhereInput | boolean
    delete?: CryptoProjectWhereInput | boolean
    connect?: CryptoProjectWhereUniqueInput
    update?: XOR<XOR<CryptoProjectUpdateToOneWithWhereWithoutAdminNotesInput, CryptoProjectUpdateWithoutAdminNotesInput>, CryptoProjectUncheckedUpdateWithoutAdminNotesInput>
  }

  export type BusinessUpdateOneWithoutAdminNotesNestedInput = {
    create?: XOR<BusinessCreateWithoutAdminNotesInput, BusinessUncheckedCreateWithoutAdminNotesInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutAdminNotesInput
    upsert?: BusinessUpsertWithoutAdminNotesInput
    disconnect?: BusinessWhereInput | boolean
    delete?: BusinessWhereInput | boolean
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutAdminNotesInput, BusinessUpdateWithoutAdminNotesInput>, BusinessUncheckedUpdateWithoutAdminNotesInput>
  }

  export type ContactMessageUpdateOneWithoutAdminNotesNestedInput = {
    create?: XOR<ContactMessageCreateWithoutAdminNotesInput, ContactMessageUncheckedCreateWithoutAdminNotesInput>
    connectOrCreate?: ContactMessageCreateOrConnectWithoutAdminNotesInput
    upsert?: ContactMessageUpsertWithoutAdminNotesInput
    disconnect?: ContactMessageWhereInput | boolean
    delete?: ContactMessageWhereInput | boolean
    connect?: ContactMessageWhereUniqueInput
    update?: XOR<XOR<ContactMessageUpdateToOneWithWhereWithoutAdminNotesInput, ContactMessageUpdateWithoutAdminNotesInput>, ContactMessageUncheckedUpdateWithoutAdminNotesInput>
  }

  export type LaunchApplicationUpdateOneWithoutAdminNotesNestedInput = {
    create?: XOR<LaunchApplicationCreateWithoutAdminNotesInput, LaunchApplicationUncheckedCreateWithoutAdminNotesInput>
    connectOrCreate?: LaunchApplicationCreateOrConnectWithoutAdminNotesInput
    upsert?: LaunchApplicationUpsertWithoutAdminNotesInput
    disconnect?: LaunchApplicationWhereInput | boolean
    delete?: LaunchApplicationWhereInput | boolean
    connect?: LaunchApplicationWhereUniqueInput
    update?: XOR<XOR<LaunchApplicationUpdateToOneWithWhereWithoutAdminNotesInput, LaunchApplicationUpdateWithoutAdminNotesInput>, LaunchApplicationUncheckedUpdateWithoutAdminNotesInput>
  }

  export type UserCreateNestedOneWithoutSystemLogsInput = {
    create?: XOR<UserCreateWithoutSystemLogsInput, UserUncheckedCreateWithoutSystemLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSystemLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumLogLevelFieldUpdateOperationsInput = {
    set?: $Enums.LogLevel
  }

  export type EnumLogCategoryFieldUpdateOperationsInput = {
    set?: $Enums.LogCategory
  }

  export type UserUpdateOneWithoutSystemLogsNestedInput = {
    create?: XOR<UserCreateWithoutSystemLogsInput, UserUncheckedCreateWithoutSystemLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSystemLogsInput
    upsert?: UserUpsertWithoutSystemLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSystemLogsInput, UserUpdateWithoutSystemLogsInput>, UserUncheckedUpdateWithoutSystemLogsInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumTokenTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TokenType | EnumTokenTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTokenTypeFilter<$PrismaModel> | $Enums.TokenType
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumVestingTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.VestingType | EnumVestingTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.VestingType[] | ListEnumVestingTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VestingType[] | ListEnumVestingTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVestingTypeNullableFilter<$PrismaModel> | $Enums.VestingType | null
  }

  export type NestedEnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type NestedEnumTokenTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TokenType | EnumTokenTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTokenTypeWithAggregatesFilter<$PrismaModel> | $Enums.TokenType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTokenTypeFilter<$PrismaModel>
    _max?: NestedEnumTokenTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumVestingTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VestingType | EnumVestingTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.VestingType[] | ListEnumVestingTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VestingType[] | ListEnumVestingTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVestingTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.VestingType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumVestingTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumVestingTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type NestedEnumKYBLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.KYBLevel | EnumKYBLevelFieldRefInput<$PrismaModel>
    in?: $Enums.KYBLevel[] | ListEnumKYBLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYBLevel[] | ListEnumKYBLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumKYBLevelFilter<$PrismaModel> | $Enums.KYBLevel
  }

  export type NestedEnumTokenTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TokenType | EnumTokenTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTokenTypeNullableFilter<$PrismaModel> | $Enums.TokenType | null
  }

  export type NestedEnumBusinessStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BusinessStatus | EnumBusinessStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BusinessStatus[] | ListEnumBusinessStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BusinessStatus[] | ListEnumBusinessStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBusinessStatusFilter<$PrismaModel> | $Enums.BusinessStatus
  }

  export type NestedEnumKYBLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KYBLevel | EnumKYBLevelFieldRefInput<$PrismaModel>
    in?: $Enums.KYBLevel[] | ListEnumKYBLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYBLevel[] | ListEnumKYBLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumKYBLevelWithAggregatesFilter<$PrismaModel> | $Enums.KYBLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKYBLevelFilter<$PrismaModel>
    _max?: NestedEnumKYBLevelFilter<$PrismaModel>
  }

  export type NestedEnumTokenTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TokenType | EnumTokenTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTokenTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.TokenType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTokenTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumTokenTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumBusinessStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BusinessStatus | EnumBusinessStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BusinessStatus[] | ListEnumBusinessStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BusinessStatus[] | ListEnumBusinessStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBusinessStatusWithAggregatesFilter<$PrismaModel> | $Enums.BusinessStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBusinessStatusFilter<$PrismaModel>
    _max?: NestedEnumBusinessStatusFilter<$PrismaModel>
  }

  export type NestedEnumIdentityStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IdentityStatus | EnumIdentityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IdentityStatus[] | ListEnumIdentityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdentityStatus[] | ListEnumIdentityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIdentityStatusFilter<$PrismaModel> | $Enums.IdentityStatus
  }

  export type NestedEnumIdentityStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IdentityStatus | EnumIdentityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IdentityStatus[] | ListEnumIdentityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdentityStatus[] | ListEnumIdentityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIdentityStatusWithAggregatesFilter<$PrismaModel> | $Enums.IdentityStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIdentityStatusFilter<$PrismaModel>
    _max?: NestedEnumIdentityStatusFilter<$PrismaModel>
  }

  export type NestedEnumMessageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusFilter<$PrismaModel> | $Enums.MessageStatus
  }

  export type NestedEnumMessageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusWithAggregatesFilter<$PrismaModel> | $Enums.MessageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageStatusFilter<$PrismaModel>
    _max?: NestedEnumMessageStatusFilter<$PrismaModel>
  }

  export type NestedEnumApplicationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationType | EnumApplicationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationType[] | ListEnumApplicationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationType[] | ListEnumApplicationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationTypeFilter<$PrismaModel> | $Enums.ApplicationType
  }

  export type NestedEnumApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusFilter<$PrismaModel> | $Enums.ApplicationStatus
  }

  export type NestedEnumApplicationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationType | EnumApplicationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationType[] | ListEnumApplicationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationType[] | ListEnumApplicationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationTypeWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationTypeFilter<$PrismaModel>
    _max?: NestedEnumApplicationTypeFilter<$PrismaModel>
  }

  export type NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicationStatusFilter<$PrismaModel>
  }

  export type NestedEnumTrustScoreEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TrustScoreEventType | EnumTrustScoreEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrustScoreEventType[] | ListEnumTrustScoreEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrustScoreEventType[] | ListEnumTrustScoreEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTrustScoreEventTypeFilter<$PrismaModel> | $Enums.TrustScoreEventType
  }

  export type NestedEnumTrustScoreEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrustScoreEventType | EnumTrustScoreEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TrustScoreEventType[] | ListEnumTrustScoreEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrustScoreEventType[] | ListEnumTrustScoreEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTrustScoreEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.TrustScoreEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrustScoreEventTypeFilter<$PrismaModel>
    _max?: NestedEnumTrustScoreEventTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumLogLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.LogLevel | EnumLogLevelFieldRefInput<$PrismaModel>
    in?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLogLevelFilter<$PrismaModel> | $Enums.LogLevel
  }

  export type NestedEnumLogCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.LogCategory | EnumLogCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.LogCategory[] | ListEnumLogCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogCategory[] | ListEnumLogCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumLogCategoryFilter<$PrismaModel> | $Enums.LogCategory
  }

  export type NestedEnumLogLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LogLevel | EnumLogLevelFieldRefInput<$PrismaModel>
    in?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLogLevelWithAggregatesFilter<$PrismaModel> | $Enums.LogLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLogLevelFilter<$PrismaModel>
    _max?: NestedEnumLogLevelFilter<$PrismaModel>
  }

  export type NestedEnumLogCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LogCategory | EnumLogCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.LogCategory[] | ListEnumLogCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogCategory[] | ListEnumLogCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumLogCategoryWithAggregatesFilter<$PrismaModel> | $Enums.LogCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLogCategoryFilter<$PrismaModel>
    _max?: NestedEnumLogCategoryFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type CryptoProjectCreateWithoutUserInput = {
    id?: string
    name: string
    symbol?: string | null
    description?: string | null
    category?: string | null
    website?: string | null
    whitepaper?: string | null
    twitter?: string | null
    discord?: string | null
    telegram?: string | null
    github?: string | null
    tokenType?: $Enums.TokenType
    totalSupply?: string | null
    decimals?: number
    teamAllocationPercent?: number | null
    teamVestingMonths?: number | null
    teamCliffMonths?: number | null
    vestingType?: $Enums.VestingType | null
    initialLiquidity?: string | null
    liquidityLockMonths?: number | null
    liquidityLockTxHash?: string | null
    auditProvider?: string | null
    auditReportUrl?: string | null
    auditDate?: Date | string | null
    contractAddress?: string | null
    contractVerified?: boolean
    status?: $Enums.ProjectStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    rejectionReason?: string | null
    trustScore?: number
    trustScoreUpdatedAt?: Date | string | null
    launchDate?: Date | string | null
    softCap?: string | null
    hardCap?: string | null
    minContribution?: string | null
    maxContribution?: string | null
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    trustScoreEvents?: TrustScoreEventCreateNestedManyWithoutProjectInput
    adminNotes?: AdminNoteCreateNestedManyWithoutProjectInput
    documents?: ProjectDocumentCreateNestedManyWithoutProjectInput
  }

  export type CryptoProjectUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    symbol?: string | null
    description?: string | null
    category?: string | null
    website?: string | null
    whitepaper?: string | null
    twitter?: string | null
    discord?: string | null
    telegram?: string | null
    github?: string | null
    tokenType?: $Enums.TokenType
    totalSupply?: string | null
    decimals?: number
    teamAllocationPercent?: number | null
    teamVestingMonths?: number | null
    teamCliffMonths?: number | null
    vestingType?: $Enums.VestingType | null
    initialLiquidity?: string | null
    liquidityLockMonths?: number | null
    liquidityLockTxHash?: string | null
    auditProvider?: string | null
    auditReportUrl?: string | null
    auditDate?: Date | string | null
    contractAddress?: string | null
    contractVerified?: boolean
    status?: $Enums.ProjectStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    rejectionReason?: string | null
    trustScore?: number
    trustScoreUpdatedAt?: Date | string | null
    launchDate?: Date | string | null
    softCap?: string | null
    hardCap?: string | null
    minContribution?: string | null
    maxContribution?: string | null
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    trustScoreEvents?: TrustScoreEventUncheckedCreateNestedManyWithoutProjectInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutProjectInput
    documents?: ProjectDocumentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type CryptoProjectCreateOrConnectWithoutUserInput = {
    where: CryptoProjectWhereUniqueInput
    create: XOR<CryptoProjectCreateWithoutUserInput, CryptoProjectUncheckedCreateWithoutUserInput>
  }

  export type CryptoProjectCreateManyUserInputEnvelope = {
    data: CryptoProjectCreateManyUserInput | CryptoProjectCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BusinessCreateWithoutUserInput = {
    id?: string
    legalName: string
    dba?: string | null
    entityType?: string | null
    jurisdiction?: string | null
    ein?: string | null
    registrationNumber?: string | null
    incorporationDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    businessEmail?: string | null
    businessPhone?: string | null
    website?: string | null
    description?: string | null
    industry?: string | null
    employeeCount?: number | null
    annualRevenue?: string | null
    linkedin?: string | null
    twitter?: string | null
    kybLevel?: $Enums.KYBLevel
    kybProvider?: string | null
    kybVerifiedAt?: Date | string | null
    kybExpiresAt?: Date | string | null
    kybRejectionReason?: string | null
    tokenType?: $Enums.TokenType | null
    raiseAmount?: string | null
    equityPercent?: number | null
    revenueSharePercent?: number | null
    minInvestment?: string | null
    maxInvestment?: string | null
    status?: $Enums.BusinessStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    rejectionReason?: string | null
    trustScore?: number
    trustScoreUpdatedAt?: Date | string | null
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    founders?: BusinessFounderCreateNestedManyWithoutBusinessInput
    documents?: BusinessDocumentCreateNestedManyWithoutBusinessInput
    trustScoreEvents?: TrustScoreEventCreateNestedManyWithoutBusinessInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBusinessInput
    revenueReports?: RevenueReportCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutUserInput = {
    id?: string
    legalName: string
    dba?: string | null
    entityType?: string | null
    jurisdiction?: string | null
    ein?: string | null
    registrationNumber?: string | null
    incorporationDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    businessEmail?: string | null
    businessPhone?: string | null
    website?: string | null
    description?: string | null
    industry?: string | null
    employeeCount?: number | null
    annualRevenue?: string | null
    linkedin?: string | null
    twitter?: string | null
    kybLevel?: $Enums.KYBLevel
    kybProvider?: string | null
    kybVerifiedAt?: Date | string | null
    kybExpiresAt?: Date | string | null
    kybRejectionReason?: string | null
    tokenType?: $Enums.TokenType | null
    raiseAmount?: string | null
    equityPercent?: number | null
    revenueSharePercent?: number | null
    minInvestment?: string | null
    maxInvestment?: string | null
    status?: $Enums.BusinessStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    rejectionReason?: string | null
    trustScore?: number
    trustScoreUpdatedAt?: Date | string | null
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    founders?: BusinessFounderUncheckedCreateNestedManyWithoutBusinessInput
    documents?: BusinessDocumentUncheckedCreateNestedManyWithoutBusinessInput
    trustScoreEvents?: TrustScoreEventUncheckedCreateNestedManyWithoutBusinessInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBusinessInput
    revenueReports?: RevenueReportUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutUserInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutUserInput, BusinessUncheckedCreateWithoutUserInput>
  }

  export type BusinessCreateManyUserInputEnvelope = {
    data: BusinessCreateManyUserInput | BusinessCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PrivateIdentityVerificationCreateWithoutUserInput = {
    id?: string
    status?: $Enums.IdentityStatus
    level?: string | null
    provider?: string | null
    providerSessionId?: string | null
    providerStatus?: string | null
    verifiedAt?: Date | string | null
    expiresAt?: Date | string | null
    rejectionReason?: string | null
    retryCount?: number
    lastAttemptAt?: Date | string | null
    isAccredited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivateIdentityVerificationUncheckedCreateWithoutUserInput = {
    id?: string
    status?: $Enums.IdentityStatus
    level?: string | null
    provider?: string | null
    providerSessionId?: string | null
    providerStatus?: string | null
    verifiedAt?: Date | string | null
    expiresAt?: Date | string | null
    rejectionReason?: string | null
    retryCount?: number
    lastAttemptAt?: Date | string | null
    isAccredited?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivateIdentityVerificationCreateOrConnectWithoutUserInput = {
    where: PrivateIdentityVerificationWhereUniqueInput
    create: XOR<PrivateIdentityVerificationCreateWithoutUserInput, PrivateIdentityVerificationUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    token: string
    refreshToken?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    isRevoked?: boolean
    revokedAt?: Date | string | null
    revokedReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    refreshToken?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    isRevoked?: boolean
    revokedAt?: Date | string | null
    revokedReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SystemLogCreateWithoutUserInput = {
    id?: string
    level: $Enums.LogLevel
    category: $Enums.LogCategory
    action: string
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    requestId?: string | null
    endpoint?: string | null
    method?: string | null
    statusCode?: number | null
    responseTime?: number | null
    createdAt?: Date | string
  }

  export type SystemLogUncheckedCreateWithoutUserInput = {
    id?: string
    level: $Enums.LogLevel
    category: $Enums.LogCategory
    action: string
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    requestId?: string | null
    endpoint?: string | null
    method?: string | null
    statusCode?: number | null
    responseTime?: number | null
    createdAt?: Date | string
  }

  export type SystemLogCreateOrConnectWithoutUserInput = {
    where: SystemLogWhereUniqueInput
    create: XOR<SystemLogCreateWithoutUserInput, SystemLogUncheckedCreateWithoutUserInput>
  }

  export type SystemLogCreateManyUserInputEnvelope = {
    data: SystemLogCreateManyUserInput | SystemLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TrustScoreEventCreateWithoutUserInput = {
    id?: string
    eventType: $Enums.TrustScoreEventType
    points: number
    reason: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredBy?: string | null
    createdAt?: Date | string
    project?: CryptoProjectCreateNestedOneWithoutTrustScoreEventsInput
    business?: BusinessCreateNestedOneWithoutTrustScoreEventsInput
  }

  export type TrustScoreEventUncheckedCreateWithoutUserInput = {
    id?: string
    projectId?: string | null
    businessId?: string | null
    eventType: $Enums.TrustScoreEventType
    points: number
    reason: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredBy?: string | null
    createdAt?: Date | string
  }

  export type TrustScoreEventCreateOrConnectWithoutUserInput = {
    where: TrustScoreEventWhereUniqueInput
    create: XOR<TrustScoreEventCreateWithoutUserInput, TrustScoreEventUncheckedCreateWithoutUserInput>
  }

  export type TrustScoreEventCreateManyUserInputEnvelope = {
    data: TrustScoreEventCreateManyUserInput | TrustScoreEventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ContactMessageCreateWithoutUserInput = {
    id?: string
    name: string
    email: string
    subject?: string | null
    message: string
    category?: string | null
    status?: $Enums.MessageStatus
    assignedTo?: string | null
    responseText?: string | null
    respondedAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adminNotes?: AdminNoteCreateNestedManyWithoutContactInput
  }

  export type ContactMessageUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    email: string
    subject?: string | null
    message: string
    category?: string | null
    status?: $Enums.MessageStatus
    assignedTo?: string | null
    responseText?: string | null
    respondedAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactMessageCreateOrConnectWithoutUserInput = {
    where: ContactMessageWhereUniqueInput
    create: XOR<ContactMessageCreateWithoutUserInput, ContactMessageUncheckedCreateWithoutUserInput>
  }

  export type ContactMessageCreateManyUserInputEnvelope = {
    data: ContactMessageCreateManyUserInput | ContactMessageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LaunchApplicationCreateWithoutUserInput = {
    id?: string
    applicantName: string
    applicantEmail: string
    applicantRole?: string | null
    companyName?: string | null
    website?: string | null
    type: $Enums.ApplicationType
    description: string
    raiseAmount?: string | null
    timeline?: string | null
    twitter?: string | null
    discord?: string | null
    telegram?: string | null
    referralSource?: string | null
    status?: $Enums.ApplicationStatus
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adminNotes?: AdminNoteCreateNestedManyWithoutApplicationInput
  }

  export type LaunchApplicationUncheckedCreateWithoutUserInput = {
    id?: string
    applicantName: string
    applicantEmail: string
    applicantRole?: string | null
    companyName?: string | null
    website?: string | null
    type: $Enums.ApplicationType
    description: string
    raiseAmount?: string | null
    timeline?: string | null
    twitter?: string | null
    discord?: string | null
    telegram?: string | null
    referralSource?: string | null
    status?: $Enums.ApplicationStatus
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type LaunchApplicationCreateOrConnectWithoutUserInput = {
    where: LaunchApplicationWhereUniqueInput
    create: XOR<LaunchApplicationCreateWithoutUserInput, LaunchApplicationUncheckedCreateWithoutUserInput>
  }

  export type LaunchApplicationCreateManyUserInputEnvelope = {
    data: LaunchApplicationCreateManyUserInput | LaunchApplicationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AdminNoteCreateWithoutAuthorInput = {
    id?: string
    note: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: CryptoProjectCreateNestedOneWithoutAdminNotesInput
    business?: BusinessCreateNestedOneWithoutAdminNotesInput
    contact?: ContactMessageCreateNestedOneWithoutAdminNotesInput
    application?: LaunchApplicationCreateNestedOneWithoutAdminNotesInput
  }

  export type AdminNoteUncheckedCreateWithoutAuthorInput = {
    id?: string
    projectId?: string | null
    businessId?: string | null
    contactId?: string | null
    applicationId?: string | null
    note: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminNoteCreateOrConnectWithoutAuthorInput = {
    where: AdminNoteWhereUniqueInput
    create: XOR<AdminNoteCreateWithoutAuthorInput, AdminNoteUncheckedCreateWithoutAuthorInput>
  }

  export type AdminNoteCreateManyAuthorInputEnvelope = {
    data: AdminNoteCreateManyAuthorInput | AdminNoteCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type CryptoProjectUpsertWithWhereUniqueWithoutUserInput = {
    where: CryptoProjectWhereUniqueInput
    update: XOR<CryptoProjectUpdateWithoutUserInput, CryptoProjectUncheckedUpdateWithoutUserInput>
    create: XOR<CryptoProjectCreateWithoutUserInput, CryptoProjectUncheckedCreateWithoutUserInput>
  }

  export type CryptoProjectUpdateWithWhereUniqueWithoutUserInput = {
    where: CryptoProjectWhereUniqueInput
    data: XOR<CryptoProjectUpdateWithoutUserInput, CryptoProjectUncheckedUpdateWithoutUserInput>
  }

  export type CryptoProjectUpdateManyWithWhereWithoutUserInput = {
    where: CryptoProjectScalarWhereInput
    data: XOR<CryptoProjectUpdateManyMutationInput, CryptoProjectUncheckedUpdateManyWithoutUserInput>
  }

  export type CryptoProjectScalarWhereInput = {
    AND?: CryptoProjectScalarWhereInput | CryptoProjectScalarWhereInput[]
    OR?: CryptoProjectScalarWhereInput[]
    NOT?: CryptoProjectScalarWhereInput | CryptoProjectScalarWhereInput[]
    id?: StringFilter<"CryptoProject"> | string
    userId?: StringFilter<"CryptoProject"> | string
    name?: StringFilter<"CryptoProject"> | string
    symbol?: StringNullableFilter<"CryptoProject"> | string | null
    description?: StringNullableFilter<"CryptoProject"> | string | null
    category?: StringNullableFilter<"CryptoProject"> | string | null
    website?: StringNullableFilter<"CryptoProject"> | string | null
    whitepaper?: StringNullableFilter<"CryptoProject"> | string | null
    twitter?: StringNullableFilter<"CryptoProject"> | string | null
    discord?: StringNullableFilter<"CryptoProject"> | string | null
    telegram?: StringNullableFilter<"CryptoProject"> | string | null
    github?: StringNullableFilter<"CryptoProject"> | string | null
    tokenType?: EnumTokenTypeFilter<"CryptoProject"> | $Enums.TokenType
    totalSupply?: StringNullableFilter<"CryptoProject"> | string | null
    decimals?: IntFilter<"CryptoProject"> | number
    teamAllocationPercent?: FloatNullableFilter<"CryptoProject"> | number | null
    teamVestingMonths?: IntNullableFilter<"CryptoProject"> | number | null
    teamCliffMonths?: IntNullableFilter<"CryptoProject"> | number | null
    vestingType?: EnumVestingTypeNullableFilter<"CryptoProject"> | $Enums.VestingType | null
    initialLiquidity?: StringNullableFilter<"CryptoProject"> | string | null
    liquidityLockMonths?: IntNullableFilter<"CryptoProject"> | number | null
    liquidityLockTxHash?: StringNullableFilter<"CryptoProject"> | string | null
    auditProvider?: StringNullableFilter<"CryptoProject"> | string | null
    auditReportUrl?: StringNullableFilter<"CryptoProject"> | string | null
    auditDate?: DateTimeNullableFilter<"CryptoProject"> | Date | string | null
    contractAddress?: StringNullableFilter<"CryptoProject"> | string | null
    contractVerified?: BoolFilter<"CryptoProject"> | boolean
    status?: EnumProjectStatusFilter<"CryptoProject"> | $Enums.ProjectStatus
    submittedAt?: DateTimeNullableFilter<"CryptoProject"> | Date | string | null
    reviewedAt?: DateTimeNullableFilter<"CryptoProject"> | Date | string | null
    reviewedBy?: StringNullableFilter<"CryptoProject"> | string | null
    rejectionReason?: StringNullableFilter<"CryptoProject"> | string | null
    trustScore?: IntFilter<"CryptoProject"> | number
    trustScoreUpdatedAt?: DateTimeNullableFilter<"CryptoProject"> | Date | string | null
    launchDate?: DateTimeNullableFilter<"CryptoProject"> | Date | string | null
    softCap?: StringNullableFilter<"CryptoProject"> | string | null
    hardCap?: StringNullableFilter<"CryptoProject"> | string | null
    minContribution?: StringNullableFilter<"CryptoProject"> | string | null
    maxContribution?: StringNullableFilter<"CryptoProject"> | string | null
    isVerified?: BoolFilter<"CryptoProject"> | boolean
    isFeatured?: BoolFilter<"CryptoProject"> | boolean
    isPaused?: BoolFilter<"CryptoProject"> | boolean
    createdAt?: DateTimeFilter<"CryptoProject"> | Date | string
    updatedAt?: DateTimeFilter<"CryptoProject"> | Date | string
  }

  export type BusinessUpsertWithWhereUniqueWithoutUserInput = {
    where: BusinessWhereUniqueInput
    update: XOR<BusinessUpdateWithoutUserInput, BusinessUncheckedUpdateWithoutUserInput>
    create: XOR<BusinessCreateWithoutUserInput, BusinessUncheckedCreateWithoutUserInput>
  }

  export type BusinessUpdateWithWhereUniqueWithoutUserInput = {
    where: BusinessWhereUniqueInput
    data: XOR<BusinessUpdateWithoutUserInput, BusinessUncheckedUpdateWithoutUserInput>
  }

  export type BusinessUpdateManyWithWhereWithoutUserInput = {
    where: BusinessScalarWhereInput
    data: XOR<BusinessUpdateManyMutationInput, BusinessUncheckedUpdateManyWithoutUserInput>
  }

  export type BusinessScalarWhereInput = {
    AND?: BusinessScalarWhereInput | BusinessScalarWhereInput[]
    OR?: BusinessScalarWhereInput[]
    NOT?: BusinessScalarWhereInput | BusinessScalarWhereInput[]
    id?: StringFilter<"Business"> | string
    userId?: StringFilter<"Business"> | string
    legalName?: StringFilter<"Business"> | string
    dba?: StringNullableFilter<"Business"> | string | null
    entityType?: StringNullableFilter<"Business"> | string | null
    jurisdiction?: StringNullableFilter<"Business"> | string | null
    ein?: StringNullableFilter<"Business"> | string | null
    registrationNumber?: StringNullableFilter<"Business"> | string | null
    incorporationDate?: DateTimeNullableFilter<"Business"> | Date | string | null
    address?: StringNullableFilter<"Business"> | string | null
    city?: StringNullableFilter<"Business"> | string | null
    state?: StringNullableFilter<"Business"> | string | null
    postalCode?: StringNullableFilter<"Business"> | string | null
    country?: StringNullableFilter<"Business"> | string | null
    businessEmail?: StringNullableFilter<"Business"> | string | null
    businessPhone?: StringNullableFilter<"Business"> | string | null
    website?: StringNullableFilter<"Business"> | string | null
    description?: StringNullableFilter<"Business"> | string | null
    industry?: StringNullableFilter<"Business"> | string | null
    employeeCount?: IntNullableFilter<"Business"> | number | null
    annualRevenue?: StringNullableFilter<"Business"> | string | null
    linkedin?: StringNullableFilter<"Business"> | string | null
    twitter?: StringNullableFilter<"Business"> | string | null
    kybLevel?: EnumKYBLevelFilter<"Business"> | $Enums.KYBLevel
    kybProvider?: StringNullableFilter<"Business"> | string | null
    kybVerifiedAt?: DateTimeNullableFilter<"Business"> | Date | string | null
    kybExpiresAt?: DateTimeNullableFilter<"Business"> | Date | string | null
    kybRejectionReason?: StringNullableFilter<"Business"> | string | null
    tokenType?: EnumTokenTypeNullableFilter<"Business"> | $Enums.TokenType | null
    raiseAmount?: StringNullableFilter<"Business"> | string | null
    equityPercent?: FloatNullableFilter<"Business"> | number | null
    revenueSharePercent?: FloatNullableFilter<"Business"> | number | null
    minInvestment?: StringNullableFilter<"Business"> | string | null
    maxInvestment?: StringNullableFilter<"Business"> | string | null
    status?: EnumBusinessStatusFilter<"Business"> | $Enums.BusinessStatus
    submittedAt?: DateTimeNullableFilter<"Business"> | Date | string | null
    reviewedAt?: DateTimeNullableFilter<"Business"> | Date | string | null
    reviewedBy?: StringNullableFilter<"Business"> | string | null
    rejectionReason?: StringNullableFilter<"Business"> | string | null
    trustScore?: IntFilter<"Business"> | number
    trustScoreUpdatedAt?: DateTimeNullableFilter<"Business"> | Date | string | null
    isVerified?: BoolFilter<"Business"> | boolean
    isFeatured?: BoolFilter<"Business"> | boolean
    isPaused?: BoolFilter<"Business"> | boolean
    createdAt?: DateTimeFilter<"Business"> | Date | string
    updatedAt?: DateTimeFilter<"Business"> | Date | string
  }

  export type PrivateIdentityVerificationUpsertWithoutUserInput = {
    update: XOR<PrivateIdentityVerificationUpdateWithoutUserInput, PrivateIdentityVerificationUncheckedUpdateWithoutUserInput>
    create: XOR<PrivateIdentityVerificationCreateWithoutUserInput, PrivateIdentityVerificationUncheckedCreateWithoutUserInput>
    where?: PrivateIdentityVerificationWhereInput
  }

  export type PrivateIdentityVerificationUpdateToOneWithWhereWithoutUserInput = {
    where?: PrivateIdentityVerificationWhereInput
    data: XOR<PrivateIdentityVerificationUpdateWithoutUserInput, PrivateIdentityVerificationUncheckedUpdateWithoutUserInput>
  }

  export type PrivateIdentityVerificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumIdentityStatusFieldUpdateOperationsInput | $Enums.IdentityStatus
    level?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    providerStatus?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAccredited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateIdentityVerificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumIdentityStatusFieldUpdateOperationsInput | $Enums.IdentityStatus
    level?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    providerSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    providerStatus?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAccredited?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    refreshToken?: StringNullableFilter<"Session"> | string | null
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    isRevoked?: BoolFilter<"Session"> | boolean
    revokedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    revokedReason?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type SystemLogUpsertWithWhereUniqueWithoutUserInput = {
    where: SystemLogWhereUniqueInput
    update: XOR<SystemLogUpdateWithoutUserInput, SystemLogUncheckedUpdateWithoutUserInput>
    create: XOR<SystemLogCreateWithoutUserInput, SystemLogUncheckedCreateWithoutUserInput>
  }

  export type SystemLogUpdateWithWhereUniqueWithoutUserInput = {
    where: SystemLogWhereUniqueInput
    data: XOR<SystemLogUpdateWithoutUserInput, SystemLogUncheckedUpdateWithoutUserInput>
  }

  export type SystemLogUpdateManyWithWhereWithoutUserInput = {
    where: SystemLogScalarWhereInput
    data: XOR<SystemLogUpdateManyMutationInput, SystemLogUncheckedUpdateManyWithoutUserInput>
  }

  export type SystemLogScalarWhereInput = {
    AND?: SystemLogScalarWhereInput | SystemLogScalarWhereInput[]
    OR?: SystemLogScalarWhereInput[]
    NOT?: SystemLogScalarWhereInput | SystemLogScalarWhereInput[]
    id?: StringFilter<"SystemLog"> | string
    level?: EnumLogLevelFilter<"SystemLog"> | $Enums.LogLevel
    category?: EnumLogCategoryFilter<"SystemLog"> | $Enums.LogCategory
    action?: StringFilter<"SystemLog"> | string
    message?: StringFilter<"SystemLog"> | string
    metadata?: JsonNullableFilter<"SystemLog">
    userId?: StringNullableFilter<"SystemLog"> | string | null
    ipAddress?: StringNullableFilter<"SystemLog"> | string | null
    userAgent?: StringNullableFilter<"SystemLog"> | string | null
    requestId?: StringNullableFilter<"SystemLog"> | string | null
    endpoint?: StringNullableFilter<"SystemLog"> | string | null
    method?: StringNullableFilter<"SystemLog"> | string | null
    statusCode?: IntNullableFilter<"SystemLog"> | number | null
    responseTime?: IntNullableFilter<"SystemLog"> | number | null
    createdAt?: DateTimeFilter<"SystemLog"> | Date | string
  }

  export type TrustScoreEventUpsertWithWhereUniqueWithoutUserInput = {
    where: TrustScoreEventWhereUniqueInput
    update: XOR<TrustScoreEventUpdateWithoutUserInput, TrustScoreEventUncheckedUpdateWithoutUserInput>
    create: XOR<TrustScoreEventCreateWithoutUserInput, TrustScoreEventUncheckedCreateWithoutUserInput>
  }

  export type TrustScoreEventUpdateWithWhereUniqueWithoutUserInput = {
    where: TrustScoreEventWhereUniqueInput
    data: XOR<TrustScoreEventUpdateWithoutUserInput, TrustScoreEventUncheckedUpdateWithoutUserInput>
  }

  export type TrustScoreEventUpdateManyWithWhereWithoutUserInput = {
    where: TrustScoreEventScalarWhereInput
    data: XOR<TrustScoreEventUpdateManyMutationInput, TrustScoreEventUncheckedUpdateManyWithoutUserInput>
  }

  export type TrustScoreEventScalarWhereInput = {
    AND?: TrustScoreEventScalarWhereInput | TrustScoreEventScalarWhereInput[]
    OR?: TrustScoreEventScalarWhereInput[]
    NOT?: TrustScoreEventScalarWhereInput | TrustScoreEventScalarWhereInput[]
    id?: StringFilter<"TrustScoreEvent"> | string
    projectId?: StringNullableFilter<"TrustScoreEvent"> | string | null
    businessId?: StringNullableFilter<"TrustScoreEvent"> | string | null
    userId?: StringNullableFilter<"TrustScoreEvent"> | string | null
    eventType?: EnumTrustScoreEventTypeFilter<"TrustScoreEvent"> | $Enums.TrustScoreEventType
    points?: IntFilter<"TrustScoreEvent"> | number
    reason?: StringFilter<"TrustScoreEvent"> | string
    metadata?: JsonNullableFilter<"TrustScoreEvent">
    triggeredBy?: StringNullableFilter<"TrustScoreEvent"> | string | null
    createdAt?: DateTimeFilter<"TrustScoreEvent"> | Date | string
  }

  export type ContactMessageUpsertWithWhereUniqueWithoutUserInput = {
    where: ContactMessageWhereUniqueInput
    update: XOR<ContactMessageUpdateWithoutUserInput, ContactMessageUncheckedUpdateWithoutUserInput>
    create: XOR<ContactMessageCreateWithoutUserInput, ContactMessageUncheckedCreateWithoutUserInput>
  }

  export type ContactMessageUpdateWithWhereUniqueWithoutUserInput = {
    where: ContactMessageWhereUniqueInput
    data: XOR<ContactMessageUpdateWithoutUserInput, ContactMessageUncheckedUpdateWithoutUserInput>
  }

  export type ContactMessageUpdateManyWithWhereWithoutUserInput = {
    where: ContactMessageScalarWhereInput
    data: XOR<ContactMessageUpdateManyMutationInput, ContactMessageUncheckedUpdateManyWithoutUserInput>
  }

  export type ContactMessageScalarWhereInput = {
    AND?: ContactMessageScalarWhereInput | ContactMessageScalarWhereInput[]
    OR?: ContactMessageScalarWhereInput[]
    NOT?: ContactMessageScalarWhereInput | ContactMessageScalarWhereInput[]
    id?: StringFilter<"ContactMessage"> | string
    userId?: StringNullableFilter<"ContactMessage"> | string | null
    name?: StringFilter<"ContactMessage"> | string
    email?: StringFilter<"ContactMessage"> | string
    subject?: StringNullableFilter<"ContactMessage"> | string | null
    message?: StringFilter<"ContactMessage"> | string
    category?: StringNullableFilter<"ContactMessage"> | string | null
    status?: EnumMessageStatusFilter<"ContactMessage"> | $Enums.MessageStatus
    assignedTo?: StringNullableFilter<"ContactMessage"> | string | null
    responseText?: StringNullableFilter<"ContactMessage"> | string | null
    respondedAt?: DateTimeNullableFilter<"ContactMessage"> | Date | string | null
    ipAddress?: StringNullableFilter<"ContactMessage"> | string | null
    userAgent?: StringNullableFilter<"ContactMessage"> | string | null
    createdAt?: DateTimeFilter<"ContactMessage"> | Date | string
    updatedAt?: DateTimeFilter<"ContactMessage"> | Date | string
  }

  export type LaunchApplicationUpsertWithWhereUniqueWithoutUserInput = {
    where: LaunchApplicationWhereUniqueInput
    update: XOR<LaunchApplicationUpdateWithoutUserInput, LaunchApplicationUncheckedUpdateWithoutUserInput>
    create: XOR<LaunchApplicationCreateWithoutUserInput, LaunchApplicationUncheckedCreateWithoutUserInput>
  }

  export type LaunchApplicationUpdateWithWhereUniqueWithoutUserInput = {
    where: LaunchApplicationWhereUniqueInput
    data: XOR<LaunchApplicationUpdateWithoutUserInput, LaunchApplicationUncheckedUpdateWithoutUserInput>
  }

  export type LaunchApplicationUpdateManyWithWhereWithoutUserInput = {
    where: LaunchApplicationScalarWhereInput
    data: XOR<LaunchApplicationUpdateManyMutationInput, LaunchApplicationUncheckedUpdateManyWithoutUserInput>
  }

  export type LaunchApplicationScalarWhereInput = {
    AND?: LaunchApplicationScalarWhereInput | LaunchApplicationScalarWhereInput[]
    OR?: LaunchApplicationScalarWhereInput[]
    NOT?: LaunchApplicationScalarWhereInput | LaunchApplicationScalarWhereInput[]
    id?: StringFilter<"LaunchApplication"> | string
    userId?: StringNullableFilter<"LaunchApplication"> | string | null
    applicantName?: StringFilter<"LaunchApplication"> | string
    applicantEmail?: StringFilter<"LaunchApplication"> | string
    applicantRole?: StringNullableFilter<"LaunchApplication"> | string | null
    companyName?: StringNullableFilter<"LaunchApplication"> | string | null
    website?: StringNullableFilter<"LaunchApplication"> | string | null
    type?: EnumApplicationTypeFilter<"LaunchApplication"> | $Enums.ApplicationType
    description?: StringFilter<"LaunchApplication"> | string
    raiseAmount?: StringNullableFilter<"LaunchApplication"> | string | null
    timeline?: StringNullableFilter<"LaunchApplication"> | string | null
    twitter?: StringNullableFilter<"LaunchApplication"> | string | null
    discord?: StringNullableFilter<"LaunchApplication"> | string | null
    telegram?: StringNullableFilter<"LaunchApplication"> | string | null
    referralSource?: StringNullableFilter<"LaunchApplication"> | string | null
    status?: EnumApplicationStatusFilter<"LaunchApplication"> | $Enums.ApplicationStatus
    reviewedBy?: StringNullableFilter<"LaunchApplication"> | string | null
    reviewedAt?: DateTimeNullableFilter<"LaunchApplication"> | Date | string | null
    rejectionReason?: StringNullableFilter<"LaunchApplication"> | string | null
    ipAddress?: StringNullableFilter<"LaunchApplication"> | string | null
    userAgent?: StringNullableFilter<"LaunchApplication"> | string | null
    createdAt?: DateTimeFilter<"LaunchApplication"> | Date | string
    updatedAt?: DateTimeFilter<"LaunchApplication"> | Date | string
  }

  export type AdminNoteUpsertWithWhereUniqueWithoutAuthorInput = {
    where: AdminNoteWhereUniqueInput
    update: XOR<AdminNoteUpdateWithoutAuthorInput, AdminNoteUncheckedUpdateWithoutAuthorInput>
    create: XOR<AdminNoteCreateWithoutAuthorInput, AdminNoteUncheckedCreateWithoutAuthorInput>
  }

  export type AdminNoteUpdateWithWhereUniqueWithoutAuthorInput = {
    where: AdminNoteWhereUniqueInput
    data: XOR<AdminNoteUpdateWithoutAuthorInput, AdminNoteUncheckedUpdateWithoutAuthorInput>
  }

  export type AdminNoteUpdateManyWithWhereWithoutAuthorInput = {
    where: AdminNoteScalarWhereInput
    data: XOR<AdminNoteUpdateManyMutationInput, AdminNoteUncheckedUpdateManyWithoutAuthorInput>
  }

  export type AdminNoteScalarWhereInput = {
    AND?: AdminNoteScalarWhereInput | AdminNoteScalarWhereInput[]
    OR?: AdminNoteScalarWhereInput[]
    NOT?: AdminNoteScalarWhereInput | AdminNoteScalarWhereInput[]
    id?: StringFilter<"AdminNote"> | string
    authorId?: StringFilter<"AdminNote"> | string
    projectId?: StringNullableFilter<"AdminNote"> | string | null
    businessId?: StringNullableFilter<"AdminNote"> | string | null
    contactId?: StringNullableFilter<"AdminNote"> | string | null
    applicationId?: StringNullableFilter<"AdminNote"> | string | null
    note?: StringFilter<"AdminNote"> | string
    isInternal?: BoolFilter<"AdminNote"> | boolean
    createdAt?: DateTimeFilter<"AdminNote"> | Date | string
    updatedAt?: DateTimeFilter<"AdminNote"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    passwordHash: string
    walletAddress?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    isEmailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    displayName?: string | null
    avatarUrl?: string | null
    bio?: string | null
    apiCallCount?: number
    apiCallResetAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cryptoProjects?: CryptoProjectCreateNestedManyWithoutUserInput
    businesses?: BusinessCreateNestedManyWithoutUserInput
    identityVerification?: PrivateIdentityVerificationCreateNestedOneWithoutUserInput
    systemLogs?: SystemLogCreateNestedManyWithoutUserInput
    trustScoreEvents?: TrustScoreEventCreateNestedManyWithoutUserInput
    contactMessages?: ContactMessageCreateNestedManyWithoutUserInput
    applications?: LaunchApplicationCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    passwordHash: string
    walletAddress?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    isEmailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    displayName?: string | null
    avatarUrl?: string | null
    bio?: string | null
    apiCallCount?: number
    apiCallResetAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cryptoProjects?: CryptoProjectUncheckedCreateNestedManyWithoutUserInput
    businesses?: BusinessUncheckedCreateNestedManyWithoutUserInput
    identityVerification?: PrivateIdentityVerificationUncheckedCreateNestedOneWithoutUserInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutUserInput
    trustScoreEvents?: TrustScoreEventUncheckedCreateNestedManyWithoutUserInput
    contactMessages?: ContactMessageUncheckedCreateNestedManyWithoutUserInput
    applications?: LaunchApplicationUncheckedCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallCount?: IntFieldUpdateOperationsInput | number
    apiCallResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cryptoProjects?: CryptoProjectUpdateManyWithoutUserNestedInput
    businesses?: BusinessUpdateManyWithoutUserNestedInput
    identityVerification?: PrivateIdentityVerificationUpdateOneWithoutUserNestedInput
    systemLogs?: SystemLogUpdateManyWithoutUserNestedInput
    trustScoreEvents?: TrustScoreEventUpdateManyWithoutUserNestedInput
    contactMessages?: ContactMessageUpdateManyWithoutUserNestedInput
    applications?: LaunchApplicationUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallCount?: IntFieldUpdateOperationsInput | number
    apiCallResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cryptoProjects?: CryptoProjectUncheckedUpdateManyWithoutUserNestedInput
    businesses?: BusinessUncheckedUpdateManyWithoutUserNestedInput
    identityVerification?: PrivateIdentityVerificationUncheckedUpdateOneWithoutUserNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutUserNestedInput
    trustScoreEvents?: TrustScoreEventUncheckedUpdateManyWithoutUserNestedInput
    contactMessages?: ContactMessageUncheckedUpdateManyWithoutUserNestedInput
    applications?: LaunchApplicationUncheckedUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateWithoutCryptoProjectsInput = {
    id?: string
    email: string
    passwordHash: string
    walletAddress?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    isEmailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    displayName?: string | null
    avatarUrl?: string | null
    bio?: string | null
    apiCallCount?: number
    apiCallResetAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    businesses?: BusinessCreateNestedManyWithoutUserInput
    identityVerification?: PrivateIdentityVerificationCreateNestedOneWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    systemLogs?: SystemLogCreateNestedManyWithoutUserInput
    trustScoreEvents?: TrustScoreEventCreateNestedManyWithoutUserInput
    contactMessages?: ContactMessageCreateNestedManyWithoutUserInput
    applications?: LaunchApplicationCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutCryptoProjectsInput = {
    id?: string
    email: string
    passwordHash: string
    walletAddress?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    isEmailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    displayName?: string | null
    avatarUrl?: string | null
    bio?: string | null
    apiCallCount?: number
    apiCallResetAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    businesses?: BusinessUncheckedCreateNestedManyWithoutUserInput
    identityVerification?: PrivateIdentityVerificationUncheckedCreateNestedOneWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutUserInput
    trustScoreEvents?: TrustScoreEventUncheckedCreateNestedManyWithoutUserInput
    contactMessages?: ContactMessageUncheckedCreateNestedManyWithoutUserInput
    applications?: LaunchApplicationUncheckedCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutCryptoProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCryptoProjectsInput, UserUncheckedCreateWithoutCryptoProjectsInput>
  }

  export type TrustScoreEventCreateWithoutProjectInput = {
    id?: string
    eventType: $Enums.TrustScoreEventType
    points: number
    reason: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredBy?: string | null
    createdAt?: Date | string
    business?: BusinessCreateNestedOneWithoutTrustScoreEventsInput
    user?: UserCreateNestedOneWithoutTrustScoreEventsInput
  }

  export type TrustScoreEventUncheckedCreateWithoutProjectInput = {
    id?: string
    businessId?: string | null
    userId?: string | null
    eventType: $Enums.TrustScoreEventType
    points: number
    reason: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredBy?: string | null
    createdAt?: Date | string
  }

  export type TrustScoreEventCreateOrConnectWithoutProjectInput = {
    where: TrustScoreEventWhereUniqueInput
    create: XOR<TrustScoreEventCreateWithoutProjectInput, TrustScoreEventUncheckedCreateWithoutProjectInput>
  }

  export type TrustScoreEventCreateManyProjectInputEnvelope = {
    data: TrustScoreEventCreateManyProjectInput | TrustScoreEventCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type AdminNoteCreateWithoutProjectInput = {
    id?: string
    note: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutAdminNotesInput
    business?: BusinessCreateNestedOneWithoutAdminNotesInput
    contact?: ContactMessageCreateNestedOneWithoutAdminNotesInput
    application?: LaunchApplicationCreateNestedOneWithoutAdminNotesInput
  }

  export type AdminNoteUncheckedCreateWithoutProjectInput = {
    id?: string
    authorId: string
    businessId?: string | null
    contactId?: string | null
    applicationId?: string | null
    note: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminNoteCreateOrConnectWithoutProjectInput = {
    where: AdminNoteWhereUniqueInput
    create: XOR<AdminNoteCreateWithoutProjectInput, AdminNoteUncheckedCreateWithoutProjectInput>
  }

  export type AdminNoteCreateManyProjectInputEnvelope = {
    data: AdminNoteCreateManyProjectInput | AdminNoteCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectDocumentCreateWithoutProjectInput = {
    id?: string
    name: string
    type: string
    fileUrl: string
    fileHash?: string | null
    fileSize?: number | null
    mimeType?: string | null
    isPublic?: boolean
    uploadedAt?: Date | string
  }

  export type ProjectDocumentUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    type: string
    fileUrl: string
    fileHash?: string | null
    fileSize?: number | null
    mimeType?: string | null
    isPublic?: boolean
    uploadedAt?: Date | string
  }

  export type ProjectDocumentCreateOrConnectWithoutProjectInput = {
    where: ProjectDocumentWhereUniqueInput
    create: XOR<ProjectDocumentCreateWithoutProjectInput, ProjectDocumentUncheckedCreateWithoutProjectInput>
  }

  export type ProjectDocumentCreateManyProjectInputEnvelope = {
    data: ProjectDocumentCreateManyProjectInput | ProjectDocumentCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCryptoProjectsInput = {
    update: XOR<UserUpdateWithoutCryptoProjectsInput, UserUncheckedUpdateWithoutCryptoProjectsInput>
    create: XOR<UserCreateWithoutCryptoProjectsInput, UserUncheckedCreateWithoutCryptoProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCryptoProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCryptoProjectsInput, UserUncheckedUpdateWithoutCryptoProjectsInput>
  }

  export type UserUpdateWithoutCryptoProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallCount?: IntFieldUpdateOperationsInput | number
    apiCallResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businesses?: BusinessUpdateManyWithoutUserNestedInput
    identityVerification?: PrivateIdentityVerificationUpdateOneWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    systemLogs?: SystemLogUpdateManyWithoutUserNestedInput
    trustScoreEvents?: TrustScoreEventUpdateManyWithoutUserNestedInput
    contactMessages?: ContactMessageUpdateManyWithoutUserNestedInput
    applications?: LaunchApplicationUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutCryptoProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallCount?: IntFieldUpdateOperationsInput | number
    apiCallResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businesses?: BusinessUncheckedUpdateManyWithoutUserNestedInput
    identityVerification?: PrivateIdentityVerificationUncheckedUpdateOneWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutUserNestedInput
    trustScoreEvents?: TrustScoreEventUncheckedUpdateManyWithoutUserNestedInput
    contactMessages?: ContactMessageUncheckedUpdateManyWithoutUserNestedInput
    applications?: LaunchApplicationUncheckedUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type TrustScoreEventUpsertWithWhereUniqueWithoutProjectInput = {
    where: TrustScoreEventWhereUniqueInput
    update: XOR<TrustScoreEventUpdateWithoutProjectInput, TrustScoreEventUncheckedUpdateWithoutProjectInput>
    create: XOR<TrustScoreEventCreateWithoutProjectInput, TrustScoreEventUncheckedCreateWithoutProjectInput>
  }

  export type TrustScoreEventUpdateWithWhereUniqueWithoutProjectInput = {
    where: TrustScoreEventWhereUniqueInput
    data: XOR<TrustScoreEventUpdateWithoutProjectInput, TrustScoreEventUncheckedUpdateWithoutProjectInput>
  }

  export type TrustScoreEventUpdateManyWithWhereWithoutProjectInput = {
    where: TrustScoreEventScalarWhereInput
    data: XOR<TrustScoreEventUpdateManyMutationInput, TrustScoreEventUncheckedUpdateManyWithoutProjectInput>
  }

  export type AdminNoteUpsertWithWhereUniqueWithoutProjectInput = {
    where: AdminNoteWhereUniqueInput
    update: XOR<AdminNoteUpdateWithoutProjectInput, AdminNoteUncheckedUpdateWithoutProjectInput>
    create: XOR<AdminNoteCreateWithoutProjectInput, AdminNoteUncheckedCreateWithoutProjectInput>
  }

  export type AdminNoteUpdateWithWhereUniqueWithoutProjectInput = {
    where: AdminNoteWhereUniqueInput
    data: XOR<AdminNoteUpdateWithoutProjectInput, AdminNoteUncheckedUpdateWithoutProjectInput>
  }

  export type AdminNoteUpdateManyWithWhereWithoutProjectInput = {
    where: AdminNoteScalarWhereInput
    data: XOR<AdminNoteUpdateManyMutationInput, AdminNoteUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectDocumentUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectDocumentWhereUniqueInput
    update: XOR<ProjectDocumentUpdateWithoutProjectInput, ProjectDocumentUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectDocumentCreateWithoutProjectInput, ProjectDocumentUncheckedCreateWithoutProjectInput>
  }

  export type ProjectDocumentUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectDocumentWhereUniqueInput
    data: XOR<ProjectDocumentUpdateWithoutProjectInput, ProjectDocumentUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectDocumentUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectDocumentScalarWhereInput
    data: XOR<ProjectDocumentUpdateManyMutationInput, ProjectDocumentUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectDocumentScalarWhereInput = {
    AND?: ProjectDocumentScalarWhereInput | ProjectDocumentScalarWhereInput[]
    OR?: ProjectDocumentScalarWhereInput[]
    NOT?: ProjectDocumentScalarWhereInput | ProjectDocumentScalarWhereInput[]
    id?: StringFilter<"ProjectDocument"> | string
    projectId?: StringFilter<"ProjectDocument"> | string
    name?: StringFilter<"ProjectDocument"> | string
    type?: StringFilter<"ProjectDocument"> | string
    fileUrl?: StringFilter<"ProjectDocument"> | string
    fileHash?: StringNullableFilter<"ProjectDocument"> | string | null
    fileSize?: IntNullableFilter<"ProjectDocument"> | number | null
    mimeType?: StringNullableFilter<"ProjectDocument"> | string | null
    isPublic?: BoolFilter<"ProjectDocument"> | boolean
    uploadedAt?: DateTimeFilter<"ProjectDocument"> | Date | string
  }

  export type CryptoProjectCreateWithoutDocumentsInput = {
    id?: string
    name: string
    symbol?: string | null
    description?: string | null
    category?: string | null
    website?: string | null
    whitepaper?: string | null
    twitter?: string | null
    discord?: string | null
    telegram?: string | null
    github?: string | null
    tokenType?: $Enums.TokenType
    totalSupply?: string | null
    decimals?: number
    teamAllocationPercent?: number | null
    teamVestingMonths?: number | null
    teamCliffMonths?: number | null
    vestingType?: $Enums.VestingType | null
    initialLiquidity?: string | null
    liquidityLockMonths?: number | null
    liquidityLockTxHash?: string | null
    auditProvider?: string | null
    auditReportUrl?: string | null
    auditDate?: Date | string | null
    contractAddress?: string | null
    contractVerified?: boolean
    status?: $Enums.ProjectStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    rejectionReason?: string | null
    trustScore?: number
    trustScoreUpdatedAt?: Date | string | null
    launchDate?: Date | string | null
    softCap?: string | null
    hardCap?: string | null
    minContribution?: string | null
    maxContribution?: string | null
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCryptoProjectsInput
    trustScoreEvents?: TrustScoreEventCreateNestedManyWithoutProjectInput
    adminNotes?: AdminNoteCreateNestedManyWithoutProjectInput
  }

  export type CryptoProjectUncheckedCreateWithoutDocumentsInput = {
    id?: string
    userId: string
    name: string
    symbol?: string | null
    description?: string | null
    category?: string | null
    website?: string | null
    whitepaper?: string | null
    twitter?: string | null
    discord?: string | null
    telegram?: string | null
    github?: string | null
    tokenType?: $Enums.TokenType
    totalSupply?: string | null
    decimals?: number
    teamAllocationPercent?: number | null
    teamVestingMonths?: number | null
    teamCliffMonths?: number | null
    vestingType?: $Enums.VestingType | null
    initialLiquidity?: string | null
    liquidityLockMonths?: number | null
    liquidityLockTxHash?: string | null
    auditProvider?: string | null
    auditReportUrl?: string | null
    auditDate?: Date | string | null
    contractAddress?: string | null
    contractVerified?: boolean
    status?: $Enums.ProjectStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    rejectionReason?: string | null
    trustScore?: number
    trustScoreUpdatedAt?: Date | string | null
    launchDate?: Date | string | null
    softCap?: string | null
    hardCap?: string | null
    minContribution?: string | null
    maxContribution?: string | null
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    trustScoreEvents?: TrustScoreEventUncheckedCreateNestedManyWithoutProjectInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutProjectInput
  }

  export type CryptoProjectCreateOrConnectWithoutDocumentsInput = {
    where: CryptoProjectWhereUniqueInput
    create: XOR<CryptoProjectCreateWithoutDocumentsInput, CryptoProjectUncheckedCreateWithoutDocumentsInput>
  }

  export type CryptoProjectUpsertWithoutDocumentsInput = {
    update: XOR<CryptoProjectUpdateWithoutDocumentsInput, CryptoProjectUncheckedUpdateWithoutDocumentsInput>
    create: XOR<CryptoProjectCreateWithoutDocumentsInput, CryptoProjectUncheckedCreateWithoutDocumentsInput>
    where?: CryptoProjectWhereInput
  }

  export type CryptoProjectUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: CryptoProjectWhereInput
    data: XOR<CryptoProjectUpdateWithoutDocumentsInput, CryptoProjectUncheckedUpdateWithoutDocumentsInput>
  }

  export type CryptoProjectUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    whitepaper?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    totalSupply?: NullableStringFieldUpdateOperationsInput | string | null
    decimals?: IntFieldUpdateOperationsInput | number
    teamAllocationPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    teamVestingMonths?: NullableIntFieldUpdateOperationsInput | number | null
    teamCliffMonths?: NullableIntFieldUpdateOperationsInput | number | null
    vestingType?: NullableEnumVestingTypeFieldUpdateOperationsInput | $Enums.VestingType | null
    initialLiquidity?: NullableStringFieldUpdateOperationsInput | string | null
    liquidityLockMonths?: NullableIntFieldUpdateOperationsInput | number | null
    liquidityLockTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    auditProvider?: NullableStringFieldUpdateOperationsInput | string | null
    auditReportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    auditDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    contractVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    trustScoreUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    launchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    softCap?: NullableStringFieldUpdateOperationsInput | string | null
    hardCap?: NullableStringFieldUpdateOperationsInput | string | null
    minContribution?: NullableStringFieldUpdateOperationsInput | string | null
    maxContribution?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCryptoProjectsNestedInput
    trustScoreEvents?: TrustScoreEventUpdateManyWithoutProjectNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutProjectNestedInput
  }

  export type CryptoProjectUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    whitepaper?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    totalSupply?: NullableStringFieldUpdateOperationsInput | string | null
    decimals?: IntFieldUpdateOperationsInput | number
    teamAllocationPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    teamVestingMonths?: NullableIntFieldUpdateOperationsInput | number | null
    teamCliffMonths?: NullableIntFieldUpdateOperationsInput | number | null
    vestingType?: NullableEnumVestingTypeFieldUpdateOperationsInput | $Enums.VestingType | null
    initialLiquidity?: NullableStringFieldUpdateOperationsInput | string | null
    liquidityLockMonths?: NullableIntFieldUpdateOperationsInput | number | null
    liquidityLockTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    auditProvider?: NullableStringFieldUpdateOperationsInput | string | null
    auditReportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    auditDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    contractVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    trustScoreUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    launchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    softCap?: NullableStringFieldUpdateOperationsInput | string | null
    hardCap?: NullableStringFieldUpdateOperationsInput | string | null
    minContribution?: NullableStringFieldUpdateOperationsInput | string | null
    maxContribution?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trustScoreEvents?: TrustScoreEventUncheckedUpdateManyWithoutProjectNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserCreateWithoutBusinessesInput = {
    id?: string
    email: string
    passwordHash: string
    walletAddress?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    isEmailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    displayName?: string | null
    avatarUrl?: string | null
    bio?: string | null
    apiCallCount?: number
    apiCallResetAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cryptoProjects?: CryptoProjectCreateNestedManyWithoutUserInput
    identityVerification?: PrivateIdentityVerificationCreateNestedOneWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    systemLogs?: SystemLogCreateNestedManyWithoutUserInput
    trustScoreEvents?: TrustScoreEventCreateNestedManyWithoutUserInput
    contactMessages?: ContactMessageCreateNestedManyWithoutUserInput
    applications?: LaunchApplicationCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutBusinessesInput = {
    id?: string
    email: string
    passwordHash: string
    walletAddress?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    isEmailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    displayName?: string | null
    avatarUrl?: string | null
    bio?: string | null
    apiCallCount?: number
    apiCallResetAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cryptoProjects?: CryptoProjectUncheckedCreateNestedManyWithoutUserInput
    identityVerification?: PrivateIdentityVerificationUncheckedCreateNestedOneWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutUserInput
    trustScoreEvents?: TrustScoreEventUncheckedCreateNestedManyWithoutUserInput
    contactMessages?: ContactMessageUncheckedCreateNestedManyWithoutUserInput
    applications?: LaunchApplicationUncheckedCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutBusinessesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBusinessesInput, UserUncheckedCreateWithoutBusinessesInput>
  }

  export type BusinessFounderCreateWithoutBusinessInput = {
    id?: string
    name: string
    role: string
    email?: string | null
    ownershipPercent?: number | null
    walletAddress?: string | null
    linkedinUrl?: string | null
    kycVerified?: boolean
    kycVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessFounderUncheckedCreateWithoutBusinessInput = {
    id?: string
    name: string
    role: string
    email?: string | null
    ownershipPercent?: number | null
    walletAddress?: string | null
    linkedinUrl?: string | null
    kycVerified?: boolean
    kycVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessFounderCreateOrConnectWithoutBusinessInput = {
    where: BusinessFounderWhereUniqueInput
    create: XOR<BusinessFounderCreateWithoutBusinessInput, BusinessFounderUncheckedCreateWithoutBusinessInput>
  }

  export type BusinessFounderCreateManyBusinessInputEnvelope = {
    data: BusinessFounderCreateManyBusinessInput | BusinessFounderCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type BusinessDocumentCreateWithoutBusinessInput = {
    id?: string
    name: string
    type: string
    fileUrl: string
    fileHash?: string | null
    fileSize?: number | null
    mimeType?: string | null
    isPublic?: boolean
    isVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    uploadedAt?: Date | string
  }

  export type BusinessDocumentUncheckedCreateWithoutBusinessInput = {
    id?: string
    name: string
    type: string
    fileUrl: string
    fileHash?: string | null
    fileSize?: number | null
    mimeType?: string | null
    isPublic?: boolean
    isVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    uploadedAt?: Date | string
  }

  export type BusinessDocumentCreateOrConnectWithoutBusinessInput = {
    where: BusinessDocumentWhereUniqueInput
    create: XOR<BusinessDocumentCreateWithoutBusinessInput, BusinessDocumentUncheckedCreateWithoutBusinessInput>
  }

  export type BusinessDocumentCreateManyBusinessInputEnvelope = {
    data: BusinessDocumentCreateManyBusinessInput | BusinessDocumentCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type TrustScoreEventCreateWithoutBusinessInput = {
    id?: string
    eventType: $Enums.TrustScoreEventType
    points: number
    reason: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredBy?: string | null
    createdAt?: Date | string
    project?: CryptoProjectCreateNestedOneWithoutTrustScoreEventsInput
    user?: UserCreateNestedOneWithoutTrustScoreEventsInput
  }

  export type TrustScoreEventUncheckedCreateWithoutBusinessInput = {
    id?: string
    projectId?: string | null
    userId?: string | null
    eventType: $Enums.TrustScoreEventType
    points: number
    reason: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredBy?: string | null
    createdAt?: Date | string
  }

  export type TrustScoreEventCreateOrConnectWithoutBusinessInput = {
    where: TrustScoreEventWhereUniqueInput
    create: XOR<TrustScoreEventCreateWithoutBusinessInput, TrustScoreEventUncheckedCreateWithoutBusinessInput>
  }

  export type TrustScoreEventCreateManyBusinessInputEnvelope = {
    data: TrustScoreEventCreateManyBusinessInput | TrustScoreEventCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type AdminNoteCreateWithoutBusinessInput = {
    id?: string
    note: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutAdminNotesInput
    project?: CryptoProjectCreateNestedOneWithoutAdminNotesInput
    contact?: ContactMessageCreateNestedOneWithoutAdminNotesInput
    application?: LaunchApplicationCreateNestedOneWithoutAdminNotesInput
  }

  export type AdminNoteUncheckedCreateWithoutBusinessInput = {
    id?: string
    authorId: string
    projectId?: string | null
    contactId?: string | null
    applicationId?: string | null
    note: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminNoteCreateOrConnectWithoutBusinessInput = {
    where: AdminNoteWhereUniqueInput
    create: XOR<AdminNoteCreateWithoutBusinessInput, AdminNoteUncheckedCreateWithoutBusinessInput>
  }

  export type AdminNoteCreateManyBusinessInputEnvelope = {
    data: AdminNoteCreateManyBusinessInput | AdminNoteCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type RevenueReportCreateWithoutBusinessInput = {
    id?: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    grossRevenue: string
    eligibleRevenue?: string | null
    distributionAmount?: string | null
    documentUrl?: string | null
    documentHash?: string | null
    isVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    submittedAt?: Date | string
  }

  export type RevenueReportUncheckedCreateWithoutBusinessInput = {
    id?: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    grossRevenue: string
    eligibleRevenue?: string | null
    distributionAmount?: string | null
    documentUrl?: string | null
    documentHash?: string | null
    isVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    submittedAt?: Date | string
  }

  export type RevenueReportCreateOrConnectWithoutBusinessInput = {
    where: RevenueReportWhereUniqueInput
    create: XOR<RevenueReportCreateWithoutBusinessInput, RevenueReportUncheckedCreateWithoutBusinessInput>
  }

  export type RevenueReportCreateManyBusinessInputEnvelope = {
    data: RevenueReportCreateManyBusinessInput | RevenueReportCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBusinessesInput = {
    update: XOR<UserUpdateWithoutBusinessesInput, UserUncheckedUpdateWithoutBusinessesInput>
    create: XOR<UserCreateWithoutBusinessesInput, UserUncheckedCreateWithoutBusinessesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBusinessesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBusinessesInput, UserUncheckedUpdateWithoutBusinessesInput>
  }

  export type UserUpdateWithoutBusinessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallCount?: IntFieldUpdateOperationsInput | number
    apiCallResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cryptoProjects?: CryptoProjectUpdateManyWithoutUserNestedInput
    identityVerification?: PrivateIdentityVerificationUpdateOneWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    systemLogs?: SystemLogUpdateManyWithoutUserNestedInput
    trustScoreEvents?: TrustScoreEventUpdateManyWithoutUserNestedInput
    contactMessages?: ContactMessageUpdateManyWithoutUserNestedInput
    applications?: LaunchApplicationUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutBusinessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallCount?: IntFieldUpdateOperationsInput | number
    apiCallResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cryptoProjects?: CryptoProjectUncheckedUpdateManyWithoutUserNestedInput
    identityVerification?: PrivateIdentityVerificationUncheckedUpdateOneWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutUserNestedInput
    trustScoreEvents?: TrustScoreEventUncheckedUpdateManyWithoutUserNestedInput
    contactMessages?: ContactMessageUncheckedUpdateManyWithoutUserNestedInput
    applications?: LaunchApplicationUncheckedUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type BusinessFounderUpsertWithWhereUniqueWithoutBusinessInput = {
    where: BusinessFounderWhereUniqueInput
    update: XOR<BusinessFounderUpdateWithoutBusinessInput, BusinessFounderUncheckedUpdateWithoutBusinessInput>
    create: XOR<BusinessFounderCreateWithoutBusinessInput, BusinessFounderUncheckedCreateWithoutBusinessInput>
  }

  export type BusinessFounderUpdateWithWhereUniqueWithoutBusinessInput = {
    where: BusinessFounderWhereUniqueInput
    data: XOR<BusinessFounderUpdateWithoutBusinessInput, BusinessFounderUncheckedUpdateWithoutBusinessInput>
  }

  export type BusinessFounderUpdateManyWithWhereWithoutBusinessInput = {
    where: BusinessFounderScalarWhereInput
    data: XOR<BusinessFounderUpdateManyMutationInput, BusinessFounderUncheckedUpdateManyWithoutBusinessInput>
  }

  export type BusinessFounderScalarWhereInput = {
    AND?: BusinessFounderScalarWhereInput | BusinessFounderScalarWhereInput[]
    OR?: BusinessFounderScalarWhereInput[]
    NOT?: BusinessFounderScalarWhereInput | BusinessFounderScalarWhereInput[]
    id?: StringFilter<"BusinessFounder"> | string
    businessId?: StringFilter<"BusinessFounder"> | string
    name?: StringFilter<"BusinessFounder"> | string
    role?: StringFilter<"BusinessFounder"> | string
    email?: StringNullableFilter<"BusinessFounder"> | string | null
    ownershipPercent?: FloatNullableFilter<"BusinessFounder"> | number | null
    walletAddress?: StringNullableFilter<"BusinessFounder"> | string | null
    linkedinUrl?: StringNullableFilter<"BusinessFounder"> | string | null
    kycVerified?: BoolFilter<"BusinessFounder"> | boolean
    kycVerifiedAt?: DateTimeNullableFilter<"BusinessFounder"> | Date | string | null
    createdAt?: DateTimeFilter<"BusinessFounder"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessFounder"> | Date | string
  }

  export type BusinessDocumentUpsertWithWhereUniqueWithoutBusinessInput = {
    where: BusinessDocumentWhereUniqueInput
    update: XOR<BusinessDocumentUpdateWithoutBusinessInput, BusinessDocumentUncheckedUpdateWithoutBusinessInput>
    create: XOR<BusinessDocumentCreateWithoutBusinessInput, BusinessDocumentUncheckedCreateWithoutBusinessInput>
  }

  export type BusinessDocumentUpdateWithWhereUniqueWithoutBusinessInput = {
    where: BusinessDocumentWhereUniqueInput
    data: XOR<BusinessDocumentUpdateWithoutBusinessInput, BusinessDocumentUncheckedUpdateWithoutBusinessInput>
  }

  export type BusinessDocumentUpdateManyWithWhereWithoutBusinessInput = {
    where: BusinessDocumentScalarWhereInput
    data: XOR<BusinessDocumentUpdateManyMutationInput, BusinessDocumentUncheckedUpdateManyWithoutBusinessInput>
  }

  export type BusinessDocumentScalarWhereInput = {
    AND?: BusinessDocumentScalarWhereInput | BusinessDocumentScalarWhereInput[]
    OR?: BusinessDocumentScalarWhereInput[]
    NOT?: BusinessDocumentScalarWhereInput | BusinessDocumentScalarWhereInput[]
    id?: StringFilter<"BusinessDocument"> | string
    businessId?: StringFilter<"BusinessDocument"> | string
    name?: StringFilter<"BusinessDocument"> | string
    type?: StringFilter<"BusinessDocument"> | string
    fileUrl?: StringFilter<"BusinessDocument"> | string
    fileHash?: StringNullableFilter<"BusinessDocument"> | string | null
    fileSize?: IntNullableFilter<"BusinessDocument"> | number | null
    mimeType?: StringNullableFilter<"BusinessDocument"> | string | null
    isPublic?: BoolFilter<"BusinessDocument"> | boolean
    isVerified?: BoolFilter<"BusinessDocument"> | boolean
    verifiedBy?: StringNullableFilter<"BusinessDocument"> | string | null
    verifiedAt?: DateTimeNullableFilter<"BusinessDocument"> | Date | string | null
    uploadedAt?: DateTimeFilter<"BusinessDocument"> | Date | string
  }

  export type TrustScoreEventUpsertWithWhereUniqueWithoutBusinessInput = {
    where: TrustScoreEventWhereUniqueInput
    update: XOR<TrustScoreEventUpdateWithoutBusinessInput, TrustScoreEventUncheckedUpdateWithoutBusinessInput>
    create: XOR<TrustScoreEventCreateWithoutBusinessInput, TrustScoreEventUncheckedCreateWithoutBusinessInput>
  }

  export type TrustScoreEventUpdateWithWhereUniqueWithoutBusinessInput = {
    where: TrustScoreEventWhereUniqueInput
    data: XOR<TrustScoreEventUpdateWithoutBusinessInput, TrustScoreEventUncheckedUpdateWithoutBusinessInput>
  }

  export type TrustScoreEventUpdateManyWithWhereWithoutBusinessInput = {
    where: TrustScoreEventScalarWhereInput
    data: XOR<TrustScoreEventUpdateManyMutationInput, TrustScoreEventUncheckedUpdateManyWithoutBusinessInput>
  }

  export type AdminNoteUpsertWithWhereUniqueWithoutBusinessInput = {
    where: AdminNoteWhereUniqueInput
    update: XOR<AdminNoteUpdateWithoutBusinessInput, AdminNoteUncheckedUpdateWithoutBusinessInput>
    create: XOR<AdminNoteCreateWithoutBusinessInput, AdminNoteUncheckedCreateWithoutBusinessInput>
  }

  export type AdminNoteUpdateWithWhereUniqueWithoutBusinessInput = {
    where: AdminNoteWhereUniqueInput
    data: XOR<AdminNoteUpdateWithoutBusinessInput, AdminNoteUncheckedUpdateWithoutBusinessInput>
  }

  export type AdminNoteUpdateManyWithWhereWithoutBusinessInput = {
    where: AdminNoteScalarWhereInput
    data: XOR<AdminNoteUpdateManyMutationInput, AdminNoteUncheckedUpdateManyWithoutBusinessInput>
  }

  export type RevenueReportUpsertWithWhereUniqueWithoutBusinessInput = {
    where: RevenueReportWhereUniqueInput
    update: XOR<RevenueReportUpdateWithoutBusinessInput, RevenueReportUncheckedUpdateWithoutBusinessInput>
    create: XOR<RevenueReportCreateWithoutBusinessInput, RevenueReportUncheckedCreateWithoutBusinessInput>
  }

  export type RevenueReportUpdateWithWhereUniqueWithoutBusinessInput = {
    where: RevenueReportWhereUniqueInput
    data: XOR<RevenueReportUpdateWithoutBusinessInput, RevenueReportUncheckedUpdateWithoutBusinessInput>
  }

  export type RevenueReportUpdateManyWithWhereWithoutBusinessInput = {
    where: RevenueReportScalarWhereInput
    data: XOR<RevenueReportUpdateManyMutationInput, RevenueReportUncheckedUpdateManyWithoutBusinessInput>
  }

  export type RevenueReportScalarWhereInput = {
    AND?: RevenueReportScalarWhereInput | RevenueReportScalarWhereInput[]
    OR?: RevenueReportScalarWhereInput[]
    NOT?: RevenueReportScalarWhereInput | RevenueReportScalarWhereInput[]
    id?: StringFilter<"RevenueReport"> | string
    businessId?: StringFilter<"RevenueReport"> | string
    period?: StringFilter<"RevenueReport"> | string
    periodStart?: DateTimeFilter<"RevenueReport"> | Date | string
    periodEnd?: DateTimeFilter<"RevenueReport"> | Date | string
    grossRevenue?: StringFilter<"RevenueReport"> | string
    eligibleRevenue?: StringNullableFilter<"RevenueReport"> | string | null
    distributionAmount?: StringNullableFilter<"RevenueReport"> | string | null
    documentUrl?: StringNullableFilter<"RevenueReport"> | string | null
    documentHash?: StringNullableFilter<"RevenueReport"> | string | null
    isVerified?: BoolFilter<"RevenueReport"> | boolean
    verifiedBy?: StringNullableFilter<"RevenueReport"> | string | null
    verifiedAt?: DateTimeNullableFilter<"RevenueReport"> | Date | string | null
    submittedAt?: DateTimeFilter<"RevenueReport"> | Date | string
  }

  export type BusinessCreateWithoutFoundersInput = {
    id?: string
    legalName: string
    dba?: string | null
    entityType?: string | null
    jurisdiction?: string | null
    ein?: string | null
    registrationNumber?: string | null
    incorporationDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    businessEmail?: string | null
    businessPhone?: string | null
    website?: string | null
    description?: string | null
    industry?: string | null
    employeeCount?: number | null
    annualRevenue?: string | null
    linkedin?: string | null
    twitter?: string | null
    kybLevel?: $Enums.KYBLevel
    kybProvider?: string | null
    kybVerifiedAt?: Date | string | null
    kybExpiresAt?: Date | string | null
    kybRejectionReason?: string | null
    tokenType?: $Enums.TokenType | null
    raiseAmount?: string | null
    equityPercent?: number | null
    revenueSharePercent?: number | null
    minInvestment?: string | null
    maxInvestment?: string | null
    status?: $Enums.BusinessStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    rejectionReason?: string | null
    trustScore?: number
    trustScoreUpdatedAt?: Date | string | null
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBusinessesInput
    documents?: BusinessDocumentCreateNestedManyWithoutBusinessInput
    trustScoreEvents?: TrustScoreEventCreateNestedManyWithoutBusinessInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBusinessInput
    revenueReports?: RevenueReportCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutFoundersInput = {
    id?: string
    userId: string
    legalName: string
    dba?: string | null
    entityType?: string | null
    jurisdiction?: string | null
    ein?: string | null
    registrationNumber?: string | null
    incorporationDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    businessEmail?: string | null
    businessPhone?: string | null
    website?: string | null
    description?: string | null
    industry?: string | null
    employeeCount?: number | null
    annualRevenue?: string | null
    linkedin?: string | null
    twitter?: string | null
    kybLevel?: $Enums.KYBLevel
    kybProvider?: string | null
    kybVerifiedAt?: Date | string | null
    kybExpiresAt?: Date | string | null
    kybRejectionReason?: string | null
    tokenType?: $Enums.TokenType | null
    raiseAmount?: string | null
    equityPercent?: number | null
    revenueSharePercent?: number | null
    minInvestment?: string | null
    maxInvestment?: string | null
    status?: $Enums.BusinessStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    rejectionReason?: string | null
    trustScore?: number
    trustScoreUpdatedAt?: Date | string | null
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: BusinessDocumentUncheckedCreateNestedManyWithoutBusinessInput
    trustScoreEvents?: TrustScoreEventUncheckedCreateNestedManyWithoutBusinessInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBusinessInput
    revenueReports?: RevenueReportUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutFoundersInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutFoundersInput, BusinessUncheckedCreateWithoutFoundersInput>
  }

  export type BusinessUpsertWithoutFoundersInput = {
    update: XOR<BusinessUpdateWithoutFoundersInput, BusinessUncheckedUpdateWithoutFoundersInput>
    create: XOR<BusinessCreateWithoutFoundersInput, BusinessUncheckedCreateWithoutFoundersInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutFoundersInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutFoundersInput, BusinessUncheckedUpdateWithoutFoundersInput>
  }

  export type BusinessUpdateWithoutFoundersInput = {
    id?: StringFieldUpdateOperationsInput | string
    legalName?: StringFieldUpdateOperationsInput | string
    dba?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    ein?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    incorporationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    businessEmail?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    annualRevenue?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    kybLevel?: EnumKYBLevelFieldUpdateOperationsInput | $Enums.KYBLevel
    kybProvider?: NullableStringFieldUpdateOperationsInput | string | null
    kybVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybRejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableEnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType | null
    raiseAmount?: NullableStringFieldUpdateOperationsInput | string | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    revenueSharePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    maxInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    trustScoreUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBusinessesNestedInput
    documents?: BusinessDocumentUpdateManyWithoutBusinessNestedInput
    trustScoreEvents?: TrustScoreEventUpdateManyWithoutBusinessNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBusinessNestedInput
    revenueReports?: RevenueReportUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutFoundersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    legalName?: StringFieldUpdateOperationsInput | string
    dba?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    ein?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    incorporationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    businessEmail?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    annualRevenue?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    kybLevel?: EnumKYBLevelFieldUpdateOperationsInput | $Enums.KYBLevel
    kybProvider?: NullableStringFieldUpdateOperationsInput | string | null
    kybVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybRejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableEnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType | null
    raiseAmount?: NullableStringFieldUpdateOperationsInput | string | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    revenueSharePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    maxInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    trustScoreUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: BusinessDocumentUncheckedUpdateManyWithoutBusinessNestedInput
    trustScoreEvents?: TrustScoreEventUncheckedUpdateManyWithoutBusinessNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBusinessNestedInput
    revenueReports?: RevenueReportUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessCreateWithoutDocumentsInput = {
    id?: string
    legalName: string
    dba?: string | null
    entityType?: string | null
    jurisdiction?: string | null
    ein?: string | null
    registrationNumber?: string | null
    incorporationDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    businessEmail?: string | null
    businessPhone?: string | null
    website?: string | null
    description?: string | null
    industry?: string | null
    employeeCount?: number | null
    annualRevenue?: string | null
    linkedin?: string | null
    twitter?: string | null
    kybLevel?: $Enums.KYBLevel
    kybProvider?: string | null
    kybVerifiedAt?: Date | string | null
    kybExpiresAt?: Date | string | null
    kybRejectionReason?: string | null
    tokenType?: $Enums.TokenType | null
    raiseAmount?: string | null
    equityPercent?: number | null
    revenueSharePercent?: number | null
    minInvestment?: string | null
    maxInvestment?: string | null
    status?: $Enums.BusinessStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    rejectionReason?: string | null
    trustScore?: number
    trustScoreUpdatedAt?: Date | string | null
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBusinessesInput
    founders?: BusinessFounderCreateNestedManyWithoutBusinessInput
    trustScoreEvents?: TrustScoreEventCreateNestedManyWithoutBusinessInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBusinessInput
    revenueReports?: RevenueReportCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutDocumentsInput = {
    id?: string
    userId: string
    legalName: string
    dba?: string | null
    entityType?: string | null
    jurisdiction?: string | null
    ein?: string | null
    registrationNumber?: string | null
    incorporationDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    businessEmail?: string | null
    businessPhone?: string | null
    website?: string | null
    description?: string | null
    industry?: string | null
    employeeCount?: number | null
    annualRevenue?: string | null
    linkedin?: string | null
    twitter?: string | null
    kybLevel?: $Enums.KYBLevel
    kybProvider?: string | null
    kybVerifiedAt?: Date | string | null
    kybExpiresAt?: Date | string | null
    kybRejectionReason?: string | null
    tokenType?: $Enums.TokenType | null
    raiseAmount?: string | null
    equityPercent?: number | null
    revenueSharePercent?: number | null
    minInvestment?: string | null
    maxInvestment?: string | null
    status?: $Enums.BusinessStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    rejectionReason?: string | null
    trustScore?: number
    trustScoreUpdatedAt?: Date | string | null
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    founders?: BusinessFounderUncheckedCreateNestedManyWithoutBusinessInput
    trustScoreEvents?: TrustScoreEventUncheckedCreateNestedManyWithoutBusinessInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBusinessInput
    revenueReports?: RevenueReportUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutDocumentsInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutDocumentsInput, BusinessUncheckedCreateWithoutDocumentsInput>
  }

  export type BusinessUpsertWithoutDocumentsInput = {
    update: XOR<BusinessUpdateWithoutDocumentsInput, BusinessUncheckedUpdateWithoutDocumentsInput>
    create: XOR<BusinessCreateWithoutDocumentsInput, BusinessUncheckedCreateWithoutDocumentsInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutDocumentsInput, BusinessUncheckedUpdateWithoutDocumentsInput>
  }

  export type BusinessUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    legalName?: StringFieldUpdateOperationsInput | string
    dba?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    ein?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    incorporationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    businessEmail?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    annualRevenue?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    kybLevel?: EnumKYBLevelFieldUpdateOperationsInput | $Enums.KYBLevel
    kybProvider?: NullableStringFieldUpdateOperationsInput | string | null
    kybVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybRejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableEnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType | null
    raiseAmount?: NullableStringFieldUpdateOperationsInput | string | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    revenueSharePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    maxInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    trustScoreUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBusinessesNestedInput
    founders?: BusinessFounderUpdateManyWithoutBusinessNestedInput
    trustScoreEvents?: TrustScoreEventUpdateManyWithoutBusinessNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBusinessNestedInput
    revenueReports?: RevenueReportUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    legalName?: StringFieldUpdateOperationsInput | string
    dba?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    ein?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    incorporationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    businessEmail?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    annualRevenue?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    kybLevel?: EnumKYBLevelFieldUpdateOperationsInput | $Enums.KYBLevel
    kybProvider?: NullableStringFieldUpdateOperationsInput | string | null
    kybVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybRejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableEnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType | null
    raiseAmount?: NullableStringFieldUpdateOperationsInput | string | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    revenueSharePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    maxInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    trustScoreUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founders?: BusinessFounderUncheckedUpdateManyWithoutBusinessNestedInput
    trustScoreEvents?: TrustScoreEventUncheckedUpdateManyWithoutBusinessNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBusinessNestedInput
    revenueReports?: RevenueReportUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessCreateWithoutRevenueReportsInput = {
    id?: string
    legalName: string
    dba?: string | null
    entityType?: string | null
    jurisdiction?: string | null
    ein?: string | null
    registrationNumber?: string | null
    incorporationDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    businessEmail?: string | null
    businessPhone?: string | null
    website?: string | null
    description?: string | null
    industry?: string | null
    employeeCount?: number | null
    annualRevenue?: string | null
    linkedin?: string | null
    twitter?: string | null
    kybLevel?: $Enums.KYBLevel
    kybProvider?: string | null
    kybVerifiedAt?: Date | string | null
    kybExpiresAt?: Date | string | null
    kybRejectionReason?: string | null
    tokenType?: $Enums.TokenType | null
    raiseAmount?: string | null
    equityPercent?: number | null
    revenueSharePercent?: number | null
    minInvestment?: string | null
    maxInvestment?: string | null
    status?: $Enums.BusinessStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    rejectionReason?: string | null
    trustScore?: number
    trustScoreUpdatedAt?: Date | string | null
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBusinessesInput
    founders?: BusinessFounderCreateNestedManyWithoutBusinessInput
    documents?: BusinessDocumentCreateNestedManyWithoutBusinessInput
    trustScoreEvents?: TrustScoreEventCreateNestedManyWithoutBusinessInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutRevenueReportsInput = {
    id?: string
    userId: string
    legalName: string
    dba?: string | null
    entityType?: string | null
    jurisdiction?: string | null
    ein?: string | null
    registrationNumber?: string | null
    incorporationDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    businessEmail?: string | null
    businessPhone?: string | null
    website?: string | null
    description?: string | null
    industry?: string | null
    employeeCount?: number | null
    annualRevenue?: string | null
    linkedin?: string | null
    twitter?: string | null
    kybLevel?: $Enums.KYBLevel
    kybProvider?: string | null
    kybVerifiedAt?: Date | string | null
    kybExpiresAt?: Date | string | null
    kybRejectionReason?: string | null
    tokenType?: $Enums.TokenType | null
    raiseAmount?: string | null
    equityPercent?: number | null
    revenueSharePercent?: number | null
    minInvestment?: string | null
    maxInvestment?: string | null
    status?: $Enums.BusinessStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    rejectionReason?: string | null
    trustScore?: number
    trustScoreUpdatedAt?: Date | string | null
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    founders?: BusinessFounderUncheckedCreateNestedManyWithoutBusinessInput
    documents?: BusinessDocumentUncheckedCreateNestedManyWithoutBusinessInput
    trustScoreEvents?: TrustScoreEventUncheckedCreateNestedManyWithoutBusinessInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutRevenueReportsInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutRevenueReportsInput, BusinessUncheckedCreateWithoutRevenueReportsInput>
  }

  export type BusinessUpsertWithoutRevenueReportsInput = {
    update: XOR<BusinessUpdateWithoutRevenueReportsInput, BusinessUncheckedUpdateWithoutRevenueReportsInput>
    create: XOR<BusinessCreateWithoutRevenueReportsInput, BusinessUncheckedCreateWithoutRevenueReportsInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutRevenueReportsInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutRevenueReportsInput, BusinessUncheckedUpdateWithoutRevenueReportsInput>
  }

  export type BusinessUpdateWithoutRevenueReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    legalName?: StringFieldUpdateOperationsInput | string
    dba?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    ein?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    incorporationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    businessEmail?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    annualRevenue?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    kybLevel?: EnumKYBLevelFieldUpdateOperationsInput | $Enums.KYBLevel
    kybProvider?: NullableStringFieldUpdateOperationsInput | string | null
    kybVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybRejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableEnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType | null
    raiseAmount?: NullableStringFieldUpdateOperationsInput | string | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    revenueSharePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    maxInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    trustScoreUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBusinessesNestedInput
    founders?: BusinessFounderUpdateManyWithoutBusinessNestedInput
    documents?: BusinessDocumentUpdateManyWithoutBusinessNestedInput
    trustScoreEvents?: TrustScoreEventUpdateManyWithoutBusinessNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutRevenueReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    legalName?: StringFieldUpdateOperationsInput | string
    dba?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    ein?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    incorporationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    businessEmail?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    annualRevenue?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    kybLevel?: EnumKYBLevelFieldUpdateOperationsInput | $Enums.KYBLevel
    kybProvider?: NullableStringFieldUpdateOperationsInput | string | null
    kybVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybRejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableEnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType | null
    raiseAmount?: NullableStringFieldUpdateOperationsInput | string | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    revenueSharePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    maxInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    trustScoreUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founders?: BusinessFounderUncheckedUpdateManyWithoutBusinessNestedInput
    documents?: BusinessDocumentUncheckedUpdateManyWithoutBusinessNestedInput
    trustScoreEvents?: TrustScoreEventUncheckedUpdateManyWithoutBusinessNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type UserCreateWithoutIdentityVerificationInput = {
    id?: string
    email: string
    passwordHash: string
    walletAddress?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    isEmailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    displayName?: string | null
    avatarUrl?: string | null
    bio?: string | null
    apiCallCount?: number
    apiCallResetAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cryptoProjects?: CryptoProjectCreateNestedManyWithoutUserInput
    businesses?: BusinessCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    systemLogs?: SystemLogCreateNestedManyWithoutUserInput
    trustScoreEvents?: TrustScoreEventCreateNestedManyWithoutUserInput
    contactMessages?: ContactMessageCreateNestedManyWithoutUserInput
    applications?: LaunchApplicationCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutIdentityVerificationInput = {
    id?: string
    email: string
    passwordHash: string
    walletAddress?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    isEmailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    displayName?: string | null
    avatarUrl?: string | null
    bio?: string | null
    apiCallCount?: number
    apiCallResetAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cryptoProjects?: CryptoProjectUncheckedCreateNestedManyWithoutUserInput
    businesses?: BusinessUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutUserInput
    trustScoreEvents?: TrustScoreEventUncheckedCreateNestedManyWithoutUserInput
    contactMessages?: ContactMessageUncheckedCreateNestedManyWithoutUserInput
    applications?: LaunchApplicationUncheckedCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutIdentityVerificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIdentityVerificationInput, UserUncheckedCreateWithoutIdentityVerificationInput>
  }

  export type UserUpsertWithoutIdentityVerificationInput = {
    update: XOR<UserUpdateWithoutIdentityVerificationInput, UserUncheckedUpdateWithoutIdentityVerificationInput>
    create: XOR<UserCreateWithoutIdentityVerificationInput, UserUncheckedCreateWithoutIdentityVerificationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIdentityVerificationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIdentityVerificationInput, UserUncheckedUpdateWithoutIdentityVerificationInput>
  }

  export type UserUpdateWithoutIdentityVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallCount?: IntFieldUpdateOperationsInput | number
    apiCallResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cryptoProjects?: CryptoProjectUpdateManyWithoutUserNestedInput
    businesses?: BusinessUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    systemLogs?: SystemLogUpdateManyWithoutUserNestedInput
    trustScoreEvents?: TrustScoreEventUpdateManyWithoutUserNestedInput
    contactMessages?: ContactMessageUpdateManyWithoutUserNestedInput
    applications?: LaunchApplicationUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutIdentityVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallCount?: IntFieldUpdateOperationsInput | number
    apiCallResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cryptoProjects?: CryptoProjectUncheckedUpdateManyWithoutUserNestedInput
    businesses?: BusinessUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutUserNestedInput
    trustScoreEvents?: TrustScoreEventUncheckedUpdateManyWithoutUserNestedInput
    contactMessages?: ContactMessageUncheckedUpdateManyWithoutUserNestedInput
    applications?: LaunchApplicationUncheckedUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateWithoutContactMessagesInput = {
    id?: string
    email: string
    passwordHash: string
    walletAddress?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    isEmailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    displayName?: string | null
    avatarUrl?: string | null
    bio?: string | null
    apiCallCount?: number
    apiCallResetAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cryptoProjects?: CryptoProjectCreateNestedManyWithoutUserInput
    businesses?: BusinessCreateNestedManyWithoutUserInput
    identityVerification?: PrivateIdentityVerificationCreateNestedOneWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    systemLogs?: SystemLogCreateNestedManyWithoutUserInput
    trustScoreEvents?: TrustScoreEventCreateNestedManyWithoutUserInput
    applications?: LaunchApplicationCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutContactMessagesInput = {
    id?: string
    email: string
    passwordHash: string
    walletAddress?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    isEmailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    displayName?: string | null
    avatarUrl?: string | null
    bio?: string | null
    apiCallCount?: number
    apiCallResetAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cryptoProjects?: CryptoProjectUncheckedCreateNestedManyWithoutUserInput
    businesses?: BusinessUncheckedCreateNestedManyWithoutUserInput
    identityVerification?: PrivateIdentityVerificationUncheckedCreateNestedOneWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutUserInput
    trustScoreEvents?: TrustScoreEventUncheckedCreateNestedManyWithoutUserInput
    applications?: LaunchApplicationUncheckedCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutContactMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContactMessagesInput, UserUncheckedCreateWithoutContactMessagesInput>
  }

  export type AdminNoteCreateWithoutContactInput = {
    id?: string
    note: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutAdminNotesInput
    project?: CryptoProjectCreateNestedOneWithoutAdminNotesInput
    business?: BusinessCreateNestedOneWithoutAdminNotesInput
    application?: LaunchApplicationCreateNestedOneWithoutAdminNotesInput
  }

  export type AdminNoteUncheckedCreateWithoutContactInput = {
    id?: string
    authorId: string
    projectId?: string | null
    businessId?: string | null
    applicationId?: string | null
    note: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminNoteCreateOrConnectWithoutContactInput = {
    where: AdminNoteWhereUniqueInput
    create: XOR<AdminNoteCreateWithoutContactInput, AdminNoteUncheckedCreateWithoutContactInput>
  }

  export type AdminNoteCreateManyContactInputEnvelope = {
    data: AdminNoteCreateManyContactInput | AdminNoteCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutContactMessagesInput = {
    update: XOR<UserUpdateWithoutContactMessagesInput, UserUncheckedUpdateWithoutContactMessagesInput>
    create: XOR<UserCreateWithoutContactMessagesInput, UserUncheckedCreateWithoutContactMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutContactMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutContactMessagesInput, UserUncheckedUpdateWithoutContactMessagesInput>
  }

  export type UserUpdateWithoutContactMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallCount?: IntFieldUpdateOperationsInput | number
    apiCallResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cryptoProjects?: CryptoProjectUpdateManyWithoutUserNestedInput
    businesses?: BusinessUpdateManyWithoutUserNestedInput
    identityVerification?: PrivateIdentityVerificationUpdateOneWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    systemLogs?: SystemLogUpdateManyWithoutUserNestedInput
    trustScoreEvents?: TrustScoreEventUpdateManyWithoutUserNestedInput
    applications?: LaunchApplicationUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutContactMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallCount?: IntFieldUpdateOperationsInput | number
    apiCallResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cryptoProjects?: CryptoProjectUncheckedUpdateManyWithoutUserNestedInput
    businesses?: BusinessUncheckedUpdateManyWithoutUserNestedInput
    identityVerification?: PrivateIdentityVerificationUncheckedUpdateOneWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutUserNestedInput
    trustScoreEvents?: TrustScoreEventUncheckedUpdateManyWithoutUserNestedInput
    applications?: LaunchApplicationUncheckedUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type AdminNoteUpsertWithWhereUniqueWithoutContactInput = {
    where: AdminNoteWhereUniqueInput
    update: XOR<AdminNoteUpdateWithoutContactInput, AdminNoteUncheckedUpdateWithoutContactInput>
    create: XOR<AdminNoteCreateWithoutContactInput, AdminNoteUncheckedCreateWithoutContactInput>
  }

  export type AdminNoteUpdateWithWhereUniqueWithoutContactInput = {
    where: AdminNoteWhereUniqueInput
    data: XOR<AdminNoteUpdateWithoutContactInput, AdminNoteUncheckedUpdateWithoutContactInput>
  }

  export type AdminNoteUpdateManyWithWhereWithoutContactInput = {
    where: AdminNoteScalarWhereInput
    data: XOR<AdminNoteUpdateManyMutationInput, AdminNoteUncheckedUpdateManyWithoutContactInput>
  }

  export type UserCreateWithoutApplicationsInput = {
    id?: string
    email: string
    passwordHash: string
    walletAddress?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    isEmailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    displayName?: string | null
    avatarUrl?: string | null
    bio?: string | null
    apiCallCount?: number
    apiCallResetAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cryptoProjects?: CryptoProjectCreateNestedManyWithoutUserInput
    businesses?: BusinessCreateNestedManyWithoutUserInput
    identityVerification?: PrivateIdentityVerificationCreateNestedOneWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    systemLogs?: SystemLogCreateNestedManyWithoutUserInput
    trustScoreEvents?: TrustScoreEventCreateNestedManyWithoutUserInput
    contactMessages?: ContactMessageCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutApplicationsInput = {
    id?: string
    email: string
    passwordHash: string
    walletAddress?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    isEmailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    displayName?: string | null
    avatarUrl?: string | null
    bio?: string | null
    apiCallCount?: number
    apiCallResetAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cryptoProjects?: CryptoProjectUncheckedCreateNestedManyWithoutUserInput
    businesses?: BusinessUncheckedCreateNestedManyWithoutUserInput
    identityVerification?: PrivateIdentityVerificationUncheckedCreateNestedOneWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutUserInput
    trustScoreEvents?: TrustScoreEventUncheckedCreateNestedManyWithoutUserInput
    contactMessages?: ContactMessageUncheckedCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutApplicationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApplicationsInput, UserUncheckedCreateWithoutApplicationsInput>
  }

  export type AdminNoteCreateWithoutApplicationInput = {
    id?: string
    note: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutAdminNotesInput
    project?: CryptoProjectCreateNestedOneWithoutAdminNotesInput
    business?: BusinessCreateNestedOneWithoutAdminNotesInput
    contact?: ContactMessageCreateNestedOneWithoutAdminNotesInput
  }

  export type AdminNoteUncheckedCreateWithoutApplicationInput = {
    id?: string
    authorId: string
    projectId?: string | null
    businessId?: string | null
    contactId?: string | null
    note: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminNoteCreateOrConnectWithoutApplicationInput = {
    where: AdminNoteWhereUniqueInput
    create: XOR<AdminNoteCreateWithoutApplicationInput, AdminNoteUncheckedCreateWithoutApplicationInput>
  }

  export type AdminNoteCreateManyApplicationInputEnvelope = {
    data: AdminNoteCreateManyApplicationInput | AdminNoteCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutApplicationsInput = {
    update: XOR<UserUpdateWithoutApplicationsInput, UserUncheckedUpdateWithoutApplicationsInput>
    create: XOR<UserCreateWithoutApplicationsInput, UserUncheckedCreateWithoutApplicationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApplicationsInput, UserUncheckedUpdateWithoutApplicationsInput>
  }

  export type UserUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallCount?: IntFieldUpdateOperationsInput | number
    apiCallResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cryptoProjects?: CryptoProjectUpdateManyWithoutUserNestedInput
    businesses?: BusinessUpdateManyWithoutUserNestedInput
    identityVerification?: PrivateIdentityVerificationUpdateOneWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    systemLogs?: SystemLogUpdateManyWithoutUserNestedInput
    trustScoreEvents?: TrustScoreEventUpdateManyWithoutUserNestedInput
    contactMessages?: ContactMessageUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallCount?: IntFieldUpdateOperationsInput | number
    apiCallResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cryptoProjects?: CryptoProjectUncheckedUpdateManyWithoutUserNestedInput
    businesses?: BusinessUncheckedUpdateManyWithoutUserNestedInput
    identityVerification?: PrivateIdentityVerificationUncheckedUpdateOneWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutUserNestedInput
    trustScoreEvents?: TrustScoreEventUncheckedUpdateManyWithoutUserNestedInput
    contactMessages?: ContactMessageUncheckedUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type AdminNoteUpsertWithWhereUniqueWithoutApplicationInput = {
    where: AdminNoteWhereUniqueInput
    update: XOR<AdminNoteUpdateWithoutApplicationInput, AdminNoteUncheckedUpdateWithoutApplicationInput>
    create: XOR<AdminNoteCreateWithoutApplicationInput, AdminNoteUncheckedCreateWithoutApplicationInput>
  }

  export type AdminNoteUpdateWithWhereUniqueWithoutApplicationInput = {
    where: AdminNoteWhereUniqueInput
    data: XOR<AdminNoteUpdateWithoutApplicationInput, AdminNoteUncheckedUpdateWithoutApplicationInput>
  }

  export type AdminNoteUpdateManyWithWhereWithoutApplicationInput = {
    where: AdminNoteScalarWhereInput
    data: XOR<AdminNoteUpdateManyMutationInput, AdminNoteUncheckedUpdateManyWithoutApplicationInput>
  }

  export type CryptoProjectCreateWithoutTrustScoreEventsInput = {
    id?: string
    name: string
    symbol?: string | null
    description?: string | null
    category?: string | null
    website?: string | null
    whitepaper?: string | null
    twitter?: string | null
    discord?: string | null
    telegram?: string | null
    github?: string | null
    tokenType?: $Enums.TokenType
    totalSupply?: string | null
    decimals?: number
    teamAllocationPercent?: number | null
    teamVestingMonths?: number | null
    teamCliffMonths?: number | null
    vestingType?: $Enums.VestingType | null
    initialLiquidity?: string | null
    liquidityLockMonths?: number | null
    liquidityLockTxHash?: string | null
    auditProvider?: string | null
    auditReportUrl?: string | null
    auditDate?: Date | string | null
    contractAddress?: string | null
    contractVerified?: boolean
    status?: $Enums.ProjectStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    rejectionReason?: string | null
    trustScore?: number
    trustScoreUpdatedAt?: Date | string | null
    launchDate?: Date | string | null
    softCap?: string | null
    hardCap?: string | null
    minContribution?: string | null
    maxContribution?: string | null
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCryptoProjectsInput
    adminNotes?: AdminNoteCreateNestedManyWithoutProjectInput
    documents?: ProjectDocumentCreateNestedManyWithoutProjectInput
  }

  export type CryptoProjectUncheckedCreateWithoutTrustScoreEventsInput = {
    id?: string
    userId: string
    name: string
    symbol?: string | null
    description?: string | null
    category?: string | null
    website?: string | null
    whitepaper?: string | null
    twitter?: string | null
    discord?: string | null
    telegram?: string | null
    github?: string | null
    tokenType?: $Enums.TokenType
    totalSupply?: string | null
    decimals?: number
    teamAllocationPercent?: number | null
    teamVestingMonths?: number | null
    teamCliffMonths?: number | null
    vestingType?: $Enums.VestingType | null
    initialLiquidity?: string | null
    liquidityLockMonths?: number | null
    liquidityLockTxHash?: string | null
    auditProvider?: string | null
    auditReportUrl?: string | null
    auditDate?: Date | string | null
    contractAddress?: string | null
    contractVerified?: boolean
    status?: $Enums.ProjectStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    rejectionReason?: string | null
    trustScore?: number
    trustScoreUpdatedAt?: Date | string | null
    launchDate?: Date | string | null
    softCap?: string | null
    hardCap?: string | null
    minContribution?: string | null
    maxContribution?: string | null
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutProjectInput
    documents?: ProjectDocumentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type CryptoProjectCreateOrConnectWithoutTrustScoreEventsInput = {
    where: CryptoProjectWhereUniqueInput
    create: XOR<CryptoProjectCreateWithoutTrustScoreEventsInput, CryptoProjectUncheckedCreateWithoutTrustScoreEventsInput>
  }

  export type BusinessCreateWithoutTrustScoreEventsInput = {
    id?: string
    legalName: string
    dba?: string | null
    entityType?: string | null
    jurisdiction?: string | null
    ein?: string | null
    registrationNumber?: string | null
    incorporationDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    businessEmail?: string | null
    businessPhone?: string | null
    website?: string | null
    description?: string | null
    industry?: string | null
    employeeCount?: number | null
    annualRevenue?: string | null
    linkedin?: string | null
    twitter?: string | null
    kybLevel?: $Enums.KYBLevel
    kybProvider?: string | null
    kybVerifiedAt?: Date | string | null
    kybExpiresAt?: Date | string | null
    kybRejectionReason?: string | null
    tokenType?: $Enums.TokenType | null
    raiseAmount?: string | null
    equityPercent?: number | null
    revenueSharePercent?: number | null
    minInvestment?: string | null
    maxInvestment?: string | null
    status?: $Enums.BusinessStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    rejectionReason?: string | null
    trustScore?: number
    trustScoreUpdatedAt?: Date | string | null
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBusinessesInput
    founders?: BusinessFounderCreateNestedManyWithoutBusinessInput
    documents?: BusinessDocumentCreateNestedManyWithoutBusinessInput
    adminNotes?: AdminNoteCreateNestedManyWithoutBusinessInput
    revenueReports?: RevenueReportCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutTrustScoreEventsInput = {
    id?: string
    userId: string
    legalName: string
    dba?: string | null
    entityType?: string | null
    jurisdiction?: string | null
    ein?: string | null
    registrationNumber?: string | null
    incorporationDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    businessEmail?: string | null
    businessPhone?: string | null
    website?: string | null
    description?: string | null
    industry?: string | null
    employeeCount?: number | null
    annualRevenue?: string | null
    linkedin?: string | null
    twitter?: string | null
    kybLevel?: $Enums.KYBLevel
    kybProvider?: string | null
    kybVerifiedAt?: Date | string | null
    kybExpiresAt?: Date | string | null
    kybRejectionReason?: string | null
    tokenType?: $Enums.TokenType | null
    raiseAmount?: string | null
    equityPercent?: number | null
    revenueSharePercent?: number | null
    minInvestment?: string | null
    maxInvestment?: string | null
    status?: $Enums.BusinessStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    rejectionReason?: string | null
    trustScore?: number
    trustScoreUpdatedAt?: Date | string | null
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    founders?: BusinessFounderUncheckedCreateNestedManyWithoutBusinessInput
    documents?: BusinessDocumentUncheckedCreateNestedManyWithoutBusinessInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutBusinessInput
    revenueReports?: RevenueReportUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutTrustScoreEventsInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutTrustScoreEventsInput, BusinessUncheckedCreateWithoutTrustScoreEventsInput>
  }

  export type UserCreateWithoutTrustScoreEventsInput = {
    id?: string
    email: string
    passwordHash: string
    walletAddress?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    isEmailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    displayName?: string | null
    avatarUrl?: string | null
    bio?: string | null
    apiCallCount?: number
    apiCallResetAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cryptoProjects?: CryptoProjectCreateNestedManyWithoutUserInput
    businesses?: BusinessCreateNestedManyWithoutUserInput
    identityVerification?: PrivateIdentityVerificationCreateNestedOneWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    systemLogs?: SystemLogCreateNestedManyWithoutUserInput
    contactMessages?: ContactMessageCreateNestedManyWithoutUserInput
    applications?: LaunchApplicationCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutTrustScoreEventsInput = {
    id?: string
    email: string
    passwordHash: string
    walletAddress?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    isEmailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    displayName?: string | null
    avatarUrl?: string | null
    bio?: string | null
    apiCallCount?: number
    apiCallResetAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cryptoProjects?: CryptoProjectUncheckedCreateNestedManyWithoutUserInput
    businesses?: BusinessUncheckedCreateNestedManyWithoutUserInput
    identityVerification?: PrivateIdentityVerificationUncheckedCreateNestedOneWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutUserInput
    contactMessages?: ContactMessageUncheckedCreateNestedManyWithoutUserInput
    applications?: LaunchApplicationUncheckedCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutTrustScoreEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTrustScoreEventsInput, UserUncheckedCreateWithoutTrustScoreEventsInput>
  }

  export type CryptoProjectUpsertWithoutTrustScoreEventsInput = {
    update: XOR<CryptoProjectUpdateWithoutTrustScoreEventsInput, CryptoProjectUncheckedUpdateWithoutTrustScoreEventsInput>
    create: XOR<CryptoProjectCreateWithoutTrustScoreEventsInput, CryptoProjectUncheckedCreateWithoutTrustScoreEventsInput>
    where?: CryptoProjectWhereInput
  }

  export type CryptoProjectUpdateToOneWithWhereWithoutTrustScoreEventsInput = {
    where?: CryptoProjectWhereInput
    data: XOR<CryptoProjectUpdateWithoutTrustScoreEventsInput, CryptoProjectUncheckedUpdateWithoutTrustScoreEventsInput>
  }

  export type CryptoProjectUpdateWithoutTrustScoreEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    whitepaper?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    totalSupply?: NullableStringFieldUpdateOperationsInput | string | null
    decimals?: IntFieldUpdateOperationsInput | number
    teamAllocationPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    teamVestingMonths?: NullableIntFieldUpdateOperationsInput | number | null
    teamCliffMonths?: NullableIntFieldUpdateOperationsInput | number | null
    vestingType?: NullableEnumVestingTypeFieldUpdateOperationsInput | $Enums.VestingType | null
    initialLiquidity?: NullableStringFieldUpdateOperationsInput | string | null
    liquidityLockMonths?: NullableIntFieldUpdateOperationsInput | number | null
    liquidityLockTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    auditProvider?: NullableStringFieldUpdateOperationsInput | string | null
    auditReportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    auditDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    contractVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    trustScoreUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    launchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    softCap?: NullableStringFieldUpdateOperationsInput | string | null
    hardCap?: NullableStringFieldUpdateOperationsInput | string | null
    minContribution?: NullableStringFieldUpdateOperationsInput | string | null
    maxContribution?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCryptoProjectsNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutProjectNestedInput
    documents?: ProjectDocumentUpdateManyWithoutProjectNestedInput
  }

  export type CryptoProjectUncheckedUpdateWithoutTrustScoreEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    whitepaper?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    totalSupply?: NullableStringFieldUpdateOperationsInput | string | null
    decimals?: IntFieldUpdateOperationsInput | number
    teamAllocationPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    teamVestingMonths?: NullableIntFieldUpdateOperationsInput | number | null
    teamCliffMonths?: NullableIntFieldUpdateOperationsInput | number | null
    vestingType?: NullableEnumVestingTypeFieldUpdateOperationsInput | $Enums.VestingType | null
    initialLiquidity?: NullableStringFieldUpdateOperationsInput | string | null
    liquidityLockMonths?: NullableIntFieldUpdateOperationsInput | number | null
    liquidityLockTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    auditProvider?: NullableStringFieldUpdateOperationsInput | string | null
    auditReportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    auditDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    contractVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    trustScoreUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    launchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    softCap?: NullableStringFieldUpdateOperationsInput | string | null
    hardCap?: NullableStringFieldUpdateOperationsInput | string | null
    minContribution?: NullableStringFieldUpdateOperationsInput | string | null
    maxContribution?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutProjectNestedInput
    documents?: ProjectDocumentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type BusinessUpsertWithoutTrustScoreEventsInput = {
    update: XOR<BusinessUpdateWithoutTrustScoreEventsInput, BusinessUncheckedUpdateWithoutTrustScoreEventsInput>
    create: XOR<BusinessCreateWithoutTrustScoreEventsInput, BusinessUncheckedCreateWithoutTrustScoreEventsInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutTrustScoreEventsInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutTrustScoreEventsInput, BusinessUncheckedUpdateWithoutTrustScoreEventsInput>
  }

  export type BusinessUpdateWithoutTrustScoreEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    legalName?: StringFieldUpdateOperationsInput | string
    dba?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    ein?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    incorporationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    businessEmail?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    annualRevenue?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    kybLevel?: EnumKYBLevelFieldUpdateOperationsInput | $Enums.KYBLevel
    kybProvider?: NullableStringFieldUpdateOperationsInput | string | null
    kybVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybRejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableEnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType | null
    raiseAmount?: NullableStringFieldUpdateOperationsInput | string | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    revenueSharePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    maxInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    trustScoreUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBusinessesNestedInput
    founders?: BusinessFounderUpdateManyWithoutBusinessNestedInput
    documents?: BusinessDocumentUpdateManyWithoutBusinessNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBusinessNestedInput
    revenueReports?: RevenueReportUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutTrustScoreEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    legalName?: StringFieldUpdateOperationsInput | string
    dba?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    ein?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    incorporationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    businessEmail?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    annualRevenue?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    kybLevel?: EnumKYBLevelFieldUpdateOperationsInput | $Enums.KYBLevel
    kybProvider?: NullableStringFieldUpdateOperationsInput | string | null
    kybVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybRejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableEnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType | null
    raiseAmount?: NullableStringFieldUpdateOperationsInput | string | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    revenueSharePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    maxInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    trustScoreUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founders?: BusinessFounderUncheckedUpdateManyWithoutBusinessNestedInput
    documents?: BusinessDocumentUncheckedUpdateManyWithoutBusinessNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBusinessNestedInput
    revenueReports?: RevenueReportUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type UserUpsertWithoutTrustScoreEventsInput = {
    update: XOR<UserUpdateWithoutTrustScoreEventsInput, UserUncheckedUpdateWithoutTrustScoreEventsInput>
    create: XOR<UserCreateWithoutTrustScoreEventsInput, UserUncheckedCreateWithoutTrustScoreEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTrustScoreEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTrustScoreEventsInput, UserUncheckedUpdateWithoutTrustScoreEventsInput>
  }

  export type UserUpdateWithoutTrustScoreEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallCount?: IntFieldUpdateOperationsInput | number
    apiCallResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cryptoProjects?: CryptoProjectUpdateManyWithoutUserNestedInput
    businesses?: BusinessUpdateManyWithoutUserNestedInput
    identityVerification?: PrivateIdentityVerificationUpdateOneWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    systemLogs?: SystemLogUpdateManyWithoutUserNestedInput
    contactMessages?: ContactMessageUpdateManyWithoutUserNestedInput
    applications?: LaunchApplicationUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutTrustScoreEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallCount?: IntFieldUpdateOperationsInput | number
    apiCallResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cryptoProjects?: CryptoProjectUncheckedUpdateManyWithoutUserNestedInput
    businesses?: BusinessUncheckedUpdateManyWithoutUserNestedInput
    identityVerification?: PrivateIdentityVerificationUncheckedUpdateOneWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutUserNestedInput
    contactMessages?: ContactMessageUncheckedUpdateManyWithoutUserNestedInput
    applications?: LaunchApplicationUncheckedUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateWithoutAdminNotesInput = {
    id?: string
    email: string
    passwordHash: string
    walletAddress?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    isEmailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    displayName?: string | null
    avatarUrl?: string | null
    bio?: string | null
    apiCallCount?: number
    apiCallResetAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cryptoProjects?: CryptoProjectCreateNestedManyWithoutUserInput
    businesses?: BusinessCreateNestedManyWithoutUserInput
    identityVerification?: PrivateIdentityVerificationCreateNestedOneWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    systemLogs?: SystemLogCreateNestedManyWithoutUserInput
    trustScoreEvents?: TrustScoreEventCreateNestedManyWithoutUserInput
    contactMessages?: ContactMessageCreateNestedManyWithoutUserInput
    applications?: LaunchApplicationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminNotesInput = {
    id?: string
    email: string
    passwordHash: string
    walletAddress?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    isEmailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    displayName?: string | null
    avatarUrl?: string | null
    bio?: string | null
    apiCallCount?: number
    apiCallResetAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cryptoProjects?: CryptoProjectUncheckedCreateNestedManyWithoutUserInput
    businesses?: BusinessUncheckedCreateNestedManyWithoutUserInput
    identityVerification?: PrivateIdentityVerificationUncheckedCreateNestedOneWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutUserInput
    trustScoreEvents?: TrustScoreEventUncheckedCreateNestedManyWithoutUserInput
    contactMessages?: ContactMessageUncheckedCreateNestedManyWithoutUserInput
    applications?: LaunchApplicationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminNotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminNotesInput, UserUncheckedCreateWithoutAdminNotesInput>
  }

  export type CryptoProjectCreateWithoutAdminNotesInput = {
    id?: string
    name: string
    symbol?: string | null
    description?: string | null
    category?: string | null
    website?: string | null
    whitepaper?: string | null
    twitter?: string | null
    discord?: string | null
    telegram?: string | null
    github?: string | null
    tokenType?: $Enums.TokenType
    totalSupply?: string | null
    decimals?: number
    teamAllocationPercent?: number | null
    teamVestingMonths?: number | null
    teamCliffMonths?: number | null
    vestingType?: $Enums.VestingType | null
    initialLiquidity?: string | null
    liquidityLockMonths?: number | null
    liquidityLockTxHash?: string | null
    auditProvider?: string | null
    auditReportUrl?: string | null
    auditDate?: Date | string | null
    contractAddress?: string | null
    contractVerified?: boolean
    status?: $Enums.ProjectStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    rejectionReason?: string | null
    trustScore?: number
    trustScoreUpdatedAt?: Date | string | null
    launchDate?: Date | string | null
    softCap?: string | null
    hardCap?: string | null
    minContribution?: string | null
    maxContribution?: string | null
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCryptoProjectsInput
    trustScoreEvents?: TrustScoreEventCreateNestedManyWithoutProjectInput
    documents?: ProjectDocumentCreateNestedManyWithoutProjectInput
  }

  export type CryptoProjectUncheckedCreateWithoutAdminNotesInput = {
    id?: string
    userId: string
    name: string
    symbol?: string | null
    description?: string | null
    category?: string | null
    website?: string | null
    whitepaper?: string | null
    twitter?: string | null
    discord?: string | null
    telegram?: string | null
    github?: string | null
    tokenType?: $Enums.TokenType
    totalSupply?: string | null
    decimals?: number
    teamAllocationPercent?: number | null
    teamVestingMonths?: number | null
    teamCliffMonths?: number | null
    vestingType?: $Enums.VestingType | null
    initialLiquidity?: string | null
    liquidityLockMonths?: number | null
    liquidityLockTxHash?: string | null
    auditProvider?: string | null
    auditReportUrl?: string | null
    auditDate?: Date | string | null
    contractAddress?: string | null
    contractVerified?: boolean
    status?: $Enums.ProjectStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    rejectionReason?: string | null
    trustScore?: number
    trustScoreUpdatedAt?: Date | string | null
    launchDate?: Date | string | null
    softCap?: string | null
    hardCap?: string | null
    minContribution?: string | null
    maxContribution?: string | null
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    trustScoreEvents?: TrustScoreEventUncheckedCreateNestedManyWithoutProjectInput
    documents?: ProjectDocumentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type CryptoProjectCreateOrConnectWithoutAdminNotesInput = {
    where: CryptoProjectWhereUniqueInput
    create: XOR<CryptoProjectCreateWithoutAdminNotesInput, CryptoProjectUncheckedCreateWithoutAdminNotesInput>
  }

  export type BusinessCreateWithoutAdminNotesInput = {
    id?: string
    legalName: string
    dba?: string | null
    entityType?: string | null
    jurisdiction?: string | null
    ein?: string | null
    registrationNumber?: string | null
    incorporationDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    businessEmail?: string | null
    businessPhone?: string | null
    website?: string | null
    description?: string | null
    industry?: string | null
    employeeCount?: number | null
    annualRevenue?: string | null
    linkedin?: string | null
    twitter?: string | null
    kybLevel?: $Enums.KYBLevel
    kybProvider?: string | null
    kybVerifiedAt?: Date | string | null
    kybExpiresAt?: Date | string | null
    kybRejectionReason?: string | null
    tokenType?: $Enums.TokenType | null
    raiseAmount?: string | null
    equityPercent?: number | null
    revenueSharePercent?: number | null
    minInvestment?: string | null
    maxInvestment?: string | null
    status?: $Enums.BusinessStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    rejectionReason?: string | null
    trustScore?: number
    trustScoreUpdatedAt?: Date | string | null
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBusinessesInput
    founders?: BusinessFounderCreateNestedManyWithoutBusinessInput
    documents?: BusinessDocumentCreateNestedManyWithoutBusinessInput
    trustScoreEvents?: TrustScoreEventCreateNestedManyWithoutBusinessInput
    revenueReports?: RevenueReportCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutAdminNotesInput = {
    id?: string
    userId: string
    legalName: string
    dba?: string | null
    entityType?: string | null
    jurisdiction?: string | null
    ein?: string | null
    registrationNumber?: string | null
    incorporationDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    businessEmail?: string | null
    businessPhone?: string | null
    website?: string | null
    description?: string | null
    industry?: string | null
    employeeCount?: number | null
    annualRevenue?: string | null
    linkedin?: string | null
    twitter?: string | null
    kybLevel?: $Enums.KYBLevel
    kybProvider?: string | null
    kybVerifiedAt?: Date | string | null
    kybExpiresAt?: Date | string | null
    kybRejectionReason?: string | null
    tokenType?: $Enums.TokenType | null
    raiseAmount?: string | null
    equityPercent?: number | null
    revenueSharePercent?: number | null
    minInvestment?: string | null
    maxInvestment?: string | null
    status?: $Enums.BusinessStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    rejectionReason?: string | null
    trustScore?: number
    trustScoreUpdatedAt?: Date | string | null
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    founders?: BusinessFounderUncheckedCreateNestedManyWithoutBusinessInput
    documents?: BusinessDocumentUncheckedCreateNestedManyWithoutBusinessInput
    trustScoreEvents?: TrustScoreEventUncheckedCreateNestedManyWithoutBusinessInput
    revenueReports?: RevenueReportUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutAdminNotesInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutAdminNotesInput, BusinessUncheckedCreateWithoutAdminNotesInput>
  }

  export type ContactMessageCreateWithoutAdminNotesInput = {
    id?: string
    name: string
    email: string
    subject?: string | null
    message: string
    category?: string | null
    status?: $Enums.MessageStatus
    assignedTo?: string | null
    responseText?: string | null
    respondedAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutContactMessagesInput
  }

  export type ContactMessageUncheckedCreateWithoutAdminNotesInput = {
    id?: string
    userId?: string | null
    name: string
    email: string
    subject?: string | null
    message: string
    category?: string | null
    status?: $Enums.MessageStatus
    assignedTo?: string | null
    responseText?: string | null
    respondedAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactMessageCreateOrConnectWithoutAdminNotesInput = {
    where: ContactMessageWhereUniqueInput
    create: XOR<ContactMessageCreateWithoutAdminNotesInput, ContactMessageUncheckedCreateWithoutAdminNotesInput>
  }

  export type LaunchApplicationCreateWithoutAdminNotesInput = {
    id?: string
    applicantName: string
    applicantEmail: string
    applicantRole?: string | null
    companyName?: string | null
    website?: string | null
    type: $Enums.ApplicationType
    description: string
    raiseAmount?: string | null
    timeline?: string | null
    twitter?: string | null
    discord?: string | null
    telegram?: string | null
    referralSource?: string | null
    status?: $Enums.ApplicationStatus
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutApplicationsInput
  }

  export type LaunchApplicationUncheckedCreateWithoutAdminNotesInput = {
    id?: string
    userId?: string | null
    applicantName: string
    applicantEmail: string
    applicantRole?: string | null
    companyName?: string | null
    website?: string | null
    type: $Enums.ApplicationType
    description: string
    raiseAmount?: string | null
    timeline?: string | null
    twitter?: string | null
    discord?: string | null
    telegram?: string | null
    referralSource?: string | null
    status?: $Enums.ApplicationStatus
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaunchApplicationCreateOrConnectWithoutAdminNotesInput = {
    where: LaunchApplicationWhereUniqueInput
    create: XOR<LaunchApplicationCreateWithoutAdminNotesInput, LaunchApplicationUncheckedCreateWithoutAdminNotesInput>
  }

  export type UserUpsertWithoutAdminNotesInput = {
    update: XOR<UserUpdateWithoutAdminNotesInput, UserUncheckedUpdateWithoutAdminNotesInput>
    create: XOR<UserCreateWithoutAdminNotesInput, UserUncheckedCreateWithoutAdminNotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminNotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminNotesInput, UserUncheckedUpdateWithoutAdminNotesInput>
  }

  export type UserUpdateWithoutAdminNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallCount?: IntFieldUpdateOperationsInput | number
    apiCallResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cryptoProjects?: CryptoProjectUpdateManyWithoutUserNestedInput
    businesses?: BusinessUpdateManyWithoutUserNestedInput
    identityVerification?: PrivateIdentityVerificationUpdateOneWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    systemLogs?: SystemLogUpdateManyWithoutUserNestedInput
    trustScoreEvents?: TrustScoreEventUpdateManyWithoutUserNestedInput
    contactMessages?: ContactMessageUpdateManyWithoutUserNestedInput
    applications?: LaunchApplicationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallCount?: IntFieldUpdateOperationsInput | number
    apiCallResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cryptoProjects?: CryptoProjectUncheckedUpdateManyWithoutUserNestedInput
    businesses?: BusinessUncheckedUpdateManyWithoutUserNestedInput
    identityVerification?: PrivateIdentityVerificationUncheckedUpdateOneWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutUserNestedInput
    trustScoreEvents?: TrustScoreEventUncheckedUpdateManyWithoutUserNestedInput
    contactMessages?: ContactMessageUncheckedUpdateManyWithoutUserNestedInput
    applications?: LaunchApplicationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CryptoProjectUpsertWithoutAdminNotesInput = {
    update: XOR<CryptoProjectUpdateWithoutAdminNotesInput, CryptoProjectUncheckedUpdateWithoutAdminNotesInput>
    create: XOR<CryptoProjectCreateWithoutAdminNotesInput, CryptoProjectUncheckedCreateWithoutAdminNotesInput>
    where?: CryptoProjectWhereInput
  }

  export type CryptoProjectUpdateToOneWithWhereWithoutAdminNotesInput = {
    where?: CryptoProjectWhereInput
    data: XOR<CryptoProjectUpdateWithoutAdminNotesInput, CryptoProjectUncheckedUpdateWithoutAdminNotesInput>
  }

  export type CryptoProjectUpdateWithoutAdminNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    whitepaper?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    totalSupply?: NullableStringFieldUpdateOperationsInput | string | null
    decimals?: IntFieldUpdateOperationsInput | number
    teamAllocationPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    teamVestingMonths?: NullableIntFieldUpdateOperationsInput | number | null
    teamCliffMonths?: NullableIntFieldUpdateOperationsInput | number | null
    vestingType?: NullableEnumVestingTypeFieldUpdateOperationsInput | $Enums.VestingType | null
    initialLiquidity?: NullableStringFieldUpdateOperationsInput | string | null
    liquidityLockMonths?: NullableIntFieldUpdateOperationsInput | number | null
    liquidityLockTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    auditProvider?: NullableStringFieldUpdateOperationsInput | string | null
    auditReportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    auditDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    contractVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    trustScoreUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    launchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    softCap?: NullableStringFieldUpdateOperationsInput | string | null
    hardCap?: NullableStringFieldUpdateOperationsInput | string | null
    minContribution?: NullableStringFieldUpdateOperationsInput | string | null
    maxContribution?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCryptoProjectsNestedInput
    trustScoreEvents?: TrustScoreEventUpdateManyWithoutProjectNestedInput
    documents?: ProjectDocumentUpdateManyWithoutProjectNestedInput
  }

  export type CryptoProjectUncheckedUpdateWithoutAdminNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    whitepaper?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    totalSupply?: NullableStringFieldUpdateOperationsInput | string | null
    decimals?: IntFieldUpdateOperationsInput | number
    teamAllocationPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    teamVestingMonths?: NullableIntFieldUpdateOperationsInput | number | null
    teamCliffMonths?: NullableIntFieldUpdateOperationsInput | number | null
    vestingType?: NullableEnumVestingTypeFieldUpdateOperationsInput | $Enums.VestingType | null
    initialLiquidity?: NullableStringFieldUpdateOperationsInput | string | null
    liquidityLockMonths?: NullableIntFieldUpdateOperationsInput | number | null
    liquidityLockTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    auditProvider?: NullableStringFieldUpdateOperationsInput | string | null
    auditReportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    auditDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    contractVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    trustScoreUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    launchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    softCap?: NullableStringFieldUpdateOperationsInput | string | null
    hardCap?: NullableStringFieldUpdateOperationsInput | string | null
    minContribution?: NullableStringFieldUpdateOperationsInput | string | null
    maxContribution?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trustScoreEvents?: TrustScoreEventUncheckedUpdateManyWithoutProjectNestedInput
    documents?: ProjectDocumentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type BusinessUpsertWithoutAdminNotesInput = {
    update: XOR<BusinessUpdateWithoutAdminNotesInput, BusinessUncheckedUpdateWithoutAdminNotesInput>
    create: XOR<BusinessCreateWithoutAdminNotesInput, BusinessUncheckedCreateWithoutAdminNotesInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutAdminNotesInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutAdminNotesInput, BusinessUncheckedUpdateWithoutAdminNotesInput>
  }

  export type BusinessUpdateWithoutAdminNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    legalName?: StringFieldUpdateOperationsInput | string
    dba?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    ein?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    incorporationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    businessEmail?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    annualRevenue?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    kybLevel?: EnumKYBLevelFieldUpdateOperationsInput | $Enums.KYBLevel
    kybProvider?: NullableStringFieldUpdateOperationsInput | string | null
    kybVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybRejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableEnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType | null
    raiseAmount?: NullableStringFieldUpdateOperationsInput | string | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    revenueSharePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    maxInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    trustScoreUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBusinessesNestedInput
    founders?: BusinessFounderUpdateManyWithoutBusinessNestedInput
    documents?: BusinessDocumentUpdateManyWithoutBusinessNestedInput
    trustScoreEvents?: TrustScoreEventUpdateManyWithoutBusinessNestedInput
    revenueReports?: RevenueReportUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutAdminNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    legalName?: StringFieldUpdateOperationsInput | string
    dba?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    ein?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    incorporationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    businessEmail?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    annualRevenue?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    kybLevel?: EnumKYBLevelFieldUpdateOperationsInput | $Enums.KYBLevel
    kybProvider?: NullableStringFieldUpdateOperationsInput | string | null
    kybVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybRejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableEnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType | null
    raiseAmount?: NullableStringFieldUpdateOperationsInput | string | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    revenueSharePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    maxInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    trustScoreUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founders?: BusinessFounderUncheckedUpdateManyWithoutBusinessNestedInput
    documents?: BusinessDocumentUncheckedUpdateManyWithoutBusinessNestedInput
    trustScoreEvents?: TrustScoreEventUncheckedUpdateManyWithoutBusinessNestedInput
    revenueReports?: RevenueReportUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type ContactMessageUpsertWithoutAdminNotesInput = {
    update: XOR<ContactMessageUpdateWithoutAdminNotesInput, ContactMessageUncheckedUpdateWithoutAdminNotesInput>
    create: XOR<ContactMessageCreateWithoutAdminNotesInput, ContactMessageUncheckedCreateWithoutAdminNotesInput>
    where?: ContactMessageWhereInput
  }

  export type ContactMessageUpdateToOneWithWhereWithoutAdminNotesInput = {
    where?: ContactMessageWhereInput
    data: XOR<ContactMessageUpdateWithoutAdminNotesInput, ContactMessageUncheckedUpdateWithoutAdminNotesInput>
  }

  export type ContactMessageUpdateWithoutAdminNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    responseText?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutContactMessagesNestedInput
  }

  export type ContactMessageUncheckedUpdateWithoutAdminNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    responseText?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunchApplicationUpsertWithoutAdminNotesInput = {
    update: XOR<LaunchApplicationUpdateWithoutAdminNotesInput, LaunchApplicationUncheckedUpdateWithoutAdminNotesInput>
    create: XOR<LaunchApplicationCreateWithoutAdminNotesInput, LaunchApplicationUncheckedCreateWithoutAdminNotesInput>
    where?: LaunchApplicationWhereInput
  }

  export type LaunchApplicationUpdateToOneWithWhereWithoutAdminNotesInput = {
    where?: LaunchApplicationWhereInput
    data: XOR<LaunchApplicationUpdateWithoutAdminNotesInput, LaunchApplicationUncheckedUpdateWithoutAdminNotesInput>
  }

  export type LaunchApplicationUpdateWithoutAdminNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantEmail?: StringFieldUpdateOperationsInput | string
    applicantRole?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumApplicationTypeFieldUpdateOperationsInput | $Enums.ApplicationType
    description?: StringFieldUpdateOperationsInput | string
    raiseAmount?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutApplicationsNestedInput
  }

  export type LaunchApplicationUncheckedUpdateWithoutAdminNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantEmail?: StringFieldUpdateOperationsInput | string
    applicantRole?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumApplicationTypeFieldUpdateOperationsInput | $Enums.ApplicationType
    description?: StringFieldUpdateOperationsInput | string
    raiseAmount?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutSystemLogsInput = {
    id?: string
    email: string
    passwordHash: string
    walletAddress?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    isEmailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    displayName?: string | null
    avatarUrl?: string | null
    bio?: string | null
    apiCallCount?: number
    apiCallResetAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cryptoProjects?: CryptoProjectCreateNestedManyWithoutUserInput
    businesses?: BusinessCreateNestedManyWithoutUserInput
    identityVerification?: PrivateIdentityVerificationCreateNestedOneWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    trustScoreEvents?: TrustScoreEventCreateNestedManyWithoutUserInput
    contactMessages?: ContactMessageCreateNestedManyWithoutUserInput
    applications?: LaunchApplicationCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutSystemLogsInput = {
    id?: string
    email: string
    passwordHash: string
    walletAddress?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    isEmailVerified?: boolean
    emailVerifiedAt?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    failedLoginCount?: number
    lockedUntil?: Date | string | null
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    displayName?: string | null
    avatarUrl?: string | null
    bio?: string | null
    apiCallCount?: number
    apiCallResetAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cryptoProjects?: CryptoProjectUncheckedCreateNestedManyWithoutUserInput
    businesses?: BusinessUncheckedCreateNestedManyWithoutUserInput
    identityVerification?: PrivateIdentityVerificationUncheckedCreateNestedOneWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    trustScoreEvents?: TrustScoreEventUncheckedCreateNestedManyWithoutUserInput
    contactMessages?: ContactMessageUncheckedCreateNestedManyWithoutUserInput
    applications?: LaunchApplicationUncheckedCreateNestedManyWithoutUserInput
    adminNotes?: AdminNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutSystemLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSystemLogsInput, UserUncheckedCreateWithoutSystemLogsInput>
  }

  export type UserUpsertWithoutSystemLogsInput = {
    update: XOR<UserUpdateWithoutSystemLogsInput, UserUncheckedUpdateWithoutSystemLogsInput>
    create: XOR<UserCreateWithoutSystemLogsInput, UserUncheckedCreateWithoutSystemLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSystemLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSystemLogsInput, UserUncheckedUpdateWithoutSystemLogsInput>
  }

  export type UserUpdateWithoutSystemLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallCount?: IntFieldUpdateOperationsInput | number
    apiCallResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cryptoProjects?: CryptoProjectUpdateManyWithoutUserNestedInput
    businesses?: BusinessUpdateManyWithoutUserNestedInput
    identityVerification?: PrivateIdentityVerificationUpdateOneWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    trustScoreEvents?: TrustScoreEventUpdateManyWithoutUserNestedInput
    contactMessages?: ContactMessageUpdateManyWithoutUserNestedInput
    applications?: LaunchApplicationUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutSystemLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    failedLoginCount?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    apiCallCount?: IntFieldUpdateOperationsInput | number
    apiCallResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cryptoProjects?: CryptoProjectUncheckedUpdateManyWithoutUserNestedInput
    businesses?: BusinessUncheckedUpdateManyWithoutUserNestedInput
    identityVerification?: PrivateIdentityVerificationUncheckedUpdateOneWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    trustScoreEvents?: TrustScoreEventUncheckedUpdateManyWithoutUserNestedInput
    contactMessages?: ContactMessageUncheckedUpdateManyWithoutUserNestedInput
    applications?: LaunchApplicationUncheckedUpdateManyWithoutUserNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type CryptoProjectCreateManyUserInput = {
    id?: string
    name: string
    symbol?: string | null
    description?: string | null
    category?: string | null
    website?: string | null
    whitepaper?: string | null
    twitter?: string | null
    discord?: string | null
    telegram?: string | null
    github?: string | null
    tokenType?: $Enums.TokenType
    totalSupply?: string | null
    decimals?: number
    teamAllocationPercent?: number | null
    teamVestingMonths?: number | null
    teamCliffMonths?: number | null
    vestingType?: $Enums.VestingType | null
    initialLiquidity?: string | null
    liquidityLockMonths?: number | null
    liquidityLockTxHash?: string | null
    auditProvider?: string | null
    auditReportUrl?: string | null
    auditDate?: Date | string | null
    contractAddress?: string | null
    contractVerified?: boolean
    status?: $Enums.ProjectStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    rejectionReason?: string | null
    trustScore?: number
    trustScoreUpdatedAt?: Date | string | null
    launchDate?: Date | string | null
    softCap?: string | null
    hardCap?: string | null
    minContribution?: string | null
    maxContribution?: string | null
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessCreateManyUserInput = {
    id?: string
    legalName: string
    dba?: string | null
    entityType?: string | null
    jurisdiction?: string | null
    ein?: string | null
    registrationNumber?: string | null
    incorporationDate?: Date | string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    businessEmail?: string | null
    businessPhone?: string | null
    website?: string | null
    description?: string | null
    industry?: string | null
    employeeCount?: number | null
    annualRevenue?: string | null
    linkedin?: string | null
    twitter?: string | null
    kybLevel?: $Enums.KYBLevel
    kybProvider?: string | null
    kybVerifiedAt?: Date | string | null
    kybExpiresAt?: Date | string | null
    kybRejectionReason?: string | null
    tokenType?: $Enums.TokenType | null
    raiseAmount?: string | null
    equityPercent?: number | null
    revenueSharePercent?: number | null
    minInvestment?: string | null
    maxInvestment?: string | null
    status?: $Enums.BusinessStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    rejectionReason?: string | null
    trustScore?: number
    trustScoreUpdatedAt?: Date | string | null
    isVerified?: boolean
    isFeatured?: boolean
    isPaused?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    token: string
    refreshToken?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    isRevoked?: boolean
    revokedAt?: Date | string | null
    revokedReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemLogCreateManyUserInput = {
    id?: string
    level: $Enums.LogLevel
    category: $Enums.LogCategory
    action: string
    message: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    requestId?: string | null
    endpoint?: string | null
    method?: string | null
    statusCode?: number | null
    responseTime?: number | null
    createdAt?: Date | string
  }

  export type TrustScoreEventCreateManyUserInput = {
    id?: string
    projectId?: string | null
    businessId?: string | null
    eventType: $Enums.TrustScoreEventType
    points: number
    reason: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredBy?: string | null
    createdAt?: Date | string
  }

  export type ContactMessageCreateManyUserInput = {
    id?: string
    name: string
    email: string
    subject?: string | null
    message: string
    category?: string | null
    status?: $Enums.MessageStatus
    assignedTo?: string | null
    responseText?: string | null
    respondedAt?: Date | string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LaunchApplicationCreateManyUserInput = {
    id?: string
    applicantName: string
    applicantEmail: string
    applicantRole?: string | null
    companyName?: string | null
    website?: string | null
    type: $Enums.ApplicationType
    description: string
    raiseAmount?: string | null
    timeline?: string | null
    twitter?: string | null
    discord?: string | null
    telegram?: string | null
    referralSource?: string | null
    status?: $Enums.ApplicationStatus
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminNoteCreateManyAuthorInput = {
    id?: string
    projectId?: string | null
    businessId?: string | null
    contactId?: string | null
    applicationId?: string | null
    note: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CryptoProjectUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    whitepaper?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    totalSupply?: NullableStringFieldUpdateOperationsInput | string | null
    decimals?: IntFieldUpdateOperationsInput | number
    teamAllocationPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    teamVestingMonths?: NullableIntFieldUpdateOperationsInput | number | null
    teamCliffMonths?: NullableIntFieldUpdateOperationsInput | number | null
    vestingType?: NullableEnumVestingTypeFieldUpdateOperationsInput | $Enums.VestingType | null
    initialLiquidity?: NullableStringFieldUpdateOperationsInput | string | null
    liquidityLockMonths?: NullableIntFieldUpdateOperationsInput | number | null
    liquidityLockTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    auditProvider?: NullableStringFieldUpdateOperationsInput | string | null
    auditReportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    auditDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    contractVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    trustScoreUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    launchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    softCap?: NullableStringFieldUpdateOperationsInput | string | null
    hardCap?: NullableStringFieldUpdateOperationsInput | string | null
    minContribution?: NullableStringFieldUpdateOperationsInput | string | null
    maxContribution?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trustScoreEvents?: TrustScoreEventUpdateManyWithoutProjectNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutProjectNestedInput
    documents?: ProjectDocumentUpdateManyWithoutProjectNestedInput
  }

  export type CryptoProjectUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    whitepaper?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    totalSupply?: NullableStringFieldUpdateOperationsInput | string | null
    decimals?: IntFieldUpdateOperationsInput | number
    teamAllocationPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    teamVestingMonths?: NullableIntFieldUpdateOperationsInput | number | null
    teamCliffMonths?: NullableIntFieldUpdateOperationsInput | number | null
    vestingType?: NullableEnumVestingTypeFieldUpdateOperationsInput | $Enums.VestingType | null
    initialLiquidity?: NullableStringFieldUpdateOperationsInput | string | null
    liquidityLockMonths?: NullableIntFieldUpdateOperationsInput | number | null
    liquidityLockTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    auditProvider?: NullableStringFieldUpdateOperationsInput | string | null
    auditReportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    auditDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    contractVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    trustScoreUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    launchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    softCap?: NullableStringFieldUpdateOperationsInput | string | null
    hardCap?: NullableStringFieldUpdateOperationsInput | string | null
    minContribution?: NullableStringFieldUpdateOperationsInput | string | null
    maxContribution?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trustScoreEvents?: TrustScoreEventUncheckedUpdateManyWithoutProjectNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutProjectNestedInput
    documents?: ProjectDocumentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type CryptoProjectUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    whitepaper?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    totalSupply?: NullableStringFieldUpdateOperationsInput | string | null
    decimals?: IntFieldUpdateOperationsInput | number
    teamAllocationPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    teamVestingMonths?: NullableIntFieldUpdateOperationsInput | number | null
    teamCliffMonths?: NullableIntFieldUpdateOperationsInput | number | null
    vestingType?: NullableEnumVestingTypeFieldUpdateOperationsInput | $Enums.VestingType | null
    initialLiquidity?: NullableStringFieldUpdateOperationsInput | string | null
    liquidityLockMonths?: NullableIntFieldUpdateOperationsInput | number | null
    liquidityLockTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    auditProvider?: NullableStringFieldUpdateOperationsInput | string | null
    auditReportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    auditDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contractAddress?: NullableStringFieldUpdateOperationsInput | string | null
    contractVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    trustScoreUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    launchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    softCap?: NullableStringFieldUpdateOperationsInput | string | null
    hardCap?: NullableStringFieldUpdateOperationsInput | string | null
    minContribution?: NullableStringFieldUpdateOperationsInput | string | null
    maxContribution?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    legalName?: StringFieldUpdateOperationsInput | string
    dba?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    ein?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    incorporationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    businessEmail?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    annualRevenue?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    kybLevel?: EnumKYBLevelFieldUpdateOperationsInput | $Enums.KYBLevel
    kybProvider?: NullableStringFieldUpdateOperationsInput | string | null
    kybVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybRejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableEnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType | null
    raiseAmount?: NullableStringFieldUpdateOperationsInput | string | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    revenueSharePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    maxInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    trustScoreUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founders?: BusinessFounderUpdateManyWithoutBusinessNestedInput
    documents?: BusinessDocumentUpdateManyWithoutBusinessNestedInput
    trustScoreEvents?: TrustScoreEventUpdateManyWithoutBusinessNestedInput
    adminNotes?: AdminNoteUpdateManyWithoutBusinessNestedInput
    revenueReports?: RevenueReportUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    legalName?: StringFieldUpdateOperationsInput | string
    dba?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    ein?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    incorporationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    businessEmail?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    annualRevenue?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    kybLevel?: EnumKYBLevelFieldUpdateOperationsInput | $Enums.KYBLevel
    kybProvider?: NullableStringFieldUpdateOperationsInput | string | null
    kybVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybRejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableEnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType | null
    raiseAmount?: NullableStringFieldUpdateOperationsInput | string | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    revenueSharePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    maxInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    trustScoreUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    founders?: BusinessFounderUncheckedUpdateManyWithoutBusinessNestedInput
    documents?: BusinessDocumentUncheckedUpdateManyWithoutBusinessNestedInput
    trustScoreEvents?: TrustScoreEventUncheckedUpdateManyWithoutBusinessNestedInput
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutBusinessNestedInput
    revenueReports?: RevenueReportUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    legalName?: StringFieldUpdateOperationsInput | string
    dba?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    jurisdiction?: NullableStringFieldUpdateOperationsInput | string | null
    ein?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    incorporationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    businessEmail?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    annualRevenue?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    kybLevel?: EnumKYBLevelFieldUpdateOperationsInput | $Enums.KYBLevel
    kybProvider?: NullableStringFieldUpdateOperationsInput | string | null
    kybVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kybRejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    tokenType?: NullableEnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType | null
    raiseAmount?: NullableStringFieldUpdateOperationsInput | string | null
    equityPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    revenueSharePercent?: NullableFloatFieldUpdateOperationsInput | number | null
    minInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    maxInvestment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBusinessStatusFieldUpdateOperationsInput | $Enums.BusinessStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    trustScore?: IntFieldUpdateOperationsInput | number
    trustScoreUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    category?: EnumLogCategoryFieldUpdateOperationsInput | $Enums.LogCategory
    action?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    category?: EnumLogCategoryFieldUpdateOperationsInput | $Enums.LogCategory
    action?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    category?: EnumLogCategoryFieldUpdateOperationsInput | $Enums.LogCategory
    action?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrustScoreEventUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumTrustScoreEventTypeFieldUpdateOperationsInput | $Enums.TrustScoreEventType
    points?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: CryptoProjectUpdateOneWithoutTrustScoreEventsNestedInput
    business?: BusinessUpdateOneWithoutTrustScoreEventsNestedInput
  }

  export type TrustScoreEventUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumTrustScoreEventTypeFieldUpdateOperationsInput | $Enums.TrustScoreEventType
    points?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrustScoreEventUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumTrustScoreEventTypeFieldUpdateOperationsInput | $Enums.TrustScoreEventType
    points?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactMessageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    responseText?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminNotes?: AdminNoteUpdateManyWithoutContactNestedInput
  }

  export type ContactMessageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    responseText?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactMessageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    responseText?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaunchApplicationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantEmail?: StringFieldUpdateOperationsInput | string
    applicantRole?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumApplicationTypeFieldUpdateOperationsInput | $Enums.ApplicationType
    description?: StringFieldUpdateOperationsInput | string
    raiseAmount?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminNotes?: AdminNoteUpdateManyWithoutApplicationNestedInput
  }

  export type LaunchApplicationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantEmail?: StringFieldUpdateOperationsInput | string
    applicantRole?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumApplicationTypeFieldUpdateOperationsInput | $Enums.ApplicationType
    description?: StringFieldUpdateOperationsInput | string
    raiseAmount?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminNotes?: AdminNoteUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type LaunchApplicationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicantName?: StringFieldUpdateOperationsInput | string
    applicantEmail?: StringFieldUpdateOperationsInput | string
    applicantRole?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumApplicationTypeFieldUpdateOperationsInput | $Enums.ApplicationType
    description?: StringFieldUpdateOperationsInput | string
    raiseAmount?: NullableStringFieldUpdateOperationsInput | string | null
    timeline?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    referralSource?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminNoteUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: CryptoProjectUpdateOneWithoutAdminNotesNestedInput
    business?: BusinessUpdateOneWithoutAdminNotesNestedInput
    contact?: ContactMessageUpdateOneWithoutAdminNotesNestedInput
    application?: LaunchApplicationUpdateOneWithoutAdminNotesNestedInput
  }

  export type AdminNoteUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    applicationId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminNoteUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    applicationId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrustScoreEventCreateManyProjectInput = {
    id?: string
    businessId?: string | null
    userId?: string | null
    eventType: $Enums.TrustScoreEventType
    points: number
    reason: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredBy?: string | null
    createdAt?: Date | string
  }

  export type AdminNoteCreateManyProjectInput = {
    id?: string
    authorId: string
    businessId?: string | null
    contactId?: string | null
    applicationId?: string | null
    note: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectDocumentCreateManyProjectInput = {
    id?: string
    name: string
    type: string
    fileUrl: string
    fileHash?: string | null
    fileSize?: number | null
    mimeType?: string | null
    isPublic?: boolean
    uploadedAt?: Date | string
  }

  export type TrustScoreEventUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumTrustScoreEventTypeFieldUpdateOperationsInput | $Enums.TrustScoreEventType
    points?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneWithoutTrustScoreEventsNestedInput
    user?: UserUpdateOneWithoutTrustScoreEventsNestedInput
  }

  export type TrustScoreEventUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumTrustScoreEventTypeFieldUpdateOperationsInput | $Enums.TrustScoreEventType
    points?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrustScoreEventUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumTrustScoreEventTypeFieldUpdateOperationsInput | $Enums.TrustScoreEventType
    points?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminNoteUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutAdminNotesNestedInput
    business?: BusinessUpdateOneWithoutAdminNotesNestedInput
    contact?: ContactMessageUpdateOneWithoutAdminNotesNestedInput
    application?: LaunchApplicationUpdateOneWithoutAdminNotesNestedInput
  }

  export type AdminNoteUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    applicationId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminNoteUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    applicationId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectDocumentUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileHash?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectDocumentUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileHash?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectDocumentUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileHash?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessFounderCreateManyBusinessInput = {
    id?: string
    name: string
    role: string
    email?: string | null
    ownershipPercent?: number | null
    walletAddress?: string | null
    linkedinUrl?: string | null
    kycVerified?: boolean
    kycVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessDocumentCreateManyBusinessInput = {
    id?: string
    name: string
    type: string
    fileUrl: string
    fileHash?: string | null
    fileSize?: number | null
    mimeType?: string | null
    isPublic?: boolean
    isVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    uploadedAt?: Date | string
  }

  export type TrustScoreEventCreateManyBusinessInput = {
    id?: string
    projectId?: string | null
    userId?: string | null
    eventType: $Enums.TrustScoreEventType
    points: number
    reason: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredBy?: string | null
    createdAt?: Date | string
  }

  export type AdminNoteCreateManyBusinessInput = {
    id?: string
    authorId: string
    projectId?: string | null
    contactId?: string | null
    applicationId?: string | null
    note: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RevenueReportCreateManyBusinessInput = {
    id?: string
    period: string
    periodStart: Date | string
    periodEnd: Date | string
    grossRevenue: string
    eligibleRevenue?: string | null
    distributionAmount?: string | null
    documentUrl?: string | null
    documentHash?: string | null
    isVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    submittedAt?: Date | string
  }

  export type BusinessFounderUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessFounderUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessFounderUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinUrl?: NullableStringFieldUpdateOperationsInput | string | null
    kycVerified?: BoolFieldUpdateOperationsInput | boolean
    kycVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessDocumentUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileHash?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessDocumentUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileHash?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessDocumentUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileHash?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrustScoreEventUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumTrustScoreEventTypeFieldUpdateOperationsInput | $Enums.TrustScoreEventType
    points?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: CryptoProjectUpdateOneWithoutTrustScoreEventsNestedInput
    user?: UserUpdateOneWithoutTrustScoreEventsNestedInput
  }

  export type TrustScoreEventUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumTrustScoreEventTypeFieldUpdateOperationsInput | $Enums.TrustScoreEventType
    points?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrustScoreEventUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumTrustScoreEventTypeFieldUpdateOperationsInput | $Enums.TrustScoreEventType
    points?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminNoteUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutAdminNotesNestedInput
    project?: CryptoProjectUpdateOneWithoutAdminNotesNestedInput
    contact?: ContactMessageUpdateOneWithoutAdminNotesNestedInput
    application?: LaunchApplicationUpdateOneWithoutAdminNotesNestedInput
  }

  export type AdminNoteUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    applicationId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminNoteUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    applicationId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueReportUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    grossRevenue?: StringFieldUpdateOperationsInput | string
    eligibleRevenue?: NullableStringFieldUpdateOperationsInput | string | null
    distributionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueReportUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    grossRevenue?: StringFieldUpdateOperationsInput | string
    eligibleRevenue?: NullableStringFieldUpdateOperationsInput | string | null
    distributionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RevenueReportUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    grossRevenue?: StringFieldUpdateOperationsInput | string
    eligibleRevenue?: NullableStringFieldUpdateOperationsInput | string | null
    distributionAmount?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    documentHash?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminNoteCreateManyContactInput = {
    id?: string
    authorId: string
    projectId?: string | null
    businessId?: string | null
    applicationId?: string | null
    note: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminNoteUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutAdminNotesNestedInput
    project?: CryptoProjectUpdateOneWithoutAdminNotesNestedInput
    business?: BusinessUpdateOneWithoutAdminNotesNestedInput
    application?: LaunchApplicationUpdateOneWithoutAdminNotesNestedInput
  }

  export type AdminNoteUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    applicationId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminNoteUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    applicationId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminNoteCreateManyApplicationInput = {
    id?: string
    authorId: string
    projectId?: string | null
    businessId?: string | null
    contactId?: string | null
    note: string
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminNoteUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutAdminNotesNestedInput
    project?: CryptoProjectUpdateOneWithoutAdminNotesNestedInput
    business?: BusinessUpdateOneWithoutAdminNotesNestedInput
    contact?: ContactMessageUpdateOneWithoutAdminNotesNestedInput
  }

  export type AdminNoteUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminNoteUncheckedUpdateManyWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    projectId?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CryptoProjectCountOutputTypeDefaultArgs instead
     */
    export type CryptoProjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CryptoProjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessCountOutputTypeDefaultArgs instead
     */
    export type BusinessCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactMessageCountOutputTypeDefaultArgs instead
     */
    export type ContactMessageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactMessageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LaunchApplicationCountOutputTypeDefaultArgs instead
     */
    export type LaunchApplicationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LaunchApplicationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CryptoProjectDefaultArgs instead
     */
    export type CryptoProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CryptoProjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectDocumentDefaultArgs instead
     */
    export type ProjectDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectDocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessDefaultArgs instead
     */
    export type BusinessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessFounderDefaultArgs instead
     */
    export type BusinessFounderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessFounderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BusinessDocumentDefaultArgs instead
     */
    export type BusinessDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BusinessDocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RevenueReportDefaultArgs instead
     */
    export type RevenueReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RevenueReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PrivateIdentityVerificationDefaultArgs instead
     */
    export type PrivateIdentityVerificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PrivateIdentityVerificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactMessageDefaultArgs instead
     */
    export type ContactMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LaunchApplicationDefaultArgs instead
     */
    export type LaunchApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LaunchApplicationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrustScoreEventDefaultArgs instead
     */
    export type TrustScoreEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrustScoreEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminNoteDefaultArgs instead
     */
    export type AdminNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminNoteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemLogDefaultArgs instead
     */
    export type SystemLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DexPairDefaultArgs instead
     */
    export type DexPairArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DexPairDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RateLimitRecordDefaultArgs instead
     */
    export type RateLimitRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RateLimitRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SecurityEventDefaultArgs instead
     */
    export type SecurityEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SecurityEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BlockedEntityDefaultArgs instead
     */
    export type BlockedEntityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BlockedEntityDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}